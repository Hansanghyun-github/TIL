### 파이프라인 프로토콜

전송한 패킷에 대한 확인 응답을 받지 않고도, 여러 개의 패킷을 연속으로 전송하는 프로토콜

전송 속도를 높인다는 장점이 있지만,
패킷 손실로 인해 순서가 어긋나면, 어긋난 패킷부터 다시 보내야 하는 오버헤드가 발생할 수 있다.

파이프라이닝에서도 패킷 손상과 손실, 순서가 맞지 않는 전송이 발생하는데, 이러한 오류에 대해 두 가지 기본적인 접근 방법이 있다.
바로 **Go-Back-N(GBN)**과 **Selective Repeat(SR)**이다.

`GBN(Go-Back-N)`
- GBN에서 송신자는 송신한 패킷에 대한 확인 응답 없이, 최대 N개의 패킷을 전송할 수 있다.
- 이를 크기가 N인 윈도우로 표현한다. (N은 흐름제어와 혼잡제어에 의해 조정된다)
- 송신한 패킷이 올바르게 수신측에 도착하여 확인 응답을 받으면, 윈도우는 앞으로 이동하고 다음 패킷을 전송한다.
- 송신한 패킷의 순서가 올바르지 않는다면, 수신자가 마지막으로 올바르게 받은 패킷에 대한 ACK를 보낸다.  
  송신자는 이 ACK를 받고 ACK에 해당하는 다음 패킷부터 최대 N개까지 재전송해준다.

> GBN의 장단점
> - GBN은 파이프 라이닝을 가능하게 하여, 링크 이용률을 높여준다는 장점이 있다.
> - 하지만, GBN에서 패킷이 손실되면 N개 만큼의 패킷을 불필요하게 재전송 하는 단점이 있다.
> - 네트워크에 손실이 많이 발생할수록 네트워크 파이프 라인(링크)는 불필요한 재전송 패킷으로 채워진다는 단점이 있다.

`Selective Repeat`
- Selective Repeat(SR) 프로토콜은 손실 되거나 손상된 패킷에 대해서만 재전송 한다.
- GBN처럼 윈도우 크기만큼 패킷들을 전송하지 않는다. 즉, 불필요한 재전송을 하지 않는다.
- GBN 수신자는 누적확인 응답을 하지 않는다. 순서번호가 앞서는 패킷이 도착하면 그대로 수신한다.
- SR의 특징으로는 송신자의 윈도우와 수신자의 윈도우가 항상 같지 않음을 볼 수 있다.

---

### Transport Layer

애플리케이션 간의 통신 담당

목적지 애플리케이션으로 데이터 전송

안정적이고 신뢰할 수 있는 데이터 전송 보장(TCP)  
필수 기능만 제공(UDP)

---

TCP 연결은 논리적

TCP에만 연결(Connection, Session)이라는 개념이 있다.

연결은 결과적으로 순서번호로 구현된다.

연결은 상태(전이) 개념을 동반한다.

---

### TCP 연결 과정 - 3 way handshaking

<img src="../../img/network_32.png" width="500">

연결과정에서 오가는 segment는, payload가 없다.  
(IP header + TCP header)

TCP 연결 과정에서 - Sequence 번호를 교환한다. + 정책 교환(MSS)

> MSS를 교환함으로써 MTU를 설정한다.

> 실제 전선을 연결하는게 아니라, 논리적인 연결

---

### TCP 연결 종료 과정 - 4 way handshaking

<img src="../../img/network_33.png" width="500">

(연결 시작/종료 모두 클라이언트가 한다)

---

### TCP (연결) 상태 변화

<img src="../../img/network_34.png" width="500">

---

### TCP 연결이라는 착각

> 파일 다운로드 중 LAN 케이블을 분리했다가 다시 연결하면  
> TCP 연결은 어떻게 될까?
> 
> -> TCP 연결은 일정 시간동안 유지된다.

재전송 타이머의 기본 근사 값은 대략 3초이다.  
(대부분의 OS는 1초이내)

재전송 타이머 만료 이후에도 확인 응답을 받지 못한 경우 세그먼트를 재전송하고  
RTO(Retransmission Time-Out) 값은 두배 증가한다.  
(5회 재전송 모두 실패하면 전송 오류가 발생)

> TCP 연결이 사실은 Ent-Point의 주관적 착각에 불과하다

---

### 흐름 제어(Flow Control)

수신자측 버퍼에서 오버플로우가 발생하지 않도록,
송신자의 데이터 전송 속도를 제어하는 메커니즘

수신자는 ACK를 보낼 때, 수신 버퍼의 남은 사이즈를 알려준다.
송신자는 이를 보고 데이터 전송 속도를 조절한다.

---

### 혼잡 제어(Congestion Control)

네트워크 혼잡을 줄이기 위해,
송신자의 데이터 전송 속도를 제어하는 메커니즘

두가지 방식이 있다.

(Additive Increase, Multiplicative Decrease)
송신자 측 버퍼를 매 RTT마다 1 MSS 씩 늘리는데,
만약 패킷 손실이 발생하면 버퍼 사이즈를 절반으로 줄인다.

(Slow Start)
매 RTT 마다 송신자 측 버퍼를 두배씩 늘린다.
버퍼 사이즈가 임계값(OS가 설정)보다 커지면, 매 RTT 마다 버퍼를 1 MSS 씩 늘린다.
만약 패킷 손실이 발생하면, 임계값을 절반으로 줄이고 버파 사이즈를 초기화한다.