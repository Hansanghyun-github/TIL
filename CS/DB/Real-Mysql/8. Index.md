InnoDB 스토리지 엔진에서 인덱스는 더 특별한 의미가 있다.

InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키 락이 
검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있기 떄문이다.

> UPDATE나 DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 없는 인덱스가 없으면  
> 불필요하게 많은 레코드를 잠글 수도 있다.

---

## B-Tree 인덱스 사용에 영향을 미치는 요소

### 인덱스 키 값의 크기

### B-Tree 깊이

### 선택도(Cardinality)

### 읽어야 하는 레코드 건 수

---

## 인덱스 스킵 스캔

(MySQL 8.0 버전부터 도입된 최적화 기능)

인덱스 루스 스캔은 GROUP BY 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용 가능

이 방식은 WHERE 조건절의 검색을 위해 사용 가능하도록 용도가 넓어진 스캔 방식이다.

인덱스 스캡 스캔 사용 조건
1. WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
2. 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)

### 예시

`ADD INDEX ix_gender_birthdate (gender, birth_date)`  
`SELECT gender, birth_date FROM employees WHERE birth_data >= 1965-02-01`

인덱스의 컬럼이 (gender, birth_date)인데 조건절에는 birth_date만 가지고 쿼리를 보낸다면  
일반적으로 테이블 풀 스캔이 사용될 것이다.

여기서 MySQL이 gender의 값들을 모두 추출해서  
내부적으로 gender의 값들의 개수만큼 쿼리를 실행한다.

`select gender, birth_date from employees where gender='M' and birth_date >= '1965-02-01`  
`select gender, birth_date from employees where gender='F' and birth_date >= '1965-02-01`

만약 첫번째 컬럼의 카디널리티가 높다면 오히려 더 느려질 수 있다.  
(스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해지기 때문)

> 인덱스 스킵 스캔은 인덱스의 선행 칼럼의 카디널리티가 소량일 때만 적용 가능한 최적화이다.

---

## B-Tree 인덱스의 정렬 및 스캔 방향

인덱스를 생성할 때 설정한 정렬 규칙에 따라서 인덱스의 키 값은 항상 오름차순이거나 내림차순으로 정렬되어 저장된다.

> 정렬 방향만 세팅되어 있지, 오름차순을 반대로 읽으면 내림차순으로 읽을 수 있다.

---

first_name 칼럼에 대한 인덱스가 포함된 employees 테이블에 다음 쿼리를 실행한다면  
`SELECT * FROM employees ORDER BY first_name DESC LIMIT 1`  
MySQL은 이 쿼리를 실행하기 위해 인덱스를 처음부터 오름차순으로 끝까지 읽지 않고,  
내림차순으로 1개만 읽는다.

이는 MySQL 옵티마이저가 어떨 때 빠르게 읽을 수 있는지 알고 있기 때문이다.

---

### 인덱스 Forward/Backward 스캔

내부적으로 InnoDB에서 인덱스 Backward 스캔은 Forward 스캔보다 느리다.

그 이유는 다음과 같다.

`1. 페이지 잠금이 인덱스 정순 스캔에 적합한 구조`  
인덱스 스캔을 진행할 때 해당 레코드(페이지)를 잠금을 진행해야 하는데,  
이때 페이지 내의 잠금 방식이 항상 Forward라고 한다.  
이는 데드락을 방지하기 위함이라고 한다.  
이로 인해 잠금 획득으로 인한 쿼리 처리 지연이 발생한다고 한다.

`2. 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조`  
인덱스의 리프 노드(페이지)는 Double linked list 구조로 구성되어 있지만,  
페이지 내부의 레코드들은 Single linked list 구조로 구성되어 있다고 한다.  
(Forward 방향)  
따라서 Forward 스캔보다 Backward 스캔의 성능이 더 떨어진다고 한다.

> 2번보다는 1번으로 인한 처리 지연이 더 크다고 한다.

> 하지만 Forward/Backward 스캔이 성능에 영향을 미치는 건  
> 해당 쿼리가 CPU bound 일 때라고 한다.  
> 
> 만약 해당 쿼리가 디스크를 자주 방문해야 한다면,  
> Backward 스캔으로 인한 처리 지연보다  
> 디스크를 방문할 때의 지연이 더 크다고 한다.

(출처: https://tech.kakao.com/2018/06/19/mysql-ascending-index-vs-descending-index/)  


---

## B-Tree 인덱스의 가용성과 효율성

쿼리의 WHERE 조건이나 GROUP BY, ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 
어떤 방식으로 사용할 수 있는지 식별할 수 있어야 한다.

### 효율성 - 작업 범위 결정 조건 & 체크(필터링) 조건

```select * from dept_emp where dept_no = 'd002' and emp_no >= 10114```

여기서 만약 (dept_no, emp_no) 인덱스가 있다면  
dept_no, emp_no 둘다 작업 범위 결정 조건이 된다.  
(효율적으로 인덱스를 사용한 경우)

만약 (emp_no, dept_no) 인덱스가 있다면  
emp_no만 작업 범위 결정 조건이 되고,  
dept_no는 필터링 조건이 된다.  
(위보다는 비효율적인 과정)

> 필터링  
> : 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 안 맞는지 비교하면서 취사선택하는 과정

작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만,  
필터링 조건은 많다고 해서 쿼리의 성능을 높이지는 못한다.  
(오히려 느리게 만들 때도 있다)

### 가용성

인덱스가 있어도 이를 활용할 수 없다면 이는 없느니만 못하다.

(대표적으로 다중 컬럼 인덱스의 첫번째 칼럼에 대한 조건이 없을 떄)

---

## 유니크 인덱스

### 유니크 인덱스와 일반 세컨더리 인덱스 비교

`읽기 성능`  
읽기 성능 상의 차이는 미미하다.

`쓰기 성능`

유니크 인덱스는 중복된 값이 있는지 없는지 체크하는 과정이 필요하다.
그래서 유니크하지 않은 세컨터리 인덱스의 쓰기보다 느리다.

그리고 MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 
쓰기를 할 때는 쓰기 잠금을 사용하는데,
이떄 데드락이 빈번히 발생한다.

그리고 유니크 인덱스는 insert/update/delete 작업을 할 때 
반드시 중복 체크를 해야 하므로  
체인지 버퍼를 사용할 수 없다.

> 유일성이 꼭 보장돼야 하는 칼럼에 대해서만 유니크 인덱스를 생성하자  
> (필요하지 않다면 유니크하지 않은 세컨더리 인덱스도 고려해 보자)

---

## 외래키

MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있다.

외래키 관리에 중요한 두가지 특징이 있다.
1. 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 대기가 발생한다.
2. 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 대기를 발생시키지 않는다.