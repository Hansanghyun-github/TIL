SELECT 절 처리 순서

FROM 절 & JOIN 조건 - WHERE 절 - GROUP BY 절 - HAVING 절 - Window function - SELECT 절 - DISTINCT 절 - ORDER BY 절 - LIMIT/OFFSET 절

> 9장 옵티마이저를 보고 정리한 내용

### Order by

`인덱스를 이용할 때`

인덱스를 순서대로 읽어서 반환

> 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고,  
> ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.  
> 그리고 WHERE 절의 첫번째 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.
>
> B-Tree 인덱스만 가능  
> 네스티드 루프 조인에서만 가능  
> (해시 조인은 조인버퍼 사용하면서 정렬 흐트러질 수 있음)

> 인덱스를 이용해 순서대로 조회할 수 있다고 무조건 좋은 건 아님
> 인덱스 리프노드를 통해 레코드 읽어 올때마다 랜덤 I/O가 발생하기 때문에  
> 인덱스를 이용하지 않을 수 있음

`드라이빙 테이블만 정렬할 때` (Using filesort)

조인에서 첫번째로 읽히는 테이블의 칼럼만으로 정렬 가능

1. 조건 처리 & 정렬 수행(filesort)
2. 순서대로 읽으면서 조인 수행

`조인 결과를 임시 테이블로 저장 후 정렬 할 때` (Using filesort, Using temporary)

그 외 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장하고,  
그 결과를 다시 정렬하는 결과를 거친다.

> 인덱스 이용할 때만 스트리밍 방식  
> 나머진 버퍼링 방식

> 그리고 임시 파일(소트 버퍼)를 이용해서 정렬할 때도 두가지 방식이 있다.
> 
> `싱글 패스`  
> 레코드의 칼럼을 전부 소트 버퍼에 담아서 정렬 수행(쿼리 1번)
> 
> `투 패스`  
> 정렬할 칼럼, PK만 소트 버퍼에 담아서 정렬 수행(쿼리 2번)
> 
> 레코드의 크기가 크거나, BLOB/TEXT 칼럼이 있는경우 투 패스가 사용된다.

### Group by

(스트리밍 처리 불가능)

> HAVING 절은 GROUP BY 다음에 사용됨 -> 인덱스 사용 불가능

`인덱스 스캔으로 GROUP BY 처리(타이트 인덱스 스캔)`

GROUP BY 칼럼으로 이미 인덱스가 있을 때의 케이스  
(인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리)

`루스 인덱스 스캔`

(Using index for group-by)

인덱스를 이용하는데 중간중간 건너뛰면서 스캔할 때의 케이스

1. GROUP BY절에서 집계 함수가 MIN, MAX만 쓰였을 때
2. 커버링 인덱스 케이스인데 인덱스의 앞부분 컬럼만 사용됐을 때  
   (원래였으면(인덱스의 컬럼이 적었다면) 인덱스 풀 스캔일 때)

`임시 테이블을 사용하는 group by`

GROUP BY의 기준 칼럼이 인덱스를 전혀 사용하지 못할 떄 사용되는 방식

실행계획의 Extra 칼럼에 "Using temporary" 메시지가 표시된다.  
ORDER BY 절이 없다면 "Using filesort" 메시지는 표시되지 않는다.  
(정렬되지 않는다는 뜻)`

### Distinct

`SELECT DISTINCT ...`

group by와 동일하게 처리된다.

`집합 함수와 함께 사용된 DISTINCT`

집합 함수를 처리하기 위해 임시테이블이 사용된다.

### Join

`Nested-Loop Join`

조건에 부합하는 드라이빙 테이블의 레코드들을 한 건씩 읽어서,  
드리븐 테이블과 일치하는 레코드들 전부를 반환하는 방식  
(중첩 for문)  
(조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 방식)

`block nested-loop join`  
8.0.20 버전부터 비활성화됨

`Hash Join`

레코드 수가 적은 테이블을 해시 테이블(메모리)을 생성해 빠르게 조회하는 기능

총 시간은 줄어들지만, 응답 시간은 중첩조인보다 별로다.

주로 조인 칼럼에 인덱스가 없거나  
조인 대상 테이블의 레코드 건수가 매우 적은 경우 사용된다.

-> MySQL 서버의 해시 조인 최적화는 네스티드 루프 조인을 적용하기 힘든 경우를 위한 '차선책' 같은 기능

> 조인 순서를 결정하기 위해 옵티마이저는 Greedy 검색 알고리즘을 사용한다.
> 
> 시스템변수(~_depth)의 크기만큼 greedy 하게 조인 연산을 테스트해보고  
> 가장 빠른 케이스의 첫번째 테이블을 고정  
> 그리고 첫번째 테이블을 제외한 나머지 테이블로 또다시 테스트해서  
> 전부다 계산  
> (여기서 현재 조인 연산이 이전 최솟값보다 넘어서면 바로 제외(백트래킹))

### Subquery (Semi-join)

`IN-to-EXISTS 최적화`  
서브쿼리의 결과를 캐싱하고,  
외부 테이블은 캐시를 보고 데이터를 조회한다.  
서브쿼리가 외부 테이블에 dependent 하다면, (상관 서브쿼리)  
외부 값이 바뀔 때마다 캐싱해준다.

`MATERIALIZATION 최적화`  
(상관 서브쿼리 불가능)  
서브쿼리의 내용을 임시 테이블로 구체화(Meterialization)한 후,  
임시 테이블과 바깥 테이블을 조인하면서 최적화 된다.

`세미 조인 최적화`  
(NOT IN (subquery), <>(subquery) 조건절 불가능)

다른 테이블과 실제 조인을 수행하지 않고,  
단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리를 말한다.

1. Table Pull-out  
   세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에    
   쿼리를 조인 쿼리로 재작성하는 형태의 최적화  
   (서브쿼리 부분이 UNIQUE 인덱스나 PK 룩업으로 결과가 1건인 경우에만 사용 가능)
2. Duplicate Weed-out
   원본 서브쿼리를 inner join + group by로 바꿔서 실행하는 것
   (group by 나 집합 함수가 사용된 쿼리는 불가능)
3. First Match  
   서브쿼리를 조인으로 사용 & 일치하는 레코드 1건만 찾으면 바로 반환    
   (의미론적으로 EXISTS(subquery) 와 동일하게 처리 됨)
   (group by 나 집합 함수가 사용된 쿼리는 불가능)
4. Loose Scan  
   서브쿼리가 루스 인덱스 스캔을 사용할 수 있는 조건이 갖춰줘야 사용 가능  
   루스 인덱스 스캔으로 서브쿼리 읽고, 아우터 테이블을 드리븐으로 조인

