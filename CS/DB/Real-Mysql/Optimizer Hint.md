MySQL 서버로 요청된 쿼리는 결과는 동일하지만 내부적으로 그 결과를 만들어내는 방법은 매우 다양하다.
이런 다양한 방법 중에서 어떤 방법이 최적이고 최소의 비용이 소모될지 결정해야 한다.

MySQL 역시 다른 DBMS처럼, 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지
통계 정보를 참조하며, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요하다.
이를 옵티마이저가 담당한다.

> MySQL에서는 `EXPLAIN` 명령어로 쿼리의 실행 계획을 알 수 있다.
>
> 실행 계획에 표시되는 내용을 이해하려면 MySQL 서버 옵티마이저가 실행하는 최적화에 대해 어느정도 지식을 갖추고 있어야 한다.

---

# 개요

실행 계획을 살펴보기 전 먼저 알고 있어야 할 몇가지 사항들

## 쿼리 실행 절차

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번쨰 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

첫 번째 단계를 `SQL 파싱`이라 하며, 이 단계에서 문법적으로 잘못된 SQL 문장을 걸러낸다.
`SQL 파서`가 담당한다.
그리고 이때 `SQL 파스 트리`가 만들어진다.

두 번째 단계는 SQL 파스 트리를 참조하면서 다음과 같은 내용을 처리한다.

- 불필요한 조건 제거 및 복잡한 연산의 단순화
- (여러 테이블의 조인이 있는 경우) 어떤 순서로 테이블을 읽을 지 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
- 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

두 번째 단계는 `최적화 및 실행 계획 수립` 단계이다.
MySQL 서버의 `옵티마이저`에서 처리한다.
이 단계가 마무리되면 `실행 계획`이 만들어진다.

> 첫번째와 두번째 단계는 거의 MySQL 엔진에서 처리하며,
> 세 번째 단계는 MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리한다.

---

## 옵티마이저 종류

옵티마이저는 DB 서버에서 두뇌와 같은 역할을 담당한다.

옵티마이저는 비용 기반 최적화(Cost-based optimizer, CBO) 방법과
규칙 기반 최적화 방법(Rule-based optimizer, RBO)로 크게 나눌 수 있다.

`규칙 기반 최적화`
대상 테이블의 레코드 건수나 선택도(Cardinality) 등을 고려하지 않고,
옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식

`비용 기반 최적화`쿼리를 처리하기 위한 여러 가지 방법을 만들고, 각 단위 작업의 비용(부하) 정보와대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출하는 방식

> 규칙 기반 최적화는 비용 계산이 부담스러운 이유로 사용되던 방법이다.
>
> 규칙 기반 최적화는 초기 버전의 오라클 DBMS에서 사용했고,
> 비용 기반 최적화는 현재 대부분의 DBMS가 선택하고 있다고 한다.

---

# 기본 데이터 처리

MySQL 서버를 포함한 모든 DBMS는 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다.

지금부터 기본적인 가공을 위해 MySQL 서버가 어떤 알고리즘을 사용하는지 알아보겠다.

## 풀 테이블 스캔 & 풀 인덱스 스캔

(풀 인덱스 스캔은 Index.md 에서 설명했음)

풀 테이블 스캔 - 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽는 것

풀 테이블 스캔 조건

- 테이블의 레코드 건수가 매우 작을 때(인덱스를 이용하는 것보다 풀 테이블 스캔이 더 빠를 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있다 해도, 일치 레코드 건수가 너무 많은 경우
  (인덱스의 B-Tree 샘플링해서 조사한 통계 정보 기준)

대부분의 DBMS는 풀 테이블 스캔을 실행할 때
한꺼번에 여러 개의 블록/페이지를 읽어오는 기능을 내장하고 있다.

InnoDB 스토리지 엔진은특정 테이블의 연속된 데이터 페이지가 읽히면백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 시작된다.

> 리드 어헤드
> 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서
> 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것

풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는포그라운드 스레드가 페이지 읽기를 실행하지만특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다.(백그라운드 스레드는 한번에 4개/8개씩의 페이지를 읽으면 그 수를 증가시킨다)이후에 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 사용하기만 하면 되므로쿼리가 빨리 처리된다.

> `innodb_read_ahead_threshold` 시스템 변수를 이용해
> InnoDB 스토리지 엔진이 언제 리드 어헤드를 시작할지 임계값을 설정할 수 있다.

> 리드 어헤드는 풀 인덱스 스캔에서도 사용된다.

---

## 병렬 처리

MySQL 8.0 버전부터, 처음으로 쿼리의 병렬 처리가 가능해졌다.
(하나의 쿼리에 대한 병렬 처리)
(여러 개의 쿼리에 대한 병렬 처리는 이전에도 가능했음)

`innodb_parallel_read_threads` 시스템 변수로
하나의 쿼리를 최대 몇개의 스레드를 이용할지 정할 수 있다.

대신 아무런 WHERE 조건 없이 단순한 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.
`SELECT count(*) FROM Table1`

---










