## mysql 아키텍쳐

머리 역할을 담당하는 mysql 엔진과
손발을 담당하는 스토리지 엔진

> 대부분 InnoDB 스토리지 엔진 사용 함

### mysql 스레딩 구조

포그라운드 스레드
서버에 접속한 클라이언트 수만큼 존재, 요청하는 쿼리를 처리
버퍼나 캐시 사용(없으면 직접 디스크의 데이터/인덱스 읽어와서 처리)


백그라운드 스레드
인서트 버퍼 병합하는 스레드,
로그를 디스크에 기록하는 스레드 !
innodb 버퍼풀 데이터 디스크에 기록하는 스레드 !
버퍼로 읽어오는 스레드
잠금이나 데드락 모니터링하는 스레드

### mysql 메모리 구조

글로벌 메모리 영역
- 테이블 캐시
- innodb 버퍼 풀
- innodb 어댑티브 해시 인덱스
- innodb 리두 로그 버퍼

로컬 메모리 영역  
(쿼리 처리할 때 사용되는 메모리 영역)
- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

### 쿼리 실행 구조

쿼리 파서, 전처리기, 옵티마이저, 실행 엔진, 핸들러(스토리지 엔진)

### InnoDB 스토리지 엔진

레코드 기반 잠금을 제공

1. PK에 의한 클러스터링
2. 외래 키 지원
3. MVCC(하나의 레코드에 대해 여러 버전이 동시에 존재 - 언두 로그를 이용함)
4. 잠금 없는 일관된 읽기(다른 테이블에서 쓰기 잠금 걸어도 그냥 select는 바로 실행 됨)
5. InnoDB 버퍼 풀(데이터 파일, 인덱스를 메모리에 캐시해 두는 공간)
6. 언두 로그(트랜잭션 보장, 격리 수준 보장)
7. 체인지 버퍼(insert, update 시 인덱스 변경 작업 같이 해줌(버퍼링)) - 유니크 인덱스x
8. 리두 로그 및 로그 버퍼
9. 어댑티브 해시 인덱스(InnoDB에서 자동으로 생성됨, 인덱스번호&키값 으로 생성)

---

## 트랜잭션과 잠금

InnoDB만 트랜잭션 기능을 제공한다.

### 잠금

InnoDB 스토리지 엔진 내부에서 레코드 기반 잠금 제공

mysql innodb 대기 발생 시 디폴트로 사용되는 옵션?
waitting? timeout? 

### 트랜잭션 격리 수준

`READ UNCOMMITED` - 커밋되지 않아도 다른 트랜잭션에서 보여지는 레벨
`READ COMMITTED` - 커밋된 레코드만 다른 곳에서 보여지는 레벨(언두 로그 활용)
`REPEATABLE READ` - 시작 지점 이후에 항상 같은 레코드만 보여지는 레벨(언두 로그 활용)
`SERIALIZABLE` - 커밋되지 않은 쿼리는 무조건 잠금 됨(일반 select도 불가)

---

## 인덱스

InnoDB 스토리지 엔진에서
레코드 잠금이나 넥스트 키락은  
검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로  
구현 돼 있다.

### 작업 범위 결정 조건과 체크 조건

동등 비교 조건을 사용하면 작업 범위 결정 조건

범위 비교 조건을 사용하면 그 칼럼까지는 작업 범위 결정 조건
그 이후의 칼럼들은 체크 조건이 된다.

> 작업 범위 결정 조건: 인덱스가 탐색할 범위를 정하는 조건  
> 체크 조건: 결정 된 범위 내에서 조건에 해당하는 확인해주는 조건

> 다중 칼럼 인덱스에서 선행 칼럼에 대한 조건절이 없다면  
> 인덱스를 사용할 수 없다.

### 유니크 인덱스

유니크 인덱스와 일반 세컨더리 인덱스 비교

읽기 성능은 비슷하다.

쓰기 성능은 유니크 인덱스가 별로다.

> 유니크 인덱스는 insert/update 시 해당 칼럼이  
> 유니크한지 체크해야 하기 때문에 체인지 버퍼 못씀  
> 그떄 끄때 디스크 탐색해야 한다.  
> 
> 중복된 값 체크: 일기 잠금(공유 잠금)  
> 쓰기할 떄: 쓰기 잠금(배타 잠금)

결론: 유니크 인덱스는 꼭 필요할 때만 쓰자

### 외래키

외래키 제약이 설정되면  
그에 대한 인덱스가 만들어진다.

외래키를 사용함으로써 참조 무결성을  
서버자체에서 지켜주지만,  
이를 위해 동시성 처리가 떨어진다.

그리고 외래키와 관련된 칼럼의 변경은 잠금이 발생한다.

---

## 옵티마이저

옵티마이저가 select 쿼리에 대해 어떻게 최적화가 이루어지는지 

특별한 최적화에는 뭐가 있는지 살펴보겠다.

### 쿼리 실행 절차

1. sql 파싱(sql 파스 트리 생성)
2. 옵티마이저가 최적화 및 실행 계획 수립
3. 실행 계획대로 스토리지 엔진으로부터 데이터 가져옴

1,2는 MySQL 엔진가
3은 스토리지 엔진이 담당

### 풀 테이블 스캔, 인덱스 풀 스캔

풀 테이블 스캔 조건
- 레코드 건수가 매우 작을 때
- 조건에 해당하는 적절한 인덱스가 없을 때 
- 인덱스 레인지 스캔이 가능해도 조회되는 레코드 건수가 너무 많을 때

> 인덱스를 통해 조회하는 데이터는 랜덤 I/O이기 떄문에  
> 너무 많다면 이는 비효율적이다.

InnoDB 스토리지 엔진은 리드 어헤드를 지원하기 떄문에  
풀 테이블 스캔 & 인덱스 풀 스캔을 그나마 빠르게 처리할 수 있다.  
(백그라운드 스레드가 처리)

### 고급 최적화

`index_condition_pushdown`  
인덱스 칼럼엔 있지만 스캔이 안되는 조건을 체크할 수 있다.  
(와일드카드 '%'가 앞에 있을 때)

`use_index_extensions`  
설정한 인덱스 칼럼과 PK 칼럼까지 인덱스의 키로 사용됨

`index_merge`  
하나의 테이블에 대해 두개의 인덱스를 사용해 처리하는 옵션  
세부 옵션으로 3가지가 있다.
- index_merge_intersection 각각의 결과에 대해 교집합 연산 수행(AND 연산)
- index_merge_union 각각의 결과에 대해 합집합 수행(OR 연산)  
  (각 결과가 PK에 의해 정렬되었을 때 가능 - 중복 알아서 없앨 수 있음)
- index_merge_sort_union 위와 비슷, 쿼리가 PK로 정렬되어 있지 않을 때 사용

`semijoin`
서브쿼리를 최적화하는 방법
(아래 서브쿼리에서 설명)

`hash join`

> 네스티드 루프 조인 vs 해시 조인
> 첫 레코드가 반환되는 시간은 네스티드 루프조인이 빠르다.
> 하지만 전체 처리시간은 해시 조인이 빠르다.
> 
> -> 응답성-네스티드 루프 조인, 쓰루풋-해시 조인
> 
> 응답 속도를 좋게해도, order by나 group by 때문에
> 임시 테이블 사용하면 의미없다.

### 조인 최적화 알고리즘

시스템 변수에 의해 그리디 & 백트래킹 알고리즘 이용해서 조인 순서를 결정한다.

> optimizer_search_depth 만큼 모든 조인 경우의 수 탐색해서 가장 낮은 케이스의  
> 첫번쨰 테이블을 조인의 첫번째 테이블로 지정  
> 위 과정을 계속 반복  
> 
> 여기서 특정 케이스가 이전 케이스들의 최솟값보다 높아진다면 바로 다음 케이스 탐색  
> (백트래킹)

---

## 실행 계획

실행 계획의 칼럼들의 값 중 유명한 값들만 몇가지 소개하겠다.

`explain` 명령은 해당 쿼리의 실행 계획을 보여준다.  
`explain analyze` 명령은 해당 쿼리가 어떻게 실행되는 트리 형태로 자세히 보여준다.
(실제로 몇번 탐색하는지 소요되는 시간을 전부 보여준다)

### id 칼럼

select 쿼리별로 부여되는 식별자 값

같은 id를 가지고 있다면 조인되었다는 뜻

그리고 같은 id를 가지고 있는 테이블 중에서  
위에 있는 테이블이 드라이빙 테이블,  
아래에 있는 테이블이 드리븐 테이블

### type 칼럼

각 테이블의 레코드를 어떻게 읽었는지 나타낸다.

ref - 인덱스 레인지 스캔(동등 비교 조건)  
range - 인덱스 레인지 스캔(범위 비교 조건)  
index - 인덱스 풀 스캔  
ALL - 풀 테이블 스캔

### key 칼럼

최종 실행 계획에서 사용되는 인덱스의 이름을 표시

(PK는 PRIMARY)

### rows 칼럼

예측했던 레코드 건수를 보여준다.  
(실행 계획의 효율성 판단을 위한 칼럼)

### filtered 칼럼

필터링되고 남은 레코드의 비율을 의미한다.  
(실제 비율)

### Extra 칼럼

쿼리의 실행 계획과 관련된 중요한 내용이 표시되는 칼럼

---

