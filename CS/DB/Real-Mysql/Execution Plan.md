살펴볼 것
1. MySQL 서버의 실행 계획에 가장 큰 영향을 미치는 통계 정보
2. 실행 계획을 읽는 순서 
3. 실행 계획에 출력되는 키워드, 알고리즘에

# 통계 정보

테이블 및 인덱스에 대한 통계 정보와 히스토그램을 살펴본다.

> MySQL 8.0 버전부터 인덱스되지 않은 칼럼들에 대해서도  
> 데이터 분포도를 수집해서 저장하는 히스토그램이 도입됐다.

## 테이블 및 인덱스 통계 정보

비용 기반 최적화에서 제일 중요한 것은 통계 정보다.

### MySQL 서버의 통계 정보

> 5.6 버전부터 각 테이블의 통계 정보를 mysql 데이터베이스의  
> innodb_index_stats 테이블과 innodb_table_stats 테이블로 관리할 수 있게 됐다.  
> (이전까지는 그냥 메모리에 저장 -> 휘발됨)

통계 정보의 각 칼럼이 의미하는 것
- innodb_index_stats.stat_name='n_diff_pfx%': 인덱스가 가진 유니크한 값의 개수
- innodb_index_stats.stat_name='n_leaf_pages': 인덱스가 가진 리프 노드 페이지의 개수
- innodb_index_stats.stat_name='size': 인덱스 트리의 전체 페이지 개수
- innodb_table_stats.n_rows: 테이블의 전체 레코드 건수
- innodb_table_stats.clustered_index_size: PK 크기(InnoDB 페이지 개수)
- innodb_table_stats.sum_of_other_index_sizes: PK를 제외한 인덱스의 크기(InnoDB 페이지 개수)

## 히스토그램

### 히스토그램 정보 수집 및 삭제

히스토그램은 칼럼 단위로 관리되는데,  
이는 ```ANALYZE TABLE ... UPDATE HISTOGRAM``` 명령을 실행해  
수동으로 수집 및 관리된다.

수집된 정보는 시스템 딕셔너리에 함께 저장되고,  
서버를 시작할 때 information_schema 데이터베이스의  
column_statistics 테이블로 로드한다.

히스토그램의 타입은 2 종류가 있다.
1. Singleton(싱글톤 히스토그램): 칼럼 값 개별로 레코드 건수를 관리하는 히스토그램, 도수 분호 히스토그램이라고 함
2. Equi-Height(높이 균형 히스토그램): 칼럼 값의 범위를 균등한 개수로 나눠서 관리하는 히스토그램, Height-Balanced 히스토그램이라고 함

히스토그램은 버킷(Bucket) 단위로 구분되어  
레코드 건수나 칼럼값의 범위가 관리된다.

싱글톤 히스토그램은 각 버킷이 칼럼과 발생 빈도율 2개 값을 가진다.  
높이 균형 히스토그램은 각 버킷이 범위 시작 값과 마지막 값, 발생 빈도율과 각 버킷에 포함된 유니크한 값의 개수 4개의 값을 가진다.

히스토그램의 모든 레코드 건수 비율은 누적으로 표시된다.
(그래서 항상 마지막 버킷의 빈도율은 1이 된다)

> 여기서 기울기가 일정하다면 각 범위가 비슷한 레코드 건수를 가진다고 할 수 있다.

information_schema.column_statistics 테이블의 HISTOGRAM 칼럼이 가진 필드들의 의미
- sampling-rate: 스캔한 페이지의 비율(1이라면 전체를 스캔한 것이다, but 테이블 전체를 스캔하는 것은 부하가 높다)
- histogram-type: 히스토그램의 종류
- number-of-buckets-specified: 히스토그램을 생성할 때 설정한 버킷의 개수(현재 개수가 아닌 설정된 개수, default 100)

### 히스토그램의 용도

> 히스토그램이 도입되기 전에,  
> MySQL 서버는 해당 테이블의 전체 레코드 건수와  
> 인덱스된 칼럼이 가지는 유니크한 값의 개수만 가지고 예측을 했다.
> (하지만 데이터는 균등한 분포도를 가지지 않기 때문에 문제가 되었다)

히스토그램이 없다면 옵티마이저는 조인 순서를 결정할 때  
테이블의 전체 레코드 건 수나 크기등 단순한 정보만으로  
조인의 드라이빙 테이블을 결정한다.

각 칼럼에 대해 히스토그램 정보가 있다면  
어느 테이블을 먼저 읽어야 조인의 횟수를 줄일 수 있을지  
정확히 판단할 수 있다.

### 히스토그램과 인덱스

MySQL 서버에서는 쿼리의 실행 계획을 수립할 때  
사용가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고  
최종적으로 가장 나은 실행 계획을 선택한다.

이때 조건절에 일치하는 레코드 건수를 예측하기 위해  
실제 인덱스의 B-Tree를 샘플링해서 살펴본다.  
이 작업을 `인덱스 다이브(Index Dive)`라고 표현한다.

그런데 인덱스된 칼럼에 대해 히스토그램을 생성하는게 과연 좋을까?

MySQL 8.0 서버에서는 인덱스된 칼럼을 검색 조건으로 사용하는 경우  
그 칼럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다.  
(이는 실제 검색 조건 대상 값에 대한 샘플링을 실행하는 것이므로 항상 히스토그램보다 정확한 결과를 기대할 수 있다)

하지만 인덱스 다이브 작업은 어느 정도의 비용이 필요하다.

## 코스트 모델(Cost Model)

MySQL 서버가 쿼리를 처리하기 위한 작업들
- 디스크로부터 페이지 읽기
- 메모리(InnoDB 버퍼 풀)로부터 페이지 읽기
- 인덱스 키 비교
- 레코드 평가
- 메모리 임시 테이블 작업
- 디스크 임시 테이블 작업

MySQL 서버는 사용자의 쿼리에 대해  
다양한 작업이 얼마나 필요한지 예측하고  
전체 작업 비용을 계산한 결과를 바탕으로 최적의 실행 계획을 찾는다.

이렇게 전체 쿼리의 비용을 계산하는데 필요한 작업 단위들의 비용을  
`코스트 모델(Cost Model)`이라고 한다.

MySQL 5.7 이전 버전까지는  
이런 작업들의 비용을 서버 소스 코드에 상수화 했다.

> 그 이후 버전부터 각 작업 단위의 비용을 관리자가 조정할 수 있게 됐지만,  
> 꼭 바꿔서 사용해야 하는 것은 아니다.  
>
> 코스트 모델은 MySQL 서버가 사용하는 하드웨어와  
> 서버 내부 처리 방식에 대한 깊이 있는 지식을 필요로 한다.
> 
> 그리고 기본값으로도 MySQL 서버는 20년동안 잘 사용됐기 때문에  
> 함부로 변경하지 않는게 좋을 것 같다.

---

















