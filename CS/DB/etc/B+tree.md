### B tree 용어

각 노드의 최대 자녀 노드 수: M
각 노드의 최대 key 수: M-1
각 노드의 최소 자녀 노드 수: ceil(M/2)
각 노드의 최소 key 수: ceil(M/2)-1

이 B tree는 M차 B tree 이다.

> ceil(x) x를 올림 처리

B tree의 규칙  
inner 노드의 key 수가 x개라면 자녀 노드의 수는 언제나 x+1 개다.

-> 노드가 최소 하나의 key는 가지기 때문에
inner 노드는 최소 두 개의 자녀는 가진다.

> B-Tree vs B+Tree
>
> B-Tree는 모든 노드에 데이터가 있다.
>
> B+Tree는 leaf node에만 데이터가 있다.  
> -> inner node에 데이터를 넣지 않기 때문에, key를 더 많이 넣을 수 있다.  
> -> 트리의 높이가 더 낮아진다.  
> & 순차 탐색이 빨라진다.  
> (B-Tree는 순차 탐색을 위해 모든 노드를 탐색해야 한다)
>
> 대신 B+Tree는 key의 중복이 생길 수 있다.
> 
> 그리고 B+tree의 리프노드들은 연결리스트 형태를 띄고 있다.  
> -> 순차 검색 성능 향상

대부분의 인덱스는 B+tree를 사용하기 때문에,  
삽입/삭제 과정은 B+tree를 기준으로 설명하겠다.

> 차수 M이 홀수일 때를 기준으로 설명하겠다.

---

## B+tree 데이터 삽입

1. 추가는 항상 leaf 노드에 한다.
2. 노드가 넘치면 가운데 key를 기준으로  
   왼쪽 key들, 가운데 key + 오른쪽 key로 분할하고, 가운데 key를 복사해서 부모노드에 추가한다.

> 노드가 넘친다.
> (M차 B tree에서) 자녀 노드의 수가 M개 이상일 때

핵심: B+tree의 모든 leaf 노드들은 같은 레벨을 가진다.

---

### B+tree 삽입 예시

(3차 B+tree 기준 -> 자식노드의 최대 개수는 2개)

```
    2
  /   | 
1    2|5  
```

위 상태에서 7을 추가한다면,

```
    2
  /   | 
1    2|5|7 <- 넘쳤다
```

2와 5|7로 분할한 다음, 가운데 key인 5를 복사해서 부모노드에 추가한다.

```
    2 | 5
  /   |   \ 
1     2   5|7
```

> 만약 복사한 key를 부모노드에 추가한 뒤에 부모노드도 넘쳤다면,  
> 똑같이 재조정 해준다.

---

