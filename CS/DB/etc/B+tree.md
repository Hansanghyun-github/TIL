### B tree 용어

각 노드의 최대 자녀 노드 수: M
각 노드의 최대 key 수: M-1
각 노드의 최소 자녀 노드 수: ceil(M/2)
각 노드의 최소 key 수: ceil(M/2)-1

이 B tree는 M차 B tree 이다.

> ceil(x) x를 올림 처리

B tree의 규칙  
inner 노드의 key 수가 x개라면 자녀 노드의 수는 언제나 x+1 개다.

-> 노드가 최소 하나의 key는 가지기 때문에
inner 노드는 최소 두 개의 자녀는 가진다.

> B-Tree vs B+Tree
>
> B-Tree는 모든 노드에 데이터가 있다.
>
> B+Tree는 leaf node에만 데이터가 있다.  
> -> inner node에 데이터를 넣지 않기 때문에, key를 더 많이 넣을 수 있다.  
> -> 트리의 높이가 더 낮아진다.  
> & 순차 탐색이 빨라진다.  
> (B-Tree는 순차 탐색을 위해 모든 노드를 탐색해야 한다)
>
> 대신 B+Tree는 key의 중복이 생길 수 있다.
> 
> 그리고 B+tree의 리프노드들은 연결리스트 형태를 띄고 있다.  
> -> 순차 검색 성능 향상

대부분의 인덱스는 B+tree를 사용하기 때문에,  
삽입/삭제 과정은 B+tree를 기준으로 설명하겠다.

> 차수 M이 홀수일 때를 기준으로 설명하겠다.

---

## B+tree 데이터 삽입

1. 추가는 항상 leaf 노드에 한다.
2. 노드가 넘치면 가운데 key를 기준으로  
   왼쪽 key들, 가운데 key + 오른쪽 key로 분할하고, 가운데 key를 복사해서 부모노드에 추가한다.

> 노드가 넘친다.
> (M차 B tree에서) 자녀 노드의 수가 M개 이상일 때

핵심: B+tree의 모든 leaf 노드들은 같은 레벨을 가진다.

---

### B+tree 삽입 예시

(3차 B+tree 기준 -> 자식노드의 최대 개수는 2개)

```
    2
  /   | 
1    2|5  
```

위 상태에서 7을 추가한다면,

```
    2
  /   | 
1    2|5|7 <- 넘쳤다
```

2와 5|7로 분할한 다음, 가운데 key인 5를 복사해서 부모노드에 추가한다.

```
    2 | 5
  /   |   \ 
1     2   5|7
```

> 만약 복사한 key를 부모노드에 추가한 뒤에 부모노드도 넘쳤다면,  
> 똑같이 재조정 해준다.

---

## B+tree 데이터 삭제

1. 삭제도 항상 leaf 노드에서 발생한다.
2. 삭제할 key가 leaf 노드에서 가장 처음에 있는 key라면 추가 작업을 해준다.

재조정 방법은 2가지가 있다.
1. key 수가 여유있는 형제의 지원을 받는다.
2. 1번이 불가능하면 형제와 merge

만약 지우려는 key가 root 노드나 inner 노드에 있다면,  
1,2번 과정 후, 해당 key를 inorder successor의 key로 변경해준다.

### B+tree 데이터 삭제 1번 케이스(추가작업x)

왼쪽이나 오른쪽 형제 노드 중에, key 수가 여유있는 형제의 지원을 받는다.

(1) 왼쪽에 여유가 있다.
왼쪽 노드를 분할 & 
분할 된 노드들 중, 오른쪽 노드의 첫번째 key 값을 부모노드의 key값으로 변경

(2) 오른쪽에 여유가 있다.
오른쪽 노드를 분할 & 
분할 된 노드들 중, 오른쪽 노드의 첫번째 key 값을 부모노드의 key값으로 변경

### 1번 케이스 예시

```
    3 | 7
  /   |   \
1     3   7|8
```

위 상태에서 3을 삭제하면,

```
    3 | 7
  /       \
1         7|8
```

가운데 노드의 key 수가 최소 key 수(1)보다 작다.

오른쪽 형제 노드가 여유가 있기 때문에,  
오른쪽 노드를 분할한다.
& 부모노드의 key 값을 업데이트 해준다.

결과

```
    7 | 8
  /   |   \
1     7    8
```

### 재조정 2번 케이스

1번이 불가능하면 왼쪽 or 오른쪽 노드의 합친다.

### 2번 케이스 예시

```
    7 | 8
  /   |   \
1     7    8
```

위 예시에서 7을 삭제하면,

```
    7 | 8
  /       \
1          8
```

왼쪽이나 오른쪽 형제 노드 모두, 지원이 불가능하기 때문에
부모의 key인 7을 삭제하면 된다.

결과

```
    8
  /   \
1      8
```

---

> b-tree의 삽입/삭제 과정을 다루는 사이트는 많았지만,  
> b+tree의 삽입/삭제 과정을 다루는 페이지는 상대적으로 적었다.
> 
> 결국 핵심은 최대한 노드(페이지)를 적게 방문하는 것이 b+tree의 핵심인 것 같다.

