## DB 세션(session)

클라이언트와 DB가 연결되어 있는 상태

> 세션 vs 커넥션
> 
> 커넥션(connection)  
> DB에 대한 물리적인 경로, 클라와 DB 서버 간의 네트워크 연결이 이루어질 때, 이를 커넥션이라 한다.  
> (사용자가 DB에 접속하려면 먼저 커넥션을 만들어야 한다, 일반적으로 TCP/IP를 통해 생성)
> 
> 세션  
> DB에 대한 논리적인 경로  
> 커넥션이 만들어진 이후의 상호작용  
> 사용자가 DB에 로그인하여 연결을 생성하면, 그 연결에 대한 세션도 생성됨  
> 세션은 사용자의 DB 작업이 이루어지는 동안 유지됨  
> 로그아웃하면 세션도 종료  
> 세션 내에서 사용자의 모든 트랜잭션, 쿼리 등의 작업이 이루어짐
> 
> 커넥션 안에서, 여러 개의 세션이 존재 가능하다.

---

## 트랜잭션

DB에서 수행되는 논리적인 작업 단위

목적:  
여러 단계로 이루어진 작업들을 하나의 논리적인 단위로 묶어, 데이터베이스의 상태를 일관성 있게 변화시키는 것

---

### 트랜잭션 실행 과정

시작 - 수행 - 커밋/롤백

커밋: 트랜잭션의 성공적인 완료, 커밋을 통해 트랜잭션의 결과가 DB에 영구적으로 반영

롤백: 트랜잭션의 실패 or 중단, 롤백을 통해 트랜잭션이 시작되기 전 상태로 되돌려진다.  
(트랜잭션의 변경 사항을 반영하지 않음)

> 오토커밋 - 트랜잭션의 자동 완료를 의미  
> 오토 커밋이 활성화되면, 각 SQL 문장이 별도의 트랜잭션으로 간주되어 자동으로 커밋이 수행된다.
> 
> start transaction 명령을 주면, 오토커밋은 off된다.  
> 커밋/롤백과 함께 해당 트랜잭션이 종료되면, 다시 오토커밋이 on된다.

---

## 트랜잭션의 속성(ACID)

원자성 (Atomicity), 일관성 (Consistency), 고립성 (Isolation), 지속성 (Durability)

> ACID 속성은 데이터베이스 시스템이 안정성과 신뢰성을 유지하며 데이터의 무결성을 보장하는 데 중요한 역할을 한다.  
> 이러한 속성은 트랜잭션 처리 과정에서 데이터베이스의 일관성과 신뢰성을 확보하며, 데이터 손실을 방지한다.

---

### 원자성 (Atomicity)

트랜잭션은 원자적이어야 한다.  
즉, 트랜잭션 내의 모든 작업은 전체가 성공하거나 실패해야 한다  
(하나의 작업이라도 실패하면 트랜잭션 전체가 실패하고, 모든 작업이 성공했을 때만 트랜잭션이 성공적으로 완료된다)

---

### 일관성 (Consistency)

트랜잭션이 완료된 후에도 데이터베이스는 일관된 상태를 유지해야 한다.

---  

### 고립성 (Isolation)

동시에 여러 트랜잭션이 실행될 때 발생할 수 있는 간섭이나 충돌을 방지하기 위한 속성  
(여러 트랜잭션이 동시에 실행되더라도, 각각의 트랜잭션은 다른 트랜잭션에 영향을 받지 않고 독립적으로 수행되는 것처럼 보여야 한다)

---

### 지속성 (Durability)

트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 저장되어야 한다.  
시스템 장애 또는 다시 시작되더라도 트랜잭션의 결과는 손실되지 않아야 한다.

---

## 트랜잭션의 격리 수준

하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을  
어떻게 공유하고 차단할 것인지를 결정하는 레벨

4가지가 있다.  
(READ UNCOMMITED, READ COMMITED, Repeatable Read, Serializable)

---

### READ UNCOMMITED

트랜잭션의 변경 내용이 커밋이나 롤백 여부애 상관없이 다른 트랜잭션에서 보여지는 격리 수준

Dirty Read 문제가 있다.

> Dirty Read  
> 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도,  
> 다른 트랜잭션에서 해당 (미완성) 데이터를 볼 수 있게 되는 현상
> 
> 이 현상은 데이터가 나타났다가 사라졌다 하는 현상을 초래하므로,  
> 개발자와 사용자를 상당히 혼란스럽게 만든다.

> 데이터 정합성에 문제가 많은 격리 수준

---

### READ COMMITED

어떤 트랜잭션에서 데이터를 변경했더라도 커밋이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있는 격리 수준

데이터를 조회할 때, 다른 트랜잭션에서 해당 데이터를 수정했을 경우(커밋은 아직 안함)  
수정되기 전의 데이터가 조회된다.

> (커밋은 하지 않았지만) 트랜잭션을 통해 데이터를 변경하면, 이전 데이터를 Undo 영역에 저장된다. (백업)  
> 다른 트랜잭션에서 해당 데이터를 조회하면, Undo 영역의 데이터가 조회된다.  
> 
> 처음 트랜잭션이 변경된 내용을 커밋하면,  
> 그때부터는 다른 트랜잭션에서도 백업된 데이터가 아니라 새롭게 변경된 데이터가 조회된다.
> 
> Undo 영역의 데이터(Undo 레코드)는  
> 트랜잭션의 격리 수준을 보장하기 위한 용도뿐 아니라  
> 트랜잭션의 롤백에 대한 복구에도 사용된다.

이 레벨부터는 Dirty Read가 발생하지 않는다.  
하지만 Non-Repeatable Read 문제가 있다.

> Non-Repeatable Read  
> 한 트랜잭션 내에서 같은 튜플을 조회했을 때, 동일함을 보장할 수 없다는 문제
> (트랜잭션 내에서 같은 튜플을 한번 더 조회하기 전에, 다른 트랜잭션에의 커밋을 통해 해당 데이터가 변경될 수 있다)
> 
> 일반적인 웹 프로그램에서는 크게 문제가 되지는 않지만,  
> 은행의 입출금과 같이 데이터 정합성이 중요한 서비스에서 치명적인 문제가 될 수 있다.

---

### REPEATABLE READ

동일 트랜잭션 내에서는 동일한 결과를 보여주는 격리 수준

이 격리 수준부터는 Non-Repeatable Read 문제가 발생하지 않는다.
하지만 Phantom Read 문제가 있다.  
(InnoDB는 발생하지 않음)

> Phantom Read  
> 다른 트랜잭션에서 수행한 변경 작업에 의해, 같은 쿼리에 대한 결과에 새 행이 삽입되거나 제거될 때 발생하는 문제
> 
> 일반 select 쿼리는 문제가 없지만,  
> select ... for update에서 문제가 발생한다.  
> 
> select ... for update 쿼리는 select하는 레코드에 쓰기 잠금을 걸어야 하는데,  
> 언두 레코드에는 잠금을 걸 수 없다.  
> -> 이 쿼리로 조회되는 레코드는 언두 영역의 변경 데이터x, 현재 레코드의 값을 가져오게 된다.  
> (현재 레코드의 값은 다른 트랜잭션의 커밋으로 인해 변경될 수 있음)

> MySQL InnoDB의 기본 트랜잭션 격리 수준이  
> Repeatable Read이다.

---

### SERIALIZABLE

가장 단순한 격리 수준이지만, 가장 엄격한 격리 수준  
(동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다)

한 트랜잭션에서 `읽고` 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 격리 수준

Phantom Read 문제가 발생하지 않는다.

> 하지만 InnoDB 스토리지 엔진에서는 REPEATABLE READ 격리 수준에서도  
> 이 문제가 발생하지 않기 때문에, 굳이 SERIALIZABLE 격리 수준을 사용할 필요가 없다.

---

### Non-Repeatable Read vs Phantom Read

Non-Repeatable Read는 트랜잭션이 다른 트랜잭션에서 커밋된 업데이트를 읽는 경우  
이제 동일한 행은 거래가 시작되었을 때와 다른 값을 갖는다.

Phantom Read는 유사하지만 다른 트랜잭션에서 커밋된 INSERT 또는 DELETE 된 테이블을 읽을 때 발생한다.  
거래를 시작한 이후 새로운 행이나 사라진 행이 있다.

---

### InnoDB에서 REPEATABLE READ 격리 수준에서도 Phantom Read가 발생하지 않는 이유

// TODO

InnoDB는 트랜잭션이 롤백될 가능성에 대비해 변경되기 전 레코드를 Undo 공간에 백업해두고 실제 레코드 값을 변경한다.  

`MVCC(Multi Version Concurrency Control)`  
하나의 레코드에 대해 다양한 버전을 가지고 있다.  
(필요에 따라 어느 버전의 데이터가 보여지는지는 여러 가지 상황(격리 수준)에 따라 다르다)

InnoDB는 언두 영역에 백업된 이전 데이터를 이용해 REPEATABLE READ 격리 수준을 보장한다.



---

> 남은 키워드  
> DB 동시성 제어, 갱신 손실 문제, DB 락, DB 데드락, DB 회복, REDO/UNDO, 체크포인트 회복 기법
> 
> 락과 격리 수준(트랜잭션)의 차이점  
> 정합성 VS 무결성