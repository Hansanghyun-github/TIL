# VARCHAR & TEXT

RDBMS에서 문자열을 저장할 때 사용하는 대표적인 타입이 VARCHAR이다.  
그리고 크기가 매우 큰 문자열을 저장할 때는 TEXT 타입을 쓴다.  
이 장에서는 각각의 타입들이 DB(MySQL 기준)에서 어떻게 저장 & 사용되는지 제대로 살펴본다.

---

## VARCHAR

VARCHAR type은 가변 길이의 문자열을 저장할 때 사용되는 type이다.

VARCHAR type 컬럼이 정의할 수 있는 길이의 범위는 1 ~ 65535(byte) 이다.  
(최대 지정 길이 = 16383 (문자 1개당 4바이트))

> 다른 컬럼이 추가된다면 기존 VARCHAR type 컬럼의 길이는 작아질 수 밖에 없다.
>
> 레코드의 최대 바이트 = 65535 byte  
> (이걸 넘어가면 에러 남)

=> 하나의 VARCHAR 컬럼이 너무 큰 길이를 사용하면, 다른 컬럼들이 사용할 수 있는 최대 공간의 크기가 영향을 받게 된다.

=> MySQL에서는 레코드 사이즈 한계 때문에, VARCHAR 타입의 최대 저장 길이 설정시에 공간을 아껴서 설정해야 한다.

---

## TEXT

TEXT 타입을 사용하면 길이 제한 문제가 없어진다.  
(VARCHAR 타입의 길이 설정에 대한 제약뿐만 아니라 저장하는 값의 길이 제한도 훨씬 크고 유연하게 테이블을 만들 수 있다)

---

> 그러면 VARCHAR 타입보다 TEXT 타입을 쓰는 것이 무조건 좋지 않을까?

## VARCHAR vs TEXT

### 1. 저장되는 위치

(RDBMS에서 TEXT/BLOB와 같은 대용량 데이터를 저장하는 컬럼 타입을 LOB(Large Object) 타입이라고 한다)

일반적으로 MySQL에서 레코드의 컬럼 데이터를 B-Tree(Clustering Index)에 저장한다. - 이를 Inline 저장이라고 함  
하지만 용량이 큰 LOB 데이터는 B-Tree 외부의 Off-Page에 저장한다.

MySQL은 LOB 타입의 컬럼을 항상 Off-Page로 저장하지는 않고,  
길이가 길어서 저장 공간이 많이 필요한 경우에만 Off-Page로 저장한다.

> (innodb_default_row_format=DYNAMIC 설정 기준)  
> 8100바이트의 문자열을 저장할 때는 Inline으로 저장하지만,  
> 이를 넘어가는 문자열을 저장할 때는 Off-Page로 저장한다.
>
> 이는 VARCHAR와 TEXT 타입 모두 해당된다.

### 2. 인덱싱

일반적으로 TEXT 타입의 컬럼 데이터는 인덱스를 생성할 수 없다는 이야기를 하는 사람도 많지만,  
사실 둘다 최대 크기 제한만 충족시켜 주면 인덱스를 생성할 수 있다.

> 인덱스는 3072 바이트 이하일때만 생성 가능하다.
>
> VARCHAR와 TEXT 이를 넘어가면 인덱스를 생성하지 못한다.  
> (여기서 컬럼 값의 길이를 지정하면 인덱스를 생성할 수 있다)

---

위 두가지의 비교를 보면 VARCHAR와 TEXT 타입 컬럼의 경계가 모호해진 것 같다.  
그럼 어떤 경우에 VARCHAR 타입을 쓰고, TEXT 타입을 써야 할까?

---

### 3. VARCHAR와 TEXT의 메모리 활용

(MySQL 엔진과 InnoDB 스토리지 엔진은 uchar* records[2] 메모리 포인터를 이용해서 레코드 데이터를 주고 받는다)

records[2] 메모리 객체는 실제 레코드의 크기에 관계없이 최대 크기로 메모리를 할당해둔다.

VARCHAR 타입은 최대 크기가 설정되기 때문에 메모리 공간을 records[2] 버퍼에 미리 할당받아둘 수 있지만,  
TEXT/BLOB 같은 LOB 컬럼 데이터의 경우 실제 최대 크기만큼 메모리를 할당해 두면 메모리 낭비가 너무 심해지는 문제가 있다.

=> 따라서 records[2] 포인터가 가리키는 메모리 공간은 VARCHAR 컬럼은 포함하지만, `TEXT 컬럼을 위한 공간은 포함하지 않는다.`

그리고 records[2] 메모리 버퍼는 처음 한번 할당되면 많은 커넥션들에 의해서 재사용되 수 있도록 설계되어 있다.

=> LOB 컬럼을 위한 메모리 공간은 records[2]에 미리 할당되어 있지 않기 때문에 `매번 레코드를 읽고 쓸 때마다 필요한 만큼 메모리가 할당되어야 한다.`

> 여기서 주의해야 할점은, VARCHAR 타입에 저장된 값의 길이가 길어서 Off-Page로 저장된 경우, MySQL은 records[2] 버퍼를 사용하지 못하고 새롭게 메모리 공간을 할당해서 사용해야 한다.  
> 
> => VARCHAR 타입에 매우 큰 값이 빈번하게 저장되는 경우 주의가 필요하다.

---

## 정리 (MySQL 기준)

|특징|VARCHAR|TEXT|
|--|--|--|
|저장되는 방식|선언한 길이만큼 레코드의 크기에 영향을 준다|레코드의 크기에 영향을 주지 않는다|
|저장되는 위치|길지 않다 - Inline 저장, 길다 - Off-Page 저장|VARCHAR과 같다|
|인덱싱|일정 길이 넘지 않으면 인덱스 생성 가능, 길이 넘으면 불가능|VARCHAR과 같다|
|메모리 활용|길지 않다면 데이터를 버퍼에 미리 할당, 길면(Off-Page에 저장됨) 버퍼에 할당 못함|버퍼에 할당 못함|

|컬럼 타입 선정 규칙|VARCHAR|TEXT|
|--|--|--|
|최대 길이가 ?|크지 않은 경우|길이가 큰 경우|
|테이블 데이터를 읽을 때 ?|해당 컬럼이 필요한 경우|자주 필요하지 않은 경우|


> DBMS 서버의 메모리가 충분한 경우 (긴 문자열이어도) VARCHAR 좋다. (그냥 긴 문자열 그대로 버퍼에 할당해도 괜찮으니까)

---

### Reference

https://medium.com/daangn/varchar-vs-text-230a718a22a1

---

### 여기서 궁금한 키워드

버퍼에 할당한다는 개념이 잘 이해가 안된다.

VARCHAR은 왜 문자 1개당 4바이트? (c에서 char은 1바이트인데, 한글도 2바이트인데)

Off-Page vs Inline 저장?

B-Tree 인덱스 vs 전문 검색 인덱스?

