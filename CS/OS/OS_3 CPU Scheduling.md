# CPU 스케쥴링

## CPU bound vs I/O bound

프로그램이 수행되는 과정은 CPU 작업(CPU burst)과 I/O 작업(I/O burst)의 반복으로 구성된다.

> CPU burst: 프로그램이 CPU를 가지고 명령을 수행하는 단계  
> I/O burst: I/O 요청이 발생해 커널에 의해 입출력 작업을 하는 단계

### CPU bound process

I/O 작업보다 CPU 작업이 많은 프로세스  
프로세스 수행의 상당 시간을 I/O 작업 없이 CPU 작업에 소모하는 계산 위주의 프로그램이 해당된다

### I/O bound process

CPU 작업보다 I/O 작업이 많은 프로세스  
주로 사용자와 인터랙션을 계속 주고받으며 프로그램을 수행시키는 대화형 프로그램이 해당된다.

> 시분할 시스템에서는 이와 같이 CPU 버스트가 균일하지 않은 다양한 프로그램들이 공존하므로 효율적인 CPU 스케줄링 기법이 반드시 필요하다.
> CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당해줘서 응답시간을 높이고 I/O 장치의 효율성을 높일 수 있다.

---

### CPU Scheduler vs dispatcher

CPU Scheduler : (스케쥴링 알고리즘에 따라) CPU에서 실행될 프로세스를 선택하는 역할  
dispatcher: 선택된 프로세스에게 CPU를 할당하는 역할

> 디스패처는 현재 수행 중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장하고  
> 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정을 수행한다.  
> 디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 디스패치 지연시간이라고 한다.  
> 디스패치 지연시간의 대부분은 문맥교환 오버헤드에 해당한다.

> dispatch  
> Ready 상태인 프로세스들 중에, 하나를 골라 Running 상태로 변환시키는 작업

---

CPU 스케쥴러 방식에는 비선점형(non-preemtive) 방식과 선점형(preemtive) 방식이 있다.

### 비선점형(nonpreemptive) 방식

CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는 방법

### 선점형(preemptive) 방식

프로세스가 CPU에서 실행 중이더라도 강제로 CPU를 빼앗을 수 있는 스케줄링 방법

---

## 스케쥴링 알고리즘의 성능 평가

스케줄링 기법의 성능을 평가하기 위해 여러 지표들이 사용된다.

시스템 관점의 지표 - CPU 이용률, 처리량
사용자 관점의 지표 - 소요시간, 대기시간, 응답시간

### CPU 이용률(CPU utilization)
전체 시간 중에서 CPU가 일을 한 시간의 비율

### 처리량(throughput)
시간담 완료한 프로세스의 수

### 소요시간(turnaround time)
프로세스가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다쓰고 CPU 버스트가 끝날 때까지 걸린 시간  
즉, ready 큐에서 기다린 시간과 실제로 CPU를 사용한 시간의 합을 뜻한다.

### 대기시간(waiting time)
CPU 버스트 기간 중 프로세스가 ready 큐에서 CPU를 얻기 위해 기다린 시간의 합을 뜻한다.  
시분할 시스템에서는 한 번의 CPU 버스트 중에도 reay큐에서 기다린 시간이 여러번 발생할 수 있다.

### 응답시간(response time)
프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간을 뜻한다.

---

## 스케쥴링 알고리즘

### 1. FCFS(First Come First Served)

프로세스가 준비 큐에 도착한 시간 순서대로 실행하는 방식

### 2. SJF(Shortest Job First)

프로세스의 다음 CPU burst가 가장 짧은 프로세스부터 실행하는 방식

> 비선점형 방식

### 3. SRTF(Shortest Remainning Time First)

남은 CPU burst가 가장 짧은 프로세스부터 실행하는 방식

> 선점형 방식  
> (SJF의 선점형 버전)

> 프로세스의 CPU burst 시간은 알 수 없다.  
> -> 예측을 한다(과거의 CPU burst 시간을 이용)

> CPU 버스트가 짧은 프로세스가 계속 도착할 경우?  
> CPU 버스트가 짧은 프로세스가 계속 도착한다면  
> CPU 버스트가 긴 프로세스는 영원히 CPU를 할당받지 못할 수 있다.
> 이러한 현상을 `기아 현상(starvation)`이라고 한다.
> 
> 기아 현상(starvation)  
> 우선 순위가 낮은 프로세스가 계속해서 CPU를 할당받지 못하는 현상  
> 이를 해결하기 위해 오래 기다린 프로세스의 우선순위를 높이거나(Aging) Round-Robin을 적용해볼 수 있다.

### Round-Robin

라운드 로빈 스케줄링에서는 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 특정 시간(time quantum)으로 제한된다.  
이 시간이 경과하면 해당 프로세스로부터 CPU를 회수해 준비 큐에 줄 서 있는 다른 프로세스에게 CPU를 할당한다.

> time quantum이 너무 길면 response time이 안좋을 수 있고,  
> 너무 짧으면 문맥교환의 오버헤드가 커지는 단점이 있다.

### MLQ(Multi-Level Queue)

ready 큐를 여러 개로 분할해 관리하는 스케줄링 기법

각각의 큐는 다른 스케쥴링 알고리즘을 사용할 수 있다.

어떤 큐를 선택할지 고르는 알고리즘도 필요하다.

### MLFQ(Multi-Level Feedback Queue)

CPU를 기다리는 프로세스를 여러 큐에 줄 세운다는 측면에서 MLQ와 동일하나 프로세스가 하나의 큐에서 다른 큐로 이동가능하다는 점이 다르다.  
그리고 각각의 큐에 우선순위가 정해진다.

1. 맨 처음 프로세스가 레디 큐에 들어오면, 우선순위가 높은 큐에 배정
2. 실행 중인 프로세스가 time quantum을 다 쓰거나 I/O 요청을 하면, 우선순위 낮은 큐에 배정
3. 오래 기다린 프로세스는(특정 기준 이상) 우선순위 높은 큐에 배정

이런 규칙들을 통해 프로세스를 공정하게 관리할 수 있다.