# 레디스 락

싱글 스레드로 작동하며 기본적으로 하나의 명령어가 순차적으로 실행되기 때문에  
일반적인 상황에서는 락이 필요 없다.

하지만 여러 클라이언트가 동시에 접근하는 경우,  
데이터의 일관성을 유지하기 위해 레디스 락을 사용할 수 있다.

## 싱글 인스턴스에서 레디스 락을 사용하는 방법

### 락 획득

`SET NX PX` 명령을 사용하여 레디스 락을 구현할 수 있다.

```
SET lock_key random_value NX PX 30000
```

- `NX`: 해당 key가 존재하지 않을 때만 실행
- `PX {milliseconds}`: {milliseconds} 동안만 해당 key가 존재

A 클라이언트가 위 명령을 실행하고  
B 클라이언트가 같은 명령을 실행하면  
이미 `lock_key`가 존재하기 때문에 실패한다.  
-> A가 락을 획득한 상태 유지

> 여기서 random_value는 랜덤한 값이다.  
> (락을 해제할 때, 해당 값과 일치하는지 확인하기 위해 사용)  
> (UUID나 timestamp 등을 사용한다)

### 락 해제

`EVAL` 명령을 사용하여 레디스 락을 해제한다.

```lua
if redis.call("GET", KEYS[1]) == ARGV[1] then
    return redis.call("DEL", KEYS[1])
else
    return 0
end
```

> 그냥 `DEL` 명령을 사용하면,  
> 다른 클라이언트가 락을 획득한 상태에서 락을 해제할 수 있다.  
> 
> -> 이를 방지하기 위해, 락을 해제할 때 랜덤한 값과 일치하는지 확인한다.

---

## 분산 환경에서 레디스 락을 사용하는 방법

