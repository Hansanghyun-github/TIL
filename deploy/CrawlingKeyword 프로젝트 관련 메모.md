### 멀티스레딩 상황에서 의도적으로 실패하게 만드는 테스트 코드를 작성하자

목표 - crawling 메서드가 실행 중일 때는,  
getNewTitles 메서드는 실행되지 않아야 한다.
-> 그럼 이걸 락을 걸어?
-> 아니면 이전 데이터를 반환해야 하나?

1. 락을 거는 코드 작성
2. 성능 느려지는 테스트 코드 작성(nGrinder)
3. 이전 데이터를 반환하는 코드 작성
4. 이전 코드와 성능 비교하는 테스트 작성

> 사실 베스트는 두 메서드가 무조건 다른 시간에 동작하도록 하는 것인데...
>
> 여러 클라이언트가 항상 같은 시간에 요청을 한다면, 이는 성능 상에 문제가 있다.  
> -> getNewTitles 메서드는 랜덤한 시간에 호출되는게 좋을 것 같다.

처음에는 특정 스레드를 Thread.sleep을 통해 일정 시간동안 멈추게 한다음
락을 확인했다.

이는 적절하지 않다고 생각한다.  
왜냐하면, 멀티스레딩 환경에서는 스레드의 실행 순서가 보장되지 않기 때문이다.  
따라서, 특정 스레드가 먼저 실행되는 것을 보장할 수 없다.

이를 해결하기 위해, 현재 CPU, 메모리 등 환경에 관계 없이  
의도적으로 실패하게 만드는 테스트 코드를 작성하는 것이 좋다고 생각했다.

그럼 어떻게 실패하게 만들 수 있을까?  
-> 스레드 사이의 순서를 보장할 수 있는 방법을 사용하자.
-> CountDownLatch를 사용하자.

---

특정 메서드를 의도적으로 오래 실행하게 만들려면,
내부 메서드를 mocking 한다음, 해당 메서드를 제어하면 된다.

그런데 어떤 메서드는 내부적으로 다른 메서드를 아예 호출하지 않을 수도 있다.

결국 의도적으로 sleep하게 하는 건 좋지 않다.

스레드의 순서를 제어하는게 좋을 것 같다.

---

특정 스레드를 먼저 실행시켰다고 무조건 먼저 실행될까?  
-> 그런 보장이 없다.

그럼 이걸 어떻게 보장해줄 수 있을까?  
-> CountDownLatch를 사용하자.?

---

메서드의 동작 순서를 어떻게 검증하지?  
-> 변수를 하나 만들어서 값의 변화를 지켜보면 되겠네



---

### 크롤링 타이밍, 클라이언트가 요청하는 타이밍을 만들기 위한 아키텍처 설계

---

메서드들의 동시성을 테스트하려는데,  
문제는 코드를 고칠 수가 없잖아.

그렇다고 바이트코드를 주입해?  
너무 번거롭다.

일단 해당 메서드가 내부적으로 다른 메서드를 호출한다면,  
그 메서드를 mocking해서 제어할 수 있을 것 같다.  
(느리게 만들면 됨)

그런데 내부적으로 호출하는 메서드가 아예 없다면?  
그럼 어떻게 해야하지?

> AOP, Mocking 다 외부에서 제어하는 거야.  
> 내부적으론 할 수가 없다.
> Mocking을 해서 메서드 동작을 바꾼다?  
> 그럼 그 메서드를 뭐하러 테스트 하냐고
