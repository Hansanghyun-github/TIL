# SQL (Structured Query Language)

from절의 서브쿼리는 order by 불가능

## 문자다루기

REPLACE(1,2,3)
1에 COLUMN을 넣고 2에 대체할 문자, 3에 대체될 문자 넣음

REPLACE("010-1234-5678", "-", " ") => 010 1234 5678
REPLACE("010-1234-5678", "-") => 01012345678

3번째 인자 안넣으면 NULL로 생각

SUBSTR(1,2,3)

1에 COLUMN, 2에 시작할 위치, 3에 뽑을 개수

2번은 1~N OR -N ~ -1

SUBSTR('HELLO', 3, 1) => L
SUBSTR('HELLO', 3) => LLO
SUBSTR('HELLO', 2, 3) => ELL
SUBSTR('HELLO', -4, 3) => ELO

문자 합칠때는<br>
mysql - concat()<br>
oracle - ||

대문자 변환 - UPPER()<br>
소문자 변환 - LOWER()

---

`MySQL` ifnull(column명, 아무이름)<br>
`Oracle` NVL(column명, 아무이름)

첫번째 인자가 null이라면 두번째 인자 값이 조회된다

null이 아니라면 그대로 조회

`COALESCE(’’, ‘’, ‘’)`

첫번째 인자부터 null이 아닌 값을 조회

💡 coalesce(null, ‘a’) => a <= ifnull(null, ‘a’)

nvl2('1', 2, 3)<br>
'1'이 null이라면 3 , null 이 아니라면 2

---

## 소수점

round(숫자, 자리수) 자리수만큼 소수자리 출력, 반올림

truncate(숫자, 자리수) 자리수만큼 소수자리 출력, 내림

ceil(숫자, 자리수) 자리수만큼 소수자리 출력, 올림

3개모두 자리수 없으면 0으로 취급

---

RANK() - 중복값은 중복등수, 등수 건너뜀 - 1,2,2,4,5<br>
DENSE_RANK() - 중복값은 중복등수, 등수 안 건너뜀 - 1,2,2,3,4<br>
ROW_NUMBER() - 중복값이 있어도 고유 등수 부여 - 1,2,3,4,5

---

순위함수 사용시 ORDER BY를 입력해야 한다.

|구분|설명|
|--|--|
|ROLLUP|- 전체합계와 소그룹 간의 소계를 계산하는 ROLLUP 함수|
|--|예) GROUP BY ROLLUP (DEPTNO); → DEPTNO 합계(소계), 전체 합계를 조회|
|CUBE|- CUBE는 제시한 칼럼에 대해서 결합 가능한 모든 집계를 계산한다.|
|--|- 다차원 집계를 제공하여 다양하게 데이터를 분석할 수 있다.|
|--|예) GROUP BY CUBE(DEPTNO, JOB); → DEPTNO 합계, JOB 합계, DEPTNO & JOB 합계, 전체 합계를 조회, 조합할 수 있는 모든 경우의 수가 조합된다. *시스템에 부하를 많이 주는 단점이 있음|
|GROUPING SET|- 원하는 부분의 소계만 손쉽게 추출하여 계산할 수 있는 GROUPING SETS 함수|

### 인덱스 생성
UNIQUE SCAN : 유일한 값 하나 찾기 (예: 고객아이디) *한개의 행

RANGE SCAN : 어떠한 조건에서 한 범위를 찾기 (예:주문번호)

FULL SCAN : 전체 데이터 *전체 행

---

문자형과 숫자형을 비교 시 문자형을 숫자형으로 묵시적 변환하여 비교한다.

CHAR는 길이가 서로 다르면 짧은 쪽에 스페이스를 추가하여 같은 값으로 판단한다. 같은 값에서 길이만 서로 다를 경우 다른 값으로 판단하는 것은 VARCHAR(가변길이 문자형 : 입력한 크기만큼 할당 )로 비교하는 경우이다

---

메인쿼리의 값을 서브쿼리에서 주입을 받아서 비교를 하는것으로 상호연관 서브쿼리(CORRELATED SUB QUERY) 이다.

---

서브쿼리에 있는 칼럼을 자유롭게 사용할수 없다

---

(오라클 DB에서)
오늘 날짜를 구하기 위해서 SYSDATE+1을 해주면된다. 단, 데이트 타입을 문자열 TO_CHAR 로 변환해주어야 한다.

---

ROLE은 데이터베이스에서 OBJECT(테이블, 프로시저, 뷰) 등의 권한을 묶어서 관리할 수 있다.

---

## 조인 수행 원리
 
조인이란 두 개 이상의 테이블을 하나의 집합으로 만드는 연산이다.

FROM 절에 세 개의 테이블이 존재하더라도 세 개의 테이블이 동시에 조인이 수행되는 것은 아니다.<br>
세 개의 테이블 중에서 먼저 두 개의 테이블에 대해 조인이 수행된다. 그리고 먼저 수행된 조인 결과와 나머지 테이블 사이에서 조인이 수행된다. 

### 1. Nested Loop Join

중첩for문 방식

inner table에 인덱스가 걸려있지 않으면 굉장히 비효율적
> outer table에서 한건한건 조회할때마다 inner table을 full scan해야 하기 떄문

대량의 테이블을 조인하는 방식으로 적절하지 않다

크기가 작은 테이블이 outer table이 되야 성능에 유리하다
> 1:n이라면 1이 outer table로

### 2. Sort Merge Join

NL join에서 두 테이블을 우선 조인컬럼을 기준으로 정렬을 진행하고 조인을 진행한다.

> inner table에 적절한 인덱스가 없어서 NL join을 쓰기에 너무 비효율적일때 사용한다.

equal join이 아니라 범위로 join을 할때 적절한 수행 원리라고 할 수 있다.

table random access가 일어나지 않고 sorting 작업이 PGA영역에서 수행되기 떄문에

경합이 발생하지 않아 성능에 유리한 이점이 있다.

### 3. Hash Join

배치에서 쓰기 좋은 수행원리

대용량 테이블을 조인할떄 쓰기 좋은 조인

PGA영역에 해시 영역을 생성

첫번째 테이블을 해시 테이블에 넣는다.

그리고 두번쨰 테이블이 읽히면서 조인이 되는 원리

해쉬 영역에 올라갈때 JoinColumn을 기준으로 hash function이 적용되기 때문에

key 컬럼에 중복값이 없을수록 성능에 유리하다

> equal join만 가능하다. 범위 조인 x

> sort merge join처럼 random access 부하가 없다.

> 유의할점
>
> 해시영역에 들어가는 테이블의 크기가 충분히 작아야 성능에 유리하다.
>
> 너무 커지면 디스크 영역을 사용하게 되어 성능이 안좋아진다.

수행빈도가 높은 OLTP 환경에서 이 조인을 사용하게 되면<br>
오히려 CPU나 메모리의 사용량이 늘어서 성능이 안좋아질수있다.

---

# 인덱스(index)

조건을 만족하는 튜플들을 빠르게 조회하기 위해

    빠르게 정렬(order by)하거나 그룹핑(group by)하기 위해

인덱스를 저장하는데 생기는 오버헤드 & 인덱스를 유지하는데 생기는 오버헤드(DML로 바뀌면 인덱스도 업데이트 필요) 생각해야함

```CREATE [UNIQUE] INDEX 인덱스이름 ON 테이블이름(column 이름1, 2, ...)```

[UNIQUE]는 해당 COLUMN 들이 유니크할때만 가능

    대부분의 RDBMS에서, PK에 인덱스가 자동으로 생성된다.

MYSQL에서 어떤 인덱스 쓰는지 확인하는 방법 - EXPLAIN 명령어

MYSQL에서 특정 인덱스를 사용하도록 명령하는 방법 - USE INDEX, FORCE INDEX

> 조회하려는 데이터가 테이블의 상당 부분을 차지할때는 인덱스 말고 FULL SCAN을 사용하는 것이 좋다.
---

### 트리기반 인덱스 (B+Tree)
Branch 블록과 Leaf 블록으로 구성되있으며, 브랜치 블록을 루트 블록이라고 한다.

브랜치 블록은 분기를 목적으로 하고, 리프블록은 인덱스를 구성하는 컬럼의 값으로 정렬되며, OLTP 시스템 환경에거 가장 많이 사용된다. 

인덱스를 생성할 때 동일 컬럼으로 구성된 인덱스를 중복해서 생성할 수 없다. 그러나 인덱스 구성 컬럼은 동일하지만 컬럼 순서가 다르면 서로 다른 인덱스로 생성. JOB + SAL 과 SAL + JOB은 다르다.

데이터가 전체 데이터의 10%의 적은 데이터에서 사용하는 것이 유용하다.

    `B-tree vs B+tree`

    B-tree는 리프노드가 아닌 노드에도 VALUE(데이터)가 있다.
    B+tree는 리프노드에만 VALUE(데이터)가 있다. & 리프노드끼리 연결되어 있음
    -> 범위 검색 빠름


---

### CLUSTERED 인덱스
인덱스의 리프 페이지가 곧 데이터 페이지로서, 테이블 탐색에 필요한 레코드 식별자가 리프페이지에 없다.

리프 페이지의 모든 데이터는 인덱스 키 컬럼 순으로 물리적으로 정렬되어 저장된다.

Row id 는 리프페이지에 없다. 모든 row는 인덱스 키 컬럼순으로 정렬

    실제 페이지가 정렬됨

---

### Bit - map 인덱스
시스템에서 사용될 질의를 시스템 구현 시에 모두 알 수 없는 경우인 DW 및 AD-HOC 질의 환경을 위해서 설계 되었으며, 하나의 인덱스 키 엔트리가 많은 행에 대한 포인터를 저장하고 있는 구조이다.

인덱스는 테이블 기반 선택적 생성구조로서, 오름차순, 내림차순 정렬이 가능하다.

비용기반 옵티마지어는 소요되는 비용을 계산하지만 인덱스 스캔이 항상 유리한 것은 아니다.

규칙 기반 옵티마이저는 적적한 인덱스가 존재하면, 항상 인덱스를 사용하려고 한다.

인덱스 범위 스캔은 겨로가가 없으면 한 건도 반환하지 않을 수 있다.

인덱스를 활용해서 데이터를 조회할 때 인덱스를 구성하는 컬럼들의 순서는 SQL 실행 성능과 관계가 없다.

---

### DUAL 테이블

더미 column만 있는 테이블,

그냥 함수 결과나 현재 시간 구할때 쓴다.

---

### DECODE

오라클의 if else 문

DECODE(컬럼, 조건1, 결과1, 조건2, 결과2, ...)

---

### MERGE

UPDATE와 INSERT를 한방에 해결해주는 쿼리

    한 테이블에 해당하는 데이터가 있으면 UPDATE하고 없으면 INSERT 해라

![Alt text](img1.daumcdn-4.png)