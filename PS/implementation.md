### 프로그래머스 징검다리 건너기

https://school.programmers.co.kr/learn/courses/30/lessons/64062

> 징검다리를 표현하는 배열이 주어지는데, 징검다리를 밟을때마다 수가 1씩 감소함, 수가 0이 되면 그 돌은 밟지 못함, 징검다리 배열과 한번에 건널 수 있는 최대 칸수 k가 주어졌을때 최대 몇명이 징검다리를 건널수 있는지 구하는 문제

사용한 알고리즘: 슬라이딩 윈도우
> 이분탐색도 있다고 하지만, 생각나지는 않음

시간복잡도: $O(n)$

`처음에 접근한 방법`<br>
k의 범위 내에서 제일 높은 값 -> 그 칸에서 최대로 건널수 있는 사람의 수
0부터 n-1까지 k 범위씩 해당 범위 에서 제일 높은 값을 찾고, 모든 결과중에서 가장 작은 값이 답이 되도록 풀었다.

여기서 최적화를 위해,<br>
다음 돌을 볼때 현재 버려야 하는 돌의 값이 max가 아니라면 -> 다음 범위로 가도 max값은 변하지 않음<br>
바로 다음 인덱스로 이동했고, <br>
새로 추가하는 돌의 값이 max보다 크지 않다면 -> 똑같이 max값 안변함<br>
바로 다음 인덱스로 이동했다.<br>
위에 해당하지 않는다면 다시 해당 인덱스에서 k번 검사하여 최댓값을 찾았다.

답은 맞지만, 시간복잡도가 $O((n-k)k)$라서 효율성 검사 13번에서 시간초과가 났다.

> 이 접근은 대부분의 케이스는 다른 알고리즘보다 시간이 덜 걸렸다.
> 
> 그런데 k=3일때, [20, 19, 18, 17, 16, 15, ...] 이런 배열이 주어지면 최적화의 의미가 없다.
>> 버리는 돌의 값이 max에 해당하고, 추가하는 돌의 값이 max보다 작기 때문에, 항상 k번 연산 진행됨
>
> 이런 케이스에 해당하면 시간초과가 났다. -> 그래서 통과못함

`다음으로 접근한 방법`<br>
이 접근은 다른 사람의 풀이를 보고 이해했다.

```deque<pair<int,int>>``` {돌의 값, 인덱스}를 저장

항상 deque에 k개의 돌을 추가하는데, 여기서 규칙이 있다.
> 항상 내림차순으로 정렬되어있음

인덱스가 k 범위를 벗어 났다면, 첫번째돌을 제거<br>
그리고 새로운 돌을 추가하는데, 마지막돌들이 새로운 돌보다 값이 작다면 마지막 돌들을 제거한다.
> 이렇게 되면 deque가 항상 내림차순으로 저장된다.

원래였다면 deque에 인덱스를 저장할 필요는 없지만, 중간중간 빠진 돌이 있기 때문에, 나중에 버릴수있는 돌이진 체크하기 위해 인덱스가 추가됨

항상 내림차순으로 정렬되어 있기 때문에, 맨 앞의 돌이 최댓값이다.

이 접근 방법은 모든 케이스에 대해 비슷한 시간복잡도가 나온다. - 문제 통과함

> 첫번째 접근은 조건부 케이스를 제외하고는 좋은 결과가 나왔지만, 특정 케이스에 대해 시간초과가 나옴<br>
> 두번째 접근은 항상 시간복잡도가 비슷하게 나왔다.

---

### 프로그래머스 다단계 칫솔 판매

https://school.programmers.co.kr/learn/courses/30/lessons/77486

> 다단계 직원들의 구조가 주어졌을떄, 어떤 직원이 물건을 판매하면 해당 직원은 물건 값의 90%의 이익을 얻고, 부모노드는 10%의 이익을 얻는다. 이때 부모노드가 없을때까지 반복된다. 이런 관계에서 직원들의 구조와 판매자의 정보가 주어졌을떄, 전체 직원들의 수익은 얼마인지 구하는 문제

사용한 알고리즘: 트리, 해시

시간복잡도: $O(n * log m)$ - n은 판매자 배열의 길이, m은 직원수

그냥 직원에 해당하는 문자열과 배열에서의 위치 정보를 map(해시테이블)에 넣고<br>
판매자 배열을 for문으로 탐색하면 된다.

처음에는 수익이 최대 루트 노드까지 전달되기 때문에,<br>
시간복잡도가 $O(n*m)$ 이라고 생각했는데,

문제를 다시보니 판매량의 범위가 최대 10000원이라 아무리 부모노드를 많이 거쳐도 최대 5번밖에 탐색하지 않는걸 확인했다.

그냥 트리와 해시의 구현 문제였다.

---
