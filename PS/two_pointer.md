### 1806 부분합
> n개의 자연수로 이루어진 수열이 주어졌을때, 
> 이 수열에서 연속된 수들의 부분합 중에 그 합이 s 이상 되는 것중 가장 짧은 것의 길이를 구하는 문제

시간복잡도 $O(n)$
두개의 포인터 l,r (l=0, r=1), result = MAX (MAX > n)

l번째 위치부터 r-1번째 위치까지의 합을 cur이라 하면

cur < s 일때 l++

cur >=s 일때 r++,
현재 r - l 이 result보다 작다면 result = r - l

답은 result

---

### 17609 회문
> 문자열이 주어졌을때 그 문자열이 회문인지, 유사 회문인지, 일반 문자열인지 구하는 문제
> (회문 = 대칭인 문자열, 유사 회문 = 문자 한개 뺐을때 대칭인 문자열)

투포인터를 이용한 문자열 문제

문자열의 양쪽끝에 포인터를 둔 후, 해당 위치의 문자가 같다면 한칸씩 중간으로 옮긴다.

모든 위치의 문자를 통과하면 회문

해당 위치의 문자가 다르다면 세가지 경우의 수가 있음
1. 왼쪽 포인터의 위치를 +1 해주고 다시 진행, 전부 통과하면 유사 회문
2. 오른쪽 포인터의 위치를 -1 해주고 다시 진행, 전부 통과하면 유사 회문
3. 1,2 둘다 실패하면 일반 문자열

---

### 프로그래머스 보석 쇼핑

https://school.programmers.co.kr/learn/courses/30/lessons/67258

> 보석들의 이름이 담긴 배열이 주어졌을때, 모든 보석을 포함하는데, 길이가 가장 짧은 두 위치를 찾는 문제

사용한 알고리즘: 투포인터, map 

시간복잡도: $O(n)$

첫 접근: 그리디 - 시간복잡도가 $O((보석의 개수)^n)$ 너무 높아서 포기

두번째 접근: dp - 시간복잡도가 $O(n^2)$ n이 최대 100000이라 포기

마지막 접근: 투포인터 - 좋은 접근이였지만 두 포인터 사이의 보석의 개수를 세는 부분을 제대로 체크 못해서 풀지 못했다.

나는 각 위치마다 몇개의 보석을 포함하고 있는지를 체크해주는 배열을 만들려고 했다.

필요한 배열 크기: n * 보석의 개수

시간복잡도: $O(n * 보석의개수)$ 너무 높아서 안될것같아서 못했다.

결국 찾은 답은,

처음부터 모든 보석을 세려고 하지 말고, 

해당 위치에 있는 보석만 추가해주면된다.

> 이렇게 할 수 있는 이유는, 배열의 특정 위치에는 `보석 한개`만 있기 때문이다.
>
> 만약 특정 위치에 보석 여러개가 있었다면 내가 생각한 알고리즘을 쓰는게 맞을수도 있다.

이 알고리즘의 시간복잡도: $O(n)$