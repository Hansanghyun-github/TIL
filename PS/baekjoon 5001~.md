### 5557 1학년

https://www.acmicpc.net/problem/5557

> n개의 숫자가 주어졌을때(n <= 100), +와 0을 이용해 마지막 숫자를 제외하고 식을 만드는데, 이 식이 마지막 숫자와 같은 경우의 수를 구하는 문제(계산 값(중간에 나오는 수 모두)은 0에서 20사이)

사용한 알고리즘: DP

시간복잡도: $O(n)$

DP의 시작은 완전탐색

맨처음부터 +를 적용할떄와 -를 적용할때를 다 구하면 풀수 있음. 이 접근의 시간복잡도는 $O(2^n)$

이때 중간에 나오는 수는 모두 0에서 20사이기 때문에, 20*100 크기의 cache를 선언해서 저장해주면 dp로 가능하다.

    cache[i][j]의 의미 = j번쨰 숫자에서, 식의 결과가 i일때의 답이 나올 수 있는 모든 경우의 수

    find(int cur, int n) = n번째 숫자에서, 결과가 cur일때, 답이 나올 수 있는 모든 경우의 수를 반환

DP를 썼을 때 시간복잡도: $O(n)$

> 수의 범위가 0에서 20사이라서 DP로 가능했던 문제

---

### 5582 공통 부분 문자열
> 문자열 두개가 주어졌을때 두 문자열의 공통 부분 문자열을 구하는 문제(연속된 부분 문자열) 

dp를 이용한 문자열 문제

if(str1[i] == str2[j]) dp[i][j] = dp[i-1][j-1] + 1

---

### 9251 LCS(최장 공통 부분 수열)


💡 두 수열이 주어졌을때 모두의 부분 수열중 가장 긴것을 찾는 문제


시간복잡도: $O(n^2)$

이중포문을 이용 행은 첫번째 수열, 열은 두번째 수열

수열의 원소한개씩 비교하는데,

두 원소가 같다면, $dp[i][j]=dp[i-1][j-1]+1$

다르다면, $dp[i][j]=max(dp[i-1][j],dp[i][j-1])$

그리고 dp의 마지막 원소가 정답이다.

풀이

dp[i][j]는 현재 위치에서 LCS의 길이이다. - 최대길이

현재위치(i,j)에서 두 수열의 원소가 같다면,

$A_{i-1}$와 $B_{j-1}$의 최대길이(dp[i-1][j-1]) + 1이  현재위치의 최대길이(dp[i][j])이다.

현재위치에서 두 수열의 원소가 다르다면,

이전 위치에서의 최대길이 $max(dp[i-1][j],dp[i][j-1])$가 현재 위치의 최대길이이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 9328 열쇠

https://www.acmicpc.net/problem/9328

사용한 자료구조 & 알고리즘: 구현, BFS

시간복잡도: $O(26 * n^2)$ (26 = 알파벳 개수)

키를 얻을 때마다, 다시 탐색을 해줘야 한다. (갈 수 있는 위치가 늘어나기 때문)

0. 입구 찾아 저장 해놓기

1. 현재 가지고 있는 열쇠를 가지고 탐색 시작  
1-1. 문서 찾으면 result + 1  
1-2. 열쇠 찾으면 nextKey에 저장

2. curKey와 nextKey 비교  
2-1 같다면 종료(더이상 못찾는다)  
2-2 다르다면 1로 돌아감(더 찾을 수 있음)

3. 결과 출력

`여기서 놓쳐서 시간 잡아먹은 점`
1. 오타(nr -> nc)
2. BFS의 첫번째 위치 경우의 수 코딩 안했음

> BFS는 항상 첫번째 케이스를 놓치지 말고 코딩해줘야 한다.

---

### 9944 NxM 보드 완주하기

https://www.acmicpc.net/problem/9944

사용한 자료구조 & 알고리즘: 구현 & dfs

시간복잡도: $O()$ - 모르겠다....

어떻게 접근했는지, 풀었는지 설명:

1 - 빈 칸 중에서 한 칸을 공을 놓는 위치로 지정 - n^2  
2 - dfs를 통해 공을 이리저리 굴려본다.  
2-1 빈칸이 아예 없다면 그때의 공이 움직인 횟수 비교 - 결과 저장  
2-2 움직이지 못하는데 빈칸이 남았다면 그냥 끝냄  
2-3 빈칸이 남았고 움직일 수 있다면 다른 곳으로 굴린다.  
(최적화를 위해 현재 결과값 보다, 공이 움직인 횟수가 많다면 그냥 끝낸다)

> 여기서 놓친 부분
> 
> 공이 움직이고 나서, 재귀를 실행하기 전 visited를 체크할지,  
> 재귀를 실행하고 나서 visited를 체크할지 고민이 많이 됐다.  
> (놓치진 않았지만, 이것 때문에 시간이 오래걸렸다)
> 
> 출력 예시를 제대로 봤어야 했는데, 자세히 안봐서 어이없게 틀렸다

> 이런 문제는 시간복잡도를 어떻게 구할지 모르겠다.
> 
> 특히 재귀 부분을 어떻게 계산할지를 모르겠다.  
> (이 문제는 visited 체크했다가, 다시 지우고 실행하기 때문에 기존의 dfs와 다르다(더 오래걸린다))

---

### 10775

https://www.acmicpc.net/problem/10775

사용한 자료구조 & 알고리즘: 그리디 & 분리 집합

시간복잡도: $O(nlogn)$

어떻게 접근했는지, 풀었는지 설명:

여기서 적용할 아이디어  
i번째 비행기 gi를 할 수 있는 한 가장 높은 게이트(<= gi)에 도킹시켜야 한다.  
그래야 최대한 많은 비행기를 도킹시킬 수 있다.

여기서 문제는  
input이 10만이라는 것 - $O(n^2)$ 안됨  
O(logn)만에 풀 수 있는 알고리즘을 적용해야 한다.

분리 집합을 적용 - O(logn)에 가능

풀이 순서
1. 도킹 가능한 게이트를 찾는다.  
1-1 없다면(가능한 게이트가 0번) 종료
2. Union(docking, docking - 1) // 찾은 게이트와 이전 번호 게이트를 연결(같은 집합으로)

> 여기서 헤맨 이유
> 
> 처음에는 O(logn) 으로 이분 탐색(lower_bound 메서드)를 적용하려고 했다.  
> 그런데 도킹한 게이트는 컨테이너에 제거해야 해서 list 컨테이너를 사용했는데,  
> list 컨테이너는 이분탐색이 불가능하다(O(n)) - 인덱스로 접근이 안되기 때문

---

### 10800 컬러볼

https://www.acmicpc.net/problem/10800

사용한 자료구조 & 알고리즘: 누적합, 정렬

시간복잡도: $O(n)$

어떻게 접근했는지, 풀었는지 설명:

두개의 컨테이너를 사용했다.

첫번쨰 컨테이너: 현재 볼이 (색깔에 관계없이) 잡을 수 있는 공의 크기의 합  
두번째 컨테이너: 현재 볼이 (같은 색 기준) 잡을 수 있는 공의 크기의 합

(첫번째 컨테이너의 값 - 두번쨰 컨테이너의 값)이 정답

대신 컨테이너들은 크기순으로 정렬되기 떄문에,  
i번째 공이 각각의 컨테이너에서 몇번쨰에 담겨져 있는지 인덱싱이 필요하다.

추가 메모리가 꽤 많이 발생했지만, 인덱싱 덕분에 O(1)에 풀 수 있었다. 

> 이 문제의 핵심은 $O(n^2)$을 트리 or 해시 등를 이용해서 O(logn) or O(n)으로 줄이는 것

> 놓친점
> 
> 크기가 같은 공을 생각하지 못했다.  
> -> 이전 공과 크기가 같다면, 현재 값 = 이전 값 처리
> 
> 크기가 같은 공이 여러개 일때, 다음 공의 case를 생각하지 못했다.  
> -> count를 따로 추가해줘서 겹치는 공이 몇개였는지 체크해줬다.

---

### 11000 강의실 배정

https://www.acmicpc.net/problem/11000

사용한 자료구조 & 알고리즘: 그리디, 우선순위 큐

시간복잡도: $O(nlgn)$

어떻게 접근했는지, 풀었는지 설명:

처음에는 list를 이용해서 풀려고 했음(중간 노드 삭제 편하도록) - 시간복잡도 $O(n^2)$ (시간 초과)

검색을 통해 다른 방법을 알게 되었다. - 우선순위 큐 이용(강의의 끝나는 시간을 오름차순으로 저장) 

(i번째 강의에 접근 중이라면, 우선순위 큐는 i-1번째 강의까지의 끝나는 시간을 저장하고 있다)  
이전 강의까지의 끝나는 시간중 가장 낮은 시간과 현재 강의의 시작 시간을 비교
1. 끝나는 시간 <= 현재 강의 시작 시간 - 우선순위 큐 pop & 현재 강의 시작 시간 push
2. 끝나는 시간 > 현재 강의 시작 시간 - 우선순위 큐 현재 강의 시작 시간 push

우선순위 큐의 size를 출력으로 마무리

우선순위 큐를 이용한 알고리즘의 시간복잡도 - $O(nlgn)$

> 검색을 통해 찾은 방법의 특징은  
> 이전 강의들 중 가장 빨리 끝나는 시간만을 비교해도 상관없다는 특징을 이용했다(그리디)
> 
> (나는 한 강의를 전체 강의와 비교하려고 했다 - 시간 초과)

---

### 11054 가장 긴 바이토닉 부분 수열(요약 LBS)


💡 수열이 주어졌을때, $S_1<S_2<...<S_k>S_{k+1}>...>S_n$을 만족하는 부분수열의 최대길이를 구하는 문제



시간복잡도: $O(n^2)$

가장 긴 증가하는 부분 수열의 응용버전

(Longest Increasing Subsequence)

LIS를 두번 구하면 끝남

0을 기준으로 n-1까지 LIS를 구함 - dp1

그리고 n-1을 기준으로 0까지 LIS를 구함 - dp2

(0을 기준으로 하면 LDS이다)

dp1[i]+dp2[i]-1의 최댓값이 정답이다.

풀이

dp1[i]는 0부터 i까지의 원소중에 LIS

dp2[i]는 n-1부터 i까지의 원소중의 LIS

따라서 dp1[i]+dp2[i]-1은 현재 원소가 가장 큰 원소일때의 LBS를 만족하는 최대 길이이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 11060 점프 점프

https://www.acmicpc.net/problem/11060

> 1xn 크기의 배열이 있을때 0번 위치에서 출발해서 오른쪽 끝에 도달하는 최솟값을 구한다. 점프는 보드에 있는 숫자 내만큼 점프가능하다.
(3번위치에서 3이라면 4,5,6 점프 가능)

사용한 알고리즘: DP

시간복잡도: $O(n^2)$

완전 탐색으로 시작하는데,

현재 위치에서 최소해를 구했다면 이 값을 cache에 저장해놓는다.

다음에는 굳이 같은 위치에서 최소해를 구할필요 없음

    문제 자체는 쉬운 문제였다. 그냥 DP 연습을 위해 풀었음

    최적화 문제를 동적 계획법으로 풀때는
    1. 완전 탐색으로 풀고
    2. 전체 답을 구하지 말고 현재 위치에서 최소해를 구하는 메서드로 변환
    3. 메모이제이션 이용

    위 방법을 생각하면서 풀자

---

### 12869 뮤탈리스크

https://www.acmicpc.net/problem/12869

사용한 자료구조 & 알고리즘: dp

시간복잡도: $O(n^3)$ (n <= 60)

dp를 이용한 재귀 함수로 풀었다.

int find(int x, int y, int z) // 3대 로봇의 체력이 주어졌을 때, 최소 몇번만에 모두 없앨 수 있는지 반환



---

### 14719 빗물

https://www.acmicpc.net/problem/14719

> 2차원 세계에 블록이 쌓여있다. 비가 충분히 많이 왔을 때, 블록 사이에 빗물이 고이는데, 고이는 빗물의 총량을 구하라.

사용한 알고리즘: 구현

시간복잡도: $O(n^2)$ (n <= 500)

(현재 위치에서 빗물이 고이는 조건 - 양쪽 블럭의 높이가 현재 위치보다 높아야 함)  
바닥부터 위로 한 줄씩 서치한다.  
현재 위치보다 높은 칸이 있다면, 다음으로 높은 칸 있는지 서치  
현재 위치보다 높은 칸이 없다면, 그대로 종료(더 이상 빗물이 고일 수 없음)

다음으로 높은 칸 서치할 때, 높은 칸 있다면, 이전 위치들에 빗물을 채움

> 이 문제를 풀 때, 설계와 구현을 분리해서 빨리 풀 수 있었다.  
> 그리고 input을 받는 변수는 대문자로 정의해서 구분하는 것이 좋을 것 같다.

---

### 16194 카드 구매하기2

https://www.acmicpc.net/problem/16194

> n개의 카드팩의 가격이 주어진다. i(1~n)번째 카드팩에는 i개의 카드가 들어있다. 이때 n개의 카드를 구매하기위한 최솟값을 구하는 프로그램을 작성하라(딱 n개, n개 넘으면 안됨)

사용한 알고리즘: DP

시간복잡도: $O(n^2)$

이 문제도 위문제처럼, 완전 탐색으로 시작했다.

find(x)라는 재귀함수를 생성

find(x) = x개의 카드를 구매하기 위한 최솟값을 반환하는 함수

이때 점화식: $find(x) = min^x_{L=1}(card[L] + find(x-L))$

이때 함수를 그냥 실행하면 시간복잡도가 $O(n!)$인데 (그냥 대충 계산했을때)

이때 각 위치의 값을 저장해놓으면(메모이제이션)

시간복잡도가 $O(n^2)$으로 감소한다.

---

### 16637 괄호 추가하기

https://www.acmicpc.net/problem/16637

> n개의 문자로 이루어진 수식이 주어졌을때, 괄호를 추가하여 얻을 수 있는 최댓값을 구하시오<br>
(연산자 우선순위는 없다 - 그냥 왼쪽에서 오른쪽으로 계산)<br>
(괄호 안에 연산자는 1개만, 괄호 중첩은 불가능)

사용한 알고리즘: 브루트포스(그냥 쌩 구현)

시간복잡도: $O()$

처음에는 DP처럼 접근했다.<br>
앞의 식이 뒤의 식에 영향을 안끼친다고 생각해서

그런데 이 접근은 틀렸다.

뒤를 먼저 계산하는건 전체에 괄호를 추가하는 것과 같다 - 이는 잘못된 접근

그냥 무식하게 풀어야 한다.

dfs 방식으로 괄호 넣었다 뺐다 하면서 모든 경우의 수를 체크했다.

인풋 범위가 작아서 가능한 알고리즘

---

### 16926 배열 돌리기 1

https://www.acmicpc.net/problem/16926

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(n^2*r)$

어떻게 접근했는지, 풀었는지 설명:

현재 배열 위치에서 다음 위치를 찾는 규칙을 찾으면 금방 풀린다.

> 배열 돌리는 문제를 너무 안풀어서,  
> 이런 문제들을 많이 풀어봐야겠다.

---

### 16927 배열 돌리기 2

https://www.acmicpc.net/problem/16927

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(n^2 * r)$

어떻게 접근했는지, 풀었는지 설명:

16926번 문제에서 약간의 아이디어만 추가한 문제

배열을 회전하는데 회전해야 하는 횟수가 너무 크면 최적화를 해야 한다.

    4*5 배열을 10000번 회전한다면,
    할 수는 있지만, 너무 비효율적
    회전하는 횟수를 줄인다.

    가장 외곽라인은 14번마다 값이 반복된다. 
    그리고 안쪽라인은 6번마다 값이 반복된다.
    => R %= 2*(N+1-2*k) + 2*(M+1-2*k)
    (k는 안쪽라인으로 들어가는 횟수)

---

### 16935 배열 돌리기 3

https://www.acmicpc.net/problem/16935

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(N*M*R)$

어떻게 접근했는지, 풀었는지 설명:

배열 좌우반전, 상하반전, 90도 시계방향/반시계방향 회전,  
4등분으로 나눠서 시계방향/반시계방향 회전을  
코드로 구현하면 끝나는 문제

좌우반전 - [r][M-c-1] = [r][c]  
상하반전 - [N-r-1][c] = [r][c]  
90도 시계방향 회전 - [c][N-r-1] = [r][c]  
90도 반시계방향 회전 - [M-c-1][r] = [r][c]  

> 여기서 헷갈린 부분
> 
> 1  
> 90도 회전할 때 N과 M이 다를 수가 있다.  
> 그래서 처음에는 회전시키고 앞부분의 빈공간을 땡겨야한다고 생각했는데,  
> 그럴 필요가 없었다.  
> (그냥 N과 M만 swap 해주면 끝남)  
> (만약 N과 M을 더 큰 값으로 통일 시킨다면 떙겨줘야 한다)
> 
> 2  
> 4등분으로 나눠서 회전시키는 부분에서  
> r은 0부터 N/2 전까지만 탐색해줘야 하고,  
> c는 0부터 M/2 전까지만 탐색해줘야 한다는 것을 처음에 놓쳤다.
> 
> -> 항상 테스트 케이스를 잘 확인하자

---

### 16986 인싸들의 가위바위보

https://www.acmicpc.net/problem/16986

사용한 자료구조 & 알고리즘: 구현, 백트래킹

시간복잡도: $O(9!)$

어떻게 접근했는지, 풀었는지 설명:

그냥 게임을 진행한다.  
first or second가 지우라면, 지우가 낼 수 있는 손동작을 하나씩 다 내보면서 재귀함수를 실행한다.  
(재귀함수의 결과가 true라면 그대로 종료, false라면 다음 손동작을 내고 재귀 실행)  
f or s 모두 지우가 아니라면, 이미 있는 족보대로 게임을 진행한다.

(지우는 손동작이 겹치면 안되기 떄문에 visited로 체크해줬다)

게임을 진행하다가, 지우의 승수가 K라면 true, 지우가 아닌 다른 사람의 승수가 K라면 false

> 이런 방법도 가능할 것 같다.
> 
> 먼저 지우의 가위바위보 순서를 정해놓고, 게임을 진행하는 것  
> (훨씬 깔끔한데?)  
> 
> f or s가 지우인지 체크안해도 된다.  
> 그냥 미리 정해놓은 족보대로 게임 진행하면 되니까

> 이 문제에서 놓친점
> 
> 가위바위보 순서  
> 나는 이긴 사람, 남은 사람 순서로 진행하는 줄 알았는데  
> 지우,경희,민호 순으로 게임을 진행하는 것이었다.  
> (이것때문에 1시간 까먹음)
> 
> 재귀함수 테스트  
> 재귀함수 테스트를 cout로 일일이 확인하는 과정이 너무 오래걸렸다.
> 
> 파라미터 범위 벗어남  
> 파라미터의 값이 배열의 범위를 벗어나서 런타임 에러  
> -> assert를 이용해 체크해줘야 한다.

> 이 문제를 통해 느낀것
> 
> 1. 문제를 제대로 읽자(테스트 케이스도 제대로 보자)  
>   내가 이해한 룰대로 테스트 케이스를 따라가 보자 - 제대로 되는지
> 2. enum을 활용해보자(숫자로는 귀찮을때가 있다)
> 3. assert를 활용해보자(테스트 빠르게 해준다)
> 4. 재귀함수 테스트 케이스는 분석이 너무 어렵다.

---

### 17135 캐슬 디펜스

https://www.acmicpc.net/problem/17135

> n*m 크기의 보드 위에 몬스터가 있다.  
> n+1 행에 위치한 3명의 궁수가 몬스터를 잡을 수 있다.
> 공격 가능 거리 D  
> (거리 가까운 순, 가장 왼쪽에 있는 순 우선순위)  
> 모든 궁수가 동시에 공격한 뒤 몬스터가 아래로 한칸 이동
> 공격과 이동을 반복한다.
> 
> 궁수의 공격으로 제거할 수 있는 적의 최대 수를 출력하는 문제

사용한 알고리즘: 구현 & BFS

시간복잡도: $O(n^6)$  
(n<=15 가능)

(궁수 3명을 어떻게 배치할지 - 조합(백트래킹))

1 -  궁수 3명을 배치한다.  
2 -  한 라운드씩 진행  
2-1 - 궁수가 적을 찾는다.  
2-2 - 찾은 적들 죽인다.
2-3 - 몬스터 한 칸씩 이동

위 과정을 반복하면서 최댓값을 구한다.

> 무난한 구현문제였지만, 궁수들의 공격 우선순위를 놓쳐서 한번 틀렸다.  
> (처음에는 일반적인 BFS로 풀었음)
>
> 항상 놓치고 있는 건 없는지 확인하자.  
> 처음부터 헷갈릴 만한 것들을 체크해 놓자.

---

### 17136 색종이 붙이기

https://www.acmicpc.net/problem/17136

> 10x10 크기의 보드가 있고<br>
1x1, 2x2, 3x3, 4x4, 5x5 크기의 색종이들이 5장씩 있다<br>
10x10 보드에서 1인 칸을 채우기 위해 색종이를 사용하는데<br>
색종이를 최소 몇개로 보드를 채울 수 있는지 구하라<br>
불가능하면 -1 출력

사용한 알고리즘: 백트래킹, 특이한 dfs

시간복잡도: $O()$

처음부터 무조건 큰 크기의 색종이를 붙이는게 최적해가 되지 않는다.

따라서 5x5 색종이가 가능하면, 5x5도 붙여보고, 그것보다 작은 크기의 색종이도 붙여보면서 일일이 값을 비교해야 한다.

따라서 그리디는 불가능하고, 백트래킹 알고리즘이 가능하다.<br>
(이전에 구한 해보다, 현재 값이 크거나 같다면 그대로 종료)<br>
(무조건 배열의 다음 위치부터 찾는다)

> 여기서 하나 실수한 것이 있는데,<br>
> 백트래킹은 bottom-up만 가능한데, 나는 처음에 top-down으로 접근해서 시간이 많이 지체됐다.<br>
> 그리고 하나 놓친 부분이 있는데, 무조건 배열의 다음 위치부터 찾는걸 놓쳐서<br>
> 처음 시도했을 때 시간초과가 났다.

---

### 17142 연구소 3

https://www.acmicpc.net/problem/17142

> nxn 보드에 비활성화된 바이러스가 있다<br>
여기서 m개를 활성화시켜서 벽을 제외한 모든 빈칸을 바이러스로 채우려고 한다.<br>
바이러스가 1칸 퍼지는데 1초걸릴때, 모든 빈칸이 바이러스로 덮이는 최소시간은?<br>
(비활성화 바이러스가 활성화 바이러스를 만나면 활성화 바이러스로 바뀐다)<br>
(m <= 10)

사용한 알고리즘: bfs & 구현

시간복잡도: $O(_{10}C_5*n^2)$

1. 전체 바이러스가 k개라면(k>=m), 여기서 m개를 골라야 한다. - 최대 $_{10}C_5$
2. bfs를 이용해 바이러스가 퍼지는 시간을 구한다 - $n^2$

처음 제출했을 때는, 시간초과가 났다. <br>
그 이유는 2번을 구현할 때, 매 round마다 바이러스가 모두 퍼졌는지 확인을 해야하는데, 처음에는 이 작업을 모든 칸을 확인했다.(빈칸이 있는지)<br>
그리고 벽때문에 바이러스가 퍼질수 없는지도 확인해야 해서 같이 검사했다.<br>
(이는 이전 보드와 현재 보드 값을 비교했다 - 같은지 다른지)
여기서 시간복잡도가 너무 높게 나왔다.<br>

그래서 모든 칸을 검사하지 않고, 처음 빈칸의 개수를 세주고, 매 round마다 빈칸의 개수가 0이면 바로 탈출하도록 세팅했다.<br>
그리고 한번이라도 바이러스가 퍼졌다면 false로 초기화된 flag에 true를 줬다.

>flag=true // 바이러스가 최소한칸은 퍼졌다. -> 아직 더 퍼질수 있음<br>
flag=false // 한칸도 퍼지지 않았다. -> 더이상 퍼질수 없다.
>   
>빈칸의 개수 > 0 && flag==false<br>
>=> 모든 빈 칸에 바이러스를 퍼뜨릴 수 없다.

bfs 구현은 많이 해봐서 무난했지만, 1번을 구현하는 것이 어색했다. - 시간 많이 잡아먹음

그리고 1번을 수행할때마다, 2번에 필요한 변수들을 초기화해주는것이 많이 헷갈렸다.

문제를 자주 풀어야 익숙해진다.

---

### 17143 단어 뒤집기2

https://www.acmicpc.net/problem/17413

> 문자열이 주어졌을 때, 단어들을 뒤집어서 출력하는 문제(태그와 공백으로 구분, 태그는 그대로 출력)  
<int>fds asdw<max> => <int>sdf wdsa<max>

사용한 알고리즘: 그냥 문자열

시간복잡도: $O(n)$

문자 한개씩 탐색하는데,  
공백이나 태그라면 그대로 출력한다.

여기서 그냥 단어가 나왔다면, 단어의 끝을 찾아서(다음 문자가 공백이나 태그일 때), 단어의 끝부터 시작까지 반대로 출력한다.

문제가 생긴것은, cin >> str; 은 공백을 받지 않기 때문에, 다른 메서드를 써야 했다.  
getline(cin, str) 메서드를 사용해서 문제를 해결했다.

---

### 17406 배열 돌리기 4

https://www.acmicpc.net/problem/17406

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(6! * 6 * 50^2)$

어떻게 접근했는지, 풀었는지 설명:

배열을 돌리는 입력의 순서를 임의로 정할 수 있다. -> next_permutation  
(그냥 순열)

1. 임의의 순서 정함 - 6!
2. 정한 순서대로 배열 돌린다 - 6 * 50^2
3. 2번 결과 얻는다. - 50^2
4. 23을 1번의 모든 경우의 수만큼 반복

---

### 17470 배열 돌리기 5

https://www.acmicpc.net/problem/17470

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(R)$ (R <= 2000000)

어떻게 접근했는지, 풀었는지 설명:

주어진 회전 명령 개수대로 배열을 돌리면  
시간복잡도: $O(N^2*R)$ - 시간 초과  
명령을 최적화하는 작업이 필요하다.

6개의 명령이 있는데, 각 명령들의 특징은  
`한 부분 배열이 다른 부분 배열에 영향을 주지 않는다`  
(부분 배열의 위치 & 반전/회전 정보만 바꾸면 됨)
-> 각 부분 배열을 독립적으로 계산가능하다.  
-> 배열을 압축하여 계산할 수 있다.

부분 배열의 개수 = 2x2  
-> 2x2 배열로 R개의 연산을 진행한 후  
-> 2x2 배열의 결과를 input 배열에 적용한다.

그리고 부분 배열 내에서도, 반전 & 회전 연산을 해야 한다.  
-> 2*2 반전&회전 정보를 담은 배열도 R개의 연산 거치면 된다.
-> 이 정보대로 input 배열에 반전&회전 연산 진행

부분 배열의 위치에 대한 정보 (1)  
부분 배열 내에서 반전&회전 정보 (2)  
-> 두개의 2*2 배열이 필요하다.

> 이 문제는 5,6번 명령이 N/2 * M/2 인 4개의 부분 배열로 나누기 때문에  
> 부분 배열 위치에 대한 정보에 대한 배열의 크기가 2*2 인 것  
> (만약 부분 배열의 개수가 많아진다면, 위치 정보에 대한 배열의 크기도 커져야 한다)
> 
> (부분 배열 개수가 많아져도, 반전&회전 정보를 담기 위한 배열의 크기는 2*2로도 충분할 듯)

문제 푸는 순서
1. R개의 명령을 2*2 배열 (1), (2)에 적용한다.  
   1번 - 1,2 배열 상하반전  
   2번 - 1,2 배열 좌우반전  
   3번 - 1,2 배열 시계방향 90도 회전  
   4번 - 1,2 배열 반시계방향 90도 회전  
   5번 - 1번 배열만 시계방향 90도 회전  
   (부분 배열이 회전 하지는 않음, 위치만 옮김)  
   6번 - 1번 배열만 반시계방향 90도 회전  
   (부분 배열이 회전 하지는 않음, 위치만 옮김)
2. 1번 배열 위치대로 전체 배열의 위치를 옮김
3. 2번 배열 정보대로 전체 배열 반전&회전 적용  
    12  
    34  
    => 안 움직여도 됨  
    21  
    43  
    => 좌우반전  
    31  
    42  
    => 시계방향 90도 회전  
    ...

시간복잡도: $O(N^2+R)$ = O(R)

> 오래걸린 이유  
> 1. 부분 배열의 위치를 옮기는 건 생각해냈지만,  
>   부분 배열 내의 반전&회전을 어떻게 적용할지 시도를 못했다.  
>   -> 구글링으로 반전&회전 정보에 대한 2x2 배열 적용 방법 확인
> > 나는 그냥 수학적으로만 접근했음, but (3,1 명령 != 1,3 명령) 이라서 수학적으로 접근 불가능
> 2. 행과 열의 크기가 달라서 회전할 때 부분 배열 인덱싱 작업이 헷갈렸다.  
>    -> 회전하면 r과 c가 바뀌기 때문에 input R,C도 바꾸면 된다.  
>    (단순하게 생각해)

> 이 문제를 통해 얻은 것
> 
> 반전 & 회전 연산을 그대로 전체 배열에 진행하지 않고,  
> 2*2 배열에 진행 한 후, 전체 배열에 적용하면 최적화될 듯

---

### 17472 다리 만들기 2

https://www.acmicpc.net/problem/17472

사용한 자료구조 & 알고리즘: bfs, mst

시간복잡도: $O()$

어떻게 접근했는지, 풀었는지 설명:

1 - 각 섬을 숫자로 구분 & 보드에 표시 - bfs  

2 - 각 섬으로부터 다른 섬까지의 모든 최단거리를 구한다. - bfs, 그냥 구현  
2-1 거리가 1이라면 break  
2-2 저장된 거리가 0이라면 업데이트  
2-3 0이 아니고 이전 값보다 현재 값이 작다면 업데이트

3 - 모든 섬을 포함하는 최단거리를 구한다 - mst(프림)  
(모든 섬이 포함되었는지 체크)

> 여기서 놓친 부분
> 
> 2-3 조건을 코드로 구현하는 걸 깜빡했다
> 
> 3번을 풀때 mst를 생각못했다.  
> (그리고 mst를 오랜만에 풀어서 잊었음)

---

### 17609 회문
> 문자열이 주어졌을때 그 문자열이 회문인지, 유사 회문인지, 일반 문자열인지 구하는 문제
> (회문 = 대칭인 문자열, 유사 회문 = 문자 한개 뺐을때 대칭인 문자열)

투포인터를 이용한 문자열 문제

문자열의 양쪽끝에 포인터를 둔 후, 해당 위치의 문자가 같다면 한칸씩 중간으로 옮긴다.

모든 위치의 문자를 통과하면 회문

해당 위치의 문자가 다르다면 세가지 경우의 수가 있음
1. 왼쪽 포인터의 위치를 +1 해주고 다시 진행, 전부 통과하면 유사 회문
2. 오른쪽 포인터의 위치를 -1 해주고 다시 진행, 전부 통과하면 유사 회문
3. 1,2 둘다 실패하면 일반 문자열

---

### 17779 게리멘더링2

https://www.acmicpc.net/problem/17779

사용한 알고리즘: 구현

시간복잡도: $O(n^6)$  
n <= 20 이라 가능

x y, d1, d2를 세팅하고, 각 구역의 인구 수를 구한다.

구현 과정이 문제에 그대로 써있었다.  
그런데 이를 바로 보지 않고, 내가 나름대로 풀려고 했다. <- 시간 지체 됨

> 문제에 써 있는 과정을 자세히 보고, 이를 활용할 수 있다면 그대로 활용할 수 있어야 한다.  
> 항상 디버깅 제대로 하자

---

### 17780 새로운 게임

https://www.acmicpc.net/problem/17780

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(k^2 * 1000)$

어떻게 접근했는지, 풀었는지 설명:

그냥 문제에 나온 설명대로 구현하면 된다.

여기서 문제는  
말은 같은 칸에 겹칠 수 있고,  
겹칠때는 순서가 있다는 것이다.  
(그리고 빨간색으로 움직이면 순서를 뒤집어야 함)

이를 처리하기 위해,  
보드의 각 칸을 벡터로 선언해 일일이 push/pop 해줬다.

그리고 빨간색과 흰색으로 움직일때의 차이점은,  
현재 말들의 순서를 뒤집냐 안뒤집냐이기 때문에,  
이 부분만 if문으로 처리해주고, 다른 부분은 같이 처리할 수 있다.

그리고 말의 상태를 표현하는 자료구조가,  
2차원 배열과 벡터 두가지이기 때문에,  
두가지 모두 상태를 변경해줘야 한다.

> 만약 말이 움직이려고 하는 칸이 파란색일때, 반대로 움직여야 하는데,  
> 이떄 반대로 움직이는 경우를 모두 코드로 구현했다면 시간이 매우 오래 걸렸을 것이다.
> 
> 나는 반대 칸이, 칸을 벗어나거나 파란색일때는 그대로 종료하고,  
> 흰색/빨간색 이라면 말을 움직이는 메서드를 한번더 호출해주는 것으로 처리했다.  
> (이렇게 함으로써, 코드가 많이 줄었다)
> 
> 진짜 기능의 분리가 중요한 것같다.

> 약간 헷갈린 점
> 
> 나는 말하나를 처리할 때,  
> 새로운 변수에 call by value로 입력 했기 때문에,
> 
> 컨테이너에 있는 말의 상태를 변경해도,  
> 새로운 변수에는 입력되지 않았다.
> 
> call by value, call by reference를 항상 생각하자

---

### 19237 어른 상어

https://www.acmicpc.net/problem/19237

사용한 알고리즘: 구현

시간복잡도: $O(1000 * n^2)$

과정
1. 상어 이동방향 찾음 & 이동
2. 상어 자리에 냄새 뿌리고, 기존 냄새들 -1

사용한 방법

1. 상어에 대한 표현을 두가지로 해줬다.  
2-1. 2차원 배열에서 위치  
2-2. 벡터로 상태 표현

2. 앞번호 상어를 먼저 움직여 주면, 뒷 상어부터는 겹치는 걸 체크해 주지 않아도 된다. -> 어차피 겹치면 앞 번호가 사니까

> 어떤 객체를 두가지 상태로 표현한다면,  
> 상태가 변경될 때 양쪽다 변경될 수 있도록 주의해야 한다.  
>
> 항상 이동할 때 기존것 지워주고, 이동한 지점에 표시를 해줘야 한다.
>
> 항상 시작하는 시점과 끝나는 시점을 주의하자

---

### 19238 스타트택시 (삼성 기출)

https://www.acmicpc.net/problem/19238

> nxn 보드 위에 1개의 택시와 m명의 손님이 있다.<br>
각각의 손님은 목적지를 가지고 있다.<br>
택시는 모든 손님을 해당 위치에 태워서 목적지까지 옮겨야한다.<br>
(모든 손님의 위치와 목적지는 겹치지 않는다 & 택시는 한명만 태울 수 있다)<br>
이동하다가 연료가 부족해지면 -1을 출력하고 종료<br>
연료는 손님 태울때 & 목적지 이동할때 소모됨 & 목적지 도착하면 출발지부터 목적지까지의 거리의 두배를 연료료 채운다.<br>
>
> 손님 태울때 우선순위는 거리작은것,행작은것,열작은것 이다.

사용한 알고리즘: 쌩 구현, bfs

시간복잡도: $O(m*n^2)$

총 3단계로 구분했다.
0. 각 손님들이 목적지까지 가는데 걸리는 거리를 계산한다. & 각 배열에 저장
1. 택시가 현재 위치에서 가장 가까이 있는 손님을 찾는다. & 그 위치로 택시 이동
2. 해당 손님의 출발지에서 목적지까지 이동

12 과정을 반복하는데 중간에 연료가 부족해지면 바로 -1을 출력하고 종료했다.

0의 시간복잡도 - $O(m*n^2)$ - 손님은 m명, 손님마다 bfs로 거리를 계산했음<br>
1의 시간복잡도 - $O(n^2)$ - 한명찾을때 bfs 이용<br>
2의 시간복잡도 - O(1) - 이미 출발지와 목적지의 거리를 계산해놓았기 때문에 상수시간

    여기서 놓친 반례가 한개 있었다.

    손님의 출발지와 목적지가 벽때문에 연결되어있지 않을때를 처리하지 못했다.
>
    이 문제에서 생길 수 있는 반례

    1. 택시의 시작지점에 손님이 있을 수 있다.
    2. 택시가 손님을 찾는 과정에서 우선순위를 놓칠 수 있다.(최단거리, 행이 작게, 열이 작게)
        여기서 단순히 dr[4],dc[4]의 순서를 정한다고 우선순위가 해결되지 않는다.(왼왼왼 보다 오오위가 우선순위)
        -> 그냥 모든 배열에 접근해서 거리,행,열을 체크해야 한다.
    
    3. 택시가 손님에게 갔다가 목적지를 가는 과정에서 연료가 떨어질 수 있다.
        손님에게 갈때 & 출발지에서 목적지로 갈때 - 두가지 전부 체크해야 한다.
    4. for문에서 bfs를 사용할때 queue와 visited 초기화를 제대로 안 했을 수 있다.
>
    항상 반례를 생각하자

---

### 19539 사과나무

https://www.acmicpc.net/problem/19539

사용한 자료구조 & 알고리즘: 그리디

시간복잡도: $O(n)$

어떻게 접근했는지, 풀었는지 설명:

yes or no를 구분하는 기준

1 - 전체 크기의 합이 3으로 나눠 떨어지지 않으면 NO

여기서 3으로 나눴을 때의 몫은, 물뿌리개를 뿌리는 일 수이다.

(ex - 3 5 1 -> 3일동안 뿌려야 가능 = 9 / 3)

-> 2짜리 물뿌리개를 뿌리는 횟수도 일 수와 동일해야 한다.

-> 2를 뿌릴 수 있는 전체 횟수가 일 수보다 크거나 같으면 YES, 아니면 NO

2를 뿌릴 수 있는 전체 횟수가 일 수보다 커도 되는 이유
-> 2 = 1 + 1 -> 2를 한 번 안뿌리고 1을 두번 뿌린다고 생각하면 됨  
-> 2를 뿌리는 전체횟수와 일 수가 같아짐

> 코드로 구현하는 것은 문제가 없지만,  
> 위 아이디어를 생각하는게 힘들었다.



---

### 20055 컨베이어 벨트

https://www.acmicpc.net/problem/20055

> 2n 길이의 컨베이어 벨트가 있다.(0~2n-1)<br>
벨트가 한칸움직이면 그 위의 로봇도 같이 움직이는데, n-1번 위치의 로봇은 다음칸으로 움직이지 않고 벨트에서 내린다.
>
> 1. 모든 벨트가 한칸씩 움직인다.
> 2. 벨트위의 모든 로봇이 다음 칸으로 움직인다.
>   다음 칸으로 움직인다면, 해당 칸의 내구도는 1 감소한다. (내구도가 0이라면 다음칸으로 못감)
> 3. 0번 위치에 새로운 로봇을 올린다.(0번 위치의 내구도가 1 이상이고, 로봇이 그 위치에 없을 때)
> 4. 내구도가 0인 벨트가 k개 이상이 될때까지 123번 과정을 진행한다.
>
> 위 과정이 종료되었을때, 몇번째 단계가 진행중이었을까?

사용한 알고리즘: 구현

시간복잡도: $O()$

벨트가 한칸씩 움직이는걸 표현하기 위해, 자료구조로 deque를 사용했다.

    한칸움직이는걸 pop_back()과 push_front()로 구현, 
    모든 데이터 접근을 위해 queue가 아닌 deque 사용

로봇들의 위치도 자료구조로 표현해야 하는데, 이를 역시 deque를 사용했다.

    로봇들은 선입선출이라 queue도 가능할 것같지만, (1번과정을 진행할때) 모든 로봇의 값을 +1 해줘야 하기때문에,
    인덱스 접근이 가능한 deque를 사용했다.

(위의 두 데이터 모두 선입선출이지만, queue는 인덱스 접근을 못하기 때문에, deque를 이용했다)

그냥 쌩 구현이지만, 중간중간 놓진 부분이 있어, 예상보다 시간이 조금 더 걸렸다.

2번 과정에서 n-1번 칸의 로봇은 다음칸으로 가지 못하고, 내려야 한다. - 처음에 이 과정을 if문으로 처리해주지 못했다.

그리고 로봇을 내리고 나서, 다음 로봇들의 위치를 +1 해줘야 하는데,<br>
로봇을 내렸다 해도, 해당 로봇은 제거되었기 때문에 다음 로봇들의 위치는 인덱스 0부터 시작하는걸 깜빡했다.

3번에서 0번에 올릴때도, 0번 위치에 로봇이 있는지 체크해줘야 하는걸 깜빡했다.

    deque의 모든 데이터를 순차탐색할때, 0번 데이터를 제거했다면, 다음 데이터의 위치는 0번이 된다.
    이를 조심하자

---

### 20056 마법사 상어와 파이어볼(삼성기출)

https://www.acmicpc.net/problem/20056

> 생략

사용한 알고리즘: 구현&시물레이션

시간복잡도: $O()$

그냥 문제를 제대로 읽고 잘 설계해서 구현하는 문제

여기서 놓친 부분이 있었음
1. 속력이 n보다 클때, 다음 위치가 -n보다 작을수도 있었다. -> +n으로는 해결이 안됨
2. 그렇다고 처음부터 속력을 %n 해주면 무조건 틀린다. -> 나중에 새로운 파이어볼을 구할때 속력을 나눠줘야 하는데, 이때 나머지가 달라짐 -> 틀림
>
    나머지 제대로 체크하자

    (A+B) % C = (A%C + B%C) % C
    (A-B) % C = (A%C - B%C) % C
    (A*B) % C = (A%C * B%C) % C

    (나누는건 안된다)

---

### 20061 모노미노도미노 2

https://www.acmicpc.net/problem/20061

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O()$

어떻게 접근했는지, 풀었는지 설명:

1. 블록 옮기고
2. 한줄 채워진 행/열 있다면 점수+1 & 한칸씩 땡겨주기
3. 연두/하늘 보드에 블럭 있다면 한칸씩 땡겨주기
4. 1.2.3 블럭 개수만큼 반복
5. 점수 계산

문제 읽는게 귀찮을 뿐이지, 써놓은 대로 코드 작성하면 풀수 있는 문제

> 여기서 핵심은 각 기능별로 메서드를 구분해 처리하는게 빠르게 할 수 있는 방법

---

### 20210 파일 탐색기

https://www.acmicpc.net/problem/20210

사용한 자료구조 & 알고리즘: 문자열, 정렬

시간복잡도: $O(nlogn * l)$ (l = 문자열의 길이 <= 100)

어떻게 접근했는지, 풀었는지 설명:

정렬은 algorithm 라이브러리의 sort를 사용

결국 두 문자를 비교하는 것이 이 문제의 핵심

두 문자 비교 case
1. 한쪽이 문자, 다른쪽은 숫자 -> 문자가 더 크다.
2. 둘다 문자 -> 문자 비교
3. 둘다 숫자 -> 숫자 비교

문자 비교는 간단하니 생략

숫자 비교  

1. 0을 제외한 자릿수 체크 -> 자릿수 큰 쪽이 더 큰 것
2. (자릿수 같은 상태) 두 숫자 한개씩 비교 -> 숫자 큰 쪽이 더 큰 것
3. (모든 수가 같다) 두 숫자의 길이를 비교한다.

1번 케이스 - 0123 vs 00012 - 0123이 더 크다.

2번 케이스 - 01234 vs 01244 - 01244가 더 크다.

3번 케이스 - 00012 vs 12 - 00012가 더 크다.

> 문자를 일일이 비교하는 것이 매우 귀찮았던 문제  
> 하지만 어려움은 없었다.
> 
> 각 기능별로 메서드를 분리해줌으로써, (isChar, isInt, compareInt, compareChar)  
> 문제를 빠르게 풀 수 있었다.

---

### 20237 배열 돌리기 6

https://www.acmicpc.net/problem/20327

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(n^2 * R)$

어떻게 접근했는지, 풀었는지 설명:

기본적인 배열의 상하반전, 좌우반전, 시계/반시계 방향 90도 회전의 업그레이드 문제  
문제는 배열을 $2^n x 2^n$ 개의 부분 배열로 나눠서 배열 연산을 진행한다는 점

부분 배열 내에서 연산(1,2,3,4): 

4개의 함수가 필요  
1 - 연산을 진행 할 부분 배열의 위치를 정해주는 함수  
2-1 - 현재 부분 배열을 temp로 옮겨주는 함수  
2-2 - 파라미터로 받은 부분 배열의 위치대로 연산을 진행하는 함수  
2-3 = temp의 값을 현재 부분 배열의 위치로 옮겨주는 함수  
(현재 부분 배열은 {sr,sc}에서 시작, temp는 {0,0}에서 시작)

> 이렇게 되면 2-2 인 1,2,3,4 연산을 위한 함수만 따로 구현하고, 1, 2-1, 2-3은 재사용 가능하다

부분 배열을 하나의 한 칸으로 보고 진행하는 연산(5,6,7,8): 

한칸이라고 생각하고 for문을 작성하는데,  
```
for (int i = 0; i < len; i++) {
    for (int j = 0; j < len; j++) {
        fTOs(i * len2, j * len2, j * len2, (len - i - 1) * len2, len2); // 90도 시계방향 회전
        // {fr,fc} -> {sr,sc} len2*len2 만큼 저장
        // 진짜 한칸이었으면 temp[j][len-i-1] = input[i][j]; 라고 작성 됨
    }
}
```  
이처럼 시작위치를 전달해준다.

> 핵심은 계산해야 할 부분 배열의 위치를 구하는 기능과,  
> 연산을 진행하는 기능의 분리  
> -> 연산을 진행할 때 부분 배열의 위치를 신경 안써도 됨  
> -> 코드가 깔끔해짐 & 재사용성 올라감
> 
> (코테에서도 이렇게 해야 한다)

> 1시간 쫌 넘게 걸렸다.
> 
> 시간이 지체된 이유 - i랑 j를 헷갈렸다.  
> (2차원 배열 접근은 i,j 말고 r,c 쓰자 - 가독성 그나마 좋다)

---

### 23291 어항 정리

https://www.acmicpc.net/problem/23291

사용한 자료구조 & 알고리즘: 구현, 시뮬레이션

시간복잡도: $O()$

어떻게 접근했는지, 풀었는지 설명:

구현은 그냥 문제에 표현된대로 하면 된다.  
문제는 구현할 것들이 너무 많다는 것  
-> 그냥 기능 잘 분리해서, 각 기능별로 구현

물고기 수 조절 함수와 어항을 바닥에 일렬로 놓는 함수 두가지는 재사용 가능

> 2시간 쫌 넘게 걸렸다.
> 
> 중간에 시간 지체된 이유
> 1. for문 탈출 조건으로 temp[r][c] != 0 조건을 사용했는데,  
>    문제는 temp 변수는 여기저기서 사용하기 때문에, 위 조건문을 사용하면 안 됐다.  
>    그냥 r의 범위와 c의 범위를 직접 입력해야만 했다.
> 2. 어항 간의 물고기 수 조절 함수 구현 중에 실수가 많았다.  
>    처음에는 그냥 상 & 우 방향으로 push 하면서, 물고기 수를 조절했다. -> 같은 위치를 두번 push 함  
>    그 다음으로, visited를 이용해 이미 방문했다면, 바로 continue 했다. -> 방문했더라도 비교 연산은 해야 한다.  
>    다음 위치와 물고기 수를 조절한다음, visited를 이용(방문 안했다면 push x) -> 정답
     
> 결국 집중 잘해서 문제 계속 시도하면, 풀 수 있다.
> 
> 1. 배열 회전을 진행하면, 행 열을 교체해 줘야 한다.
> 2. 항상 배열 내의 값을 다른 위치로 옮기면, 옮기기 전의 위치 값을 0으로 세팅해줘야 한다.

---

### 23289 온풍기 안녕!(삼성기출)

https://www.acmicpc.net/problem/23289

> 너무 길어서 짧게 설명
>
> 1. 온풍기가 분다
> 2. 온도 평준화
> 3. 사이드 온도 1씩 내림
> 4. 초콜릿 먹음(101개 이상 먹으면 종료)
> 5. 지정한 칸들 온도가 K 이상이라면 종료
>
> 위 과정을 계속 반복한다. 먹은 초콜릿 개수를 출력한다.

사용한 알고리즘: 쌩 구현

시간복잡도: $O(n^4 * 100)$
    1 - n^4
    2 - n^2
    3 - n
    4,5 - 1
    => n^4

온풍기가 불때 & 온도 평준화 시킬때 벽이 있는지 없는지 체크해줘야 하는게 너무 귀찮았다.

특히 벽을 구분하는게 힘들었다. 아니 귀찮았다.

그런데 이 문제가 어려운 것은 아니다. 그냥 체크해야 할 것이 많아서 헷갈린다는 점이 문제다.

벽의 유무를 pair\<bool, bool> 2차원 배열로 관리했다. // 아래에 있는지, 오른쪽에 있는지

하지만 이를 구현할때 계속 first와 second를 헷갈려서 시간이 지연됐다.(first가 아래인지 오른쪽인지 헷갈려서 계속 선언부분 왔다갔다 했음)

> 그리고 이 문제에선 괜찮았지만, 하나 놓친 부분이 있었다.
>
> 지정한 칸이 없는 경우를 생각을 안했다.<br>
> (물론 이문제는 지정한 칸이 1개 이상이지만, 다른 문제에서는 없을 수도 있다. 항상 체크하자)

내가 규칙을 정했으면 이를 바로바로 볼 수 있는 곳에 표시를 해두는게 좋다.<br>
(코드가 길어지면 이 규칙을 바로바로 확인하기 힘들다)