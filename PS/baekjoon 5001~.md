### 5557 1학년

https://www.acmicpc.net/problem/5557

> n개의 숫자가 주어졌을때(n <= 100), +와 0을 이용해 마지막 숫자를 제외하고 식을 만드는데, 이 식이 마지막 숫자와 같은 경우의 수를 구하는 문제(계산 값(중간에 나오는 수 모두)은 0에서 20사이)

사용한 알고리즘: DP

시간복잡도: $O(n)$

DP의 시작은 완전탐색

맨처음부터 +를 적용할떄와 -를 적용할때를 다 구하면 풀수 있음. 이 접근의 시간복잡도는 $O(2^n)$

이때 중간에 나오는 수는 모두 0에서 20사이기 때문에, 20*100 크기의 cache를 선언해서 저장해주면 dp로 가능하다.

    cache[i][j]의 의미 = j번쨰 숫자에서, 식의 결과가 i일때의 답이 나올 수 있는 모든 경우의 수

    find(int cur, int n) = n번째 숫자에서, 결과가 cur일때, 답이 나올 수 있는 모든 경우의 수를 반환

DP를 썼을 때 시간복잡도: $O(n)$

> 수의 범위가 0에서 20사이라서 DP로 가능했던 문제

---

### 5582 공통 부분 문자열
> 문자열 두개가 주어졌을때 두 문자열의 공통 부분 문자열을 구하는 문제(연속된 부분 문자열) 

dp를 이용한 문자열 문제

if(str1[i] == str2[j]) dp[i][j] = dp[i-1][j-1] + 1

---

### 9251 LCS(최장 공통 부분 수열)


💡 두 수열이 주어졌을때 모두의 부분 수열중 가장 긴것을 찾는 문제


시간복잡도: $O(n^2)$

이중포문을 이용 행은 첫번째 수열, 열은 두번째 수열

수열의 원소한개씩 비교하는데,

두 원소가 같다면, $dp[i][j]=dp[i-1][j-1]+1$

다르다면, $dp[i][j]=max(dp[i-1][j],dp[i][j-1])$

그리고 dp의 마지막 원소가 정답이다.

풀이

dp[i][j]는 현재 위치에서 LCS의 길이이다. - 최대길이

현재위치(i,j)에서 두 수열의 원소가 같다면,

$A_{i-1}$와 $B_{j-1}$의 최대길이(dp[i-1][j-1]) + 1이  현재위치의 최대길이(dp[i][j])이다.

현재위치에서 두 수열의 원소가 다르다면,

이전 위치에서의 최대길이 $max(dp[i-1][j],dp[i][j-1])$가 현재 위치의 최대길이이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 11054 가장 긴 바이토닉 부분 수열(요약 LBS)


💡 수열이 주어졌을때, $S_1<S_2<...<S_k>S_{k+1}>...>S_n$을 만족하는 부분수열의 최대길이를 구하는 문제



시간복잡도: $O(n^2)$

가장 긴 증가하는 부분 수열의 응용버전

(Longest Increasing Subsequence)

LIS를 두번 구하면 끝남

0을 기준으로 n-1까지 LIS를 구함 - dp1

그리고 n-1을 기준으로 0까지 LIS를 구함 - dp2

(0을 기준으로 하면 LDS이다)

dp1[i]+dp2[i]-1의 최댓값이 정답이다.

풀이

dp1[i]는 0부터 i까지의 원소중에 LIS

dp2[i]는 n-1부터 i까지의 원소중의 LIS

따라서 dp1[i]+dp2[i]-1은 현재 원소가 가장 큰 원소일때의 LBS를 만족하는 최대 길이이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 11060 점프 점프

https://www.acmicpc.net/problem/11060

> 1xn 크기의 배열이 있을때 0번 위치에서 출발해서 오른쪽 끝에 도달하는 최솟값을 구한다. 점프는 보드에 있는 숫자 내만큼 점프가능하다.
(3번위치에서 3이라면 4,5,6 점프 가능)

사용한 알고리즘: DP

시간복잡도: $O(n^2)$

완전 탐색으로 시작하는데,

현재 위치에서 최소해를 구했다면 이 값을 cache에 저장해놓는다.

다음에는 굳이 같은 위치에서 최소해를 구할필요 없음

    문제 자체는 쉬운 문제였다. 그냥 DP 연습을 위해 풀었음

    최적화 문제를 동적 계획법으로 풀때는
    1. 완전 탐색으로 풀고
    2. 전체 답을 구하지 말고 현재 위치에서 최소해를 구하는 메서드로 변환
    3. 메모이제이션 이용

    위 방법을 생각하면서 풀자

---

### 16194 카드 구매하기2

https://www.acmicpc.net/problem/16194

> n개의 카드팩의 가격이 주어진다. i(1~n)번째 카드팩에는 i개의 카드가 들어있다. 이때 n개의 카드를 구매하기위한 최솟값을 구하는 프로그램을 작성하라(딱 n개, n개 넘으면 안됨)

사용한 알고리즘: DP

시간복잡도: $O(n^2)$

이 문제도 위문제처럼, 완전 탐색으로 시작했다.

find(x)라는 재귀함수를 생성

find(x) = x개의 카드를 구매하기 위한 최솟값을 반환하는 함수

이때 점화식: $find(x) = min^x_{L=1}(card[L] + find(x-L))$

이때 함수를 그냥 실행하면 시간복잡도가 $O(n!)$인데 (그냥 대충 계산했을때)

이때 각 위치의 값을 저장해놓으면(메모이제이션)

시간복잡도가 $O(n^2)$으로 감소한다.

---

### 16637 괄호 추가하기

https://www.acmicpc.net/problem/16637

> n개의 문자로 이루어진 수식이 주어졌을때, 괄호를 추가하여 얻을 수 있는 최댓값을 구하시오<br>
(연산자 우선순위는 없다 - 그냥 왼쪽에서 오른쪽으로 계산)<br>
(괄호 안에 연산자는 1개만, 괄호 중첩은 불가능)

사용한 알고리즘: 브루트포스(그냥 쌩 구현)

시간복잡도: $O()$

처음에는 DP처럼 접근했다.<br>
앞의 식이 뒤의 식에 영향을 안끼친다고 생각해서

그런데 이 접근은 틀렸다.

뒤를 먼저 계산하는건 전체에 괄호를 추가하는 것과 같다 - 이는 잘못된 접근

그냥 무식하게 풀어야 한다.

dfs 방식으로 괄호 넣었다 뺐다 하면서 모든 경우의 수를 체크했다.

인풋 범위가 작아서 가능한 알고리즘

---

### 17142 연구소 3

https://www.acmicpc.net/problem/17142

> nxn 보드에 비활성화된 바이러스가 있다<br>
여기서 m개를 활성화시켜서 벽을 제외한 모든 빈칸을 바이러스로 채우려고 한다.<br>
바이러스가 1칸 퍼지는데 1초걸릴때, 모든 빈칸이 바이러스로 덮이는 최소시간은?<br>
(비활성화 바이러스가 활성화 바이러스를 만나면 활성화 바이러스로 바뀐다)<br>
(m <= 10)

사용한 알고리즘: bfs & 구현

시간복잡도: $O(_{10}C_5*n^2)$

1. 전체 바이러스가 k개라면(k>=m), 여기서 m개를 골라야 한다. - 최대 $_{10}C_5$
2. bfs를 이용해 바이러스가 퍼지는 시간을 구한다 - $n^2$

처음 제출했을 때는, 시간초과가 났다. <br>
그 이유는 2번을 구현할 때, 매 round마다 바이러스가 모두 퍼졌는지 확인을 해야하는데, 처음에는 이 작업을 모든 칸을 확인했다.(빈칸이 있는지)<br>
그리고 벽때문에 바이러스가 퍼질수 없는지도 확인해야 해서 같이 검사했다.<br>
(이는 이전 보드와 현재 보드 값을 비교했다 - 같은지 다른지)
여기서 시간복잡도가 너무 높게 나왔다.<br>

그래서 모든 칸을 검사하지 않고, 처음 빈칸의 개수를 세주고, 매 round마다 빈칸의 개수가 0이면 바로 탈출하도록 세팅했다.<br>
그리고 한번이라도 바이러스가 퍼졌다면 false로 초기화된 flag에 true를 줬다.

>flag=true // 바이러스가 최소한칸은 퍼졌다. -> 아직 더 퍼질수 있음<br>
flag=false // 한칸도 퍼지지 않았다. -> 더이상 퍼질수 없다.
>   
>빈칸의 개수 > 0 && flag==false<br>
>=> 모든 빈 칸에 바이러스를 퍼뜨릴 수 없다.

bfs 구현은 많이 해봐서 무난했지만, 1번을 구현하는 것이 어색했다. - 시간 많이 잡아먹음

그리고 1번을 수행할때마다, 2번에 필요한 변수들을 초기화해주는것이 많이 헷갈렸다.

문제를 자주 풀어야 익숙해진다.

---

### 17609 회문
> 문자열이 주어졌을때 그 문자열이 회문인지, 유사 회문인지, 일반 문자열인지 구하는 문제
> (회문 = 대칭인 문자열, 유사 회문 = 문자 한개 뺐을때 대칭인 문자열)

투포인터를 이용한 문자열 문제

문자열의 양쪽끝에 포인터를 둔 후, 해당 위치의 문자가 같다면 한칸씩 중간으로 옮긴다.

모든 위치의 문자를 통과하면 회문

해당 위치의 문자가 다르다면 세가지 경우의 수가 있음
1. 왼쪽 포인터의 위치를 +1 해주고 다시 진행, 전부 통과하면 유사 회문
2. 오른쪽 포인터의 위치를 -1 해주고 다시 진행, 전부 통과하면 유사 회문
3. 1,2 둘다 실패하면 일반 문자열

---

### 20056 마법사 상어와 파이어볼(삼성기출)

https://www.acmicpc.net/problem/20056

> 생략

사용한 알고리즘: 구현&시물레이션

시간복잡도: $O()$

그냥 문제를 제대로 읽고 잘 설계해서 구현하는 문제

여기서 놓친 부분이 있었음
1. 속력이 n보다 클때, 다음 위치가 -n보다 작을수도 있었다. -> +n으로는 해결이 안됨
2. 그렇다고 처음부터 속력을 %n 해주면 무조건 틀린다. -> 나중에 새로운 파이어볼을 구할때 속력을 나눠줘야 하는데, 이때 나머지가 달라짐 -> 틀림