### 5557 1학년

https://www.acmicpc.net/problem/5557

> n개의 숫자가 주어졌을때(n <= 100), +와 0을 이용해 마지막 숫자를 제외하고 식을 만드는데, 이 식이 마지막 숫자와 같은 경우의 수를 구하는 문제(계산 값(중간에 나오는 수 모두)은 0에서 20사이)

사용한 알고리즘: DP

시간복잡도: $O(n)$

DP의 시작은 완전탐색

맨처음부터 +를 적용할떄와 -를 적용할때를 다 구하면 풀수 있음. 이 접근의 시간복잡도는 $O(2^n)$

이때 중간에 나오는 수는 모두 0에서 20사이기 때문에, 20*100 크기의 cache를 선언해서 저장해주면 dp로 가능하다.

    cache[i][j]의 의미 = j번쨰 숫자에서, 식의 결과가 i일때의 답이 나올 수 있는 모든 경우의 수

    find(int cur, int n) = n번째 숫자에서, 결과가 cur일때, 답이 나올 수 있는 모든 경우의 수를 반환

DP를 썼을 때 시간복잡도: $O(n)$

> 수의 범위가 0에서 20사이라서 DP로 가능했던 문제

---

### 5582 공통 부분 문자열
> 문자열 두개가 주어졌을때 두 문자열의 공통 부분 문자열을 구하는 문제(연속된 부분 문자열) 

dp를 이용한 문자열 문제

if(str1[i] == str2[j]) dp[i][j] = dp[i-1][j-1] + 1

---

### 9251 LCS(최장 공통 부분 수열)


💡 두 수열이 주어졌을때 모두의 부분 수열중 가장 긴것을 찾는 문제


시간복잡도: $O(n^2)$

이중포문을 이용 행은 첫번째 수열, 열은 두번째 수열

수열의 원소한개씩 비교하는데,

두 원소가 같다면, $dp[i][j]=dp[i-1][j-1]+1$

다르다면, $dp[i][j]=max(dp[i-1][j],dp[i][j-1])$

그리고 dp의 마지막 원소가 정답이다.

풀이

dp[i][j]는 현재 위치에서 LCS의 길이이다. - 최대길이

현재위치(i,j)에서 두 수열의 원소가 같다면,

$A_{i-1}$와 $B_{j-1}$의 최대길이(dp[i-1][j-1]) + 1이  현재위치의 최대길이(dp[i][j])이다.

현재위치에서 두 수열의 원소가 다르다면,

이전 위치에서의 최대길이 $max(dp[i-1][j],dp[i][j-1])$가 현재 위치의 최대길이이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 11054 가장 긴 바이토닉 부분 수열(요약 LBS)


💡 수열이 주어졌을때, $S_1<S_2<...<S_k>S_{k+1}>...>S_n$을 만족하는 부분수열의 최대길이를 구하는 문제



시간복잡도: $O(n^2)$

가장 긴 증가하는 부분 수열의 응용버전

(Longest Increasing Subsequence)

LIS를 두번 구하면 끝남

0을 기준으로 n-1까지 LIS를 구함 - dp1

그리고 n-1을 기준으로 0까지 LIS를 구함 - dp2

(0을 기준으로 하면 LDS이다)

dp1[i]+dp2[i]-1의 최댓값이 정답이다.

풀이

dp1[i]는 0부터 i까지의 원소중에 LIS

dp2[i]는 n-1부터 i까지의 원소중의 LIS

따라서 dp1[i]+dp2[i]-1은 현재 원소가 가장 큰 원소일때의 LBS를 만족하는 최대 길이이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 11060 점프 점프

https://www.acmicpc.net/problem/11060

> 1xn 크기의 배열이 있을때 0번 위치에서 출발해서 오른쪽 끝에 도달하는 최솟값을 구한다. 점프는 보드에 있는 숫자 내만큼 점프가능하다.
(3번위치에서 3이라면 4,5,6 점프 가능)

사용한 알고리즘: DP

시간복잡도: $O(n^2)$

완전 탐색으로 시작하는데,

현재 위치에서 최소해를 구했다면 이 값을 cache에 저장해놓는다.

다음에는 굳이 같은 위치에서 최소해를 구할필요 없음

    문제 자체는 쉬운 문제였다. 그냥 DP 연습을 위해 풀었음

    최적화 문제를 동적 계획법으로 풀때는
    1. 완전 탐색으로 풀고
    2. 전체 답을 구하지 말고 현재 위치에서 최소해를 구하는 메서드로 변환
    3. 메모이제이션 이용

    위 방법을 생각하면서 풀자

---

### 16194 카드 구매하기2

https://www.acmicpc.net/problem/16194

> n개의 카드팩의 가격이 주어진다. i(1~n)번째 카드팩에는 i개의 카드가 들어있다. 이때 n개의 카드를 구매하기위한 최솟값을 구하는 프로그램을 작성하라(딱 n개, n개 넘으면 안됨)

사용한 알고리즘: DP

시간복잡도: $O(n^2)$

이 문제도 위문제처럼, 완전 탐색으로 시작했다.

find(x)라는 재귀함수를 생성

find(x) = x개의 카드를 구매하기 위한 최솟값을 반환하는 함수

이때 점화식: $find(x) = min^x_{L=1}(card[L] + find(x-L))$

이때 함수를 그냥 실행하면 시간복잡도가 $O(n!)$인데 (그냥 대충 계산했을때)

이때 각 위치의 값을 저장해놓으면(메모이제이션)

시간복잡도가 $O(n^2)$으로 감소한다.

---

### 16637 괄호 추가하기

https://www.acmicpc.net/problem/16637

> n개의 문자로 이루어진 수식이 주어졌을때, 괄호를 추가하여 얻을 수 있는 최댓값을 구하시오<br>
(연산자 우선순위는 없다 - 그냥 왼쪽에서 오른쪽으로 계산)<br>
(괄호 안에 연산자는 1개만, 괄호 중첩은 불가능)

사용한 알고리즘: 브루트포스(그냥 쌩 구현)

시간복잡도: $O()$

처음에는 DP처럼 접근했다.<br>
앞의 식이 뒤의 식에 영향을 안끼친다고 생각해서

그런데 이 접근은 틀렸다.

뒤를 먼저 계산하는건 전체에 괄호를 추가하는 것과 같다 - 이는 잘못된 접근

그냥 무식하게 풀어야 한다.

dfs 방식으로 괄호 넣었다 뺐다 하면서 모든 경우의 수를 체크했다.

인풋 범위가 작아서 가능한 알고리즘

---

### 17142 연구소 3

https://www.acmicpc.net/problem/17142

> nxn 보드에 비활성화된 바이러스가 있다<br>
여기서 m개를 활성화시켜서 벽을 제외한 모든 빈칸을 바이러스로 채우려고 한다.<br>
바이러스가 1칸 퍼지는데 1초걸릴때, 모든 빈칸이 바이러스로 덮이는 최소시간은?<br>
(비활성화 바이러스가 활성화 바이러스를 만나면 활성화 바이러스로 바뀐다)<br>
(m <= 10)

사용한 알고리즘: bfs & 구현

시간복잡도: $O(_{10}C_5*n^2)$

1. 전체 바이러스가 k개라면(k>=m), 여기서 m개를 골라야 한다. - 최대 $_{10}C_5$
2. bfs를 이용해 바이러스가 퍼지는 시간을 구한다 - $n^2$

처음 제출했을 때는, 시간초과가 났다. <br>
그 이유는 2번을 구현할 때, 매 round마다 바이러스가 모두 퍼졌는지 확인을 해야하는데, 처음에는 이 작업을 모든 칸을 확인했다.(빈칸이 있는지)<br>
그리고 벽때문에 바이러스가 퍼질수 없는지도 확인해야 해서 같이 검사했다.<br>
(이는 이전 보드와 현재 보드 값을 비교했다 - 같은지 다른지)
여기서 시간복잡도가 너무 높게 나왔다.<br>

그래서 모든 칸을 검사하지 않고, 처음 빈칸의 개수를 세주고, 매 round마다 빈칸의 개수가 0이면 바로 탈출하도록 세팅했다.<br>
그리고 한번이라도 바이러스가 퍼졌다면 false로 초기화된 flag에 true를 줬다.

>flag=true // 바이러스가 최소한칸은 퍼졌다. -> 아직 더 퍼질수 있음<br>
flag=false // 한칸도 퍼지지 않았다. -> 더이상 퍼질수 없다.
>   
>빈칸의 개수 > 0 && flag==false<br>
>=> 모든 빈 칸에 바이러스를 퍼뜨릴 수 없다.

bfs 구현은 많이 해봐서 무난했지만, 1번을 구현하는 것이 어색했다. - 시간 많이 잡아먹음

그리고 1번을 수행할때마다, 2번에 필요한 변수들을 초기화해주는것이 많이 헷갈렸다.

문제를 자주 풀어야 익숙해진다.

---

### 17609 회문
> 문자열이 주어졌을때 그 문자열이 회문인지, 유사 회문인지, 일반 문자열인지 구하는 문제
> (회문 = 대칭인 문자열, 유사 회문 = 문자 한개 뺐을때 대칭인 문자열)

투포인터를 이용한 문자열 문제

문자열의 양쪽끝에 포인터를 둔 후, 해당 위치의 문자가 같다면 한칸씩 중간으로 옮긴다.

모든 위치의 문자를 통과하면 회문

해당 위치의 문자가 다르다면 세가지 경우의 수가 있음
1. 왼쪽 포인터의 위치를 +1 해주고 다시 진행, 전부 통과하면 유사 회문
2. 오른쪽 포인터의 위치를 -1 해주고 다시 진행, 전부 통과하면 유사 회문
3. 1,2 둘다 실패하면 일반 문자열

---

### 19238 스타트택시 (삼성 기출)

https://www.acmicpc.net/problem/19238

> nxn 보드 위에 1개의 택시와 m명의 손님이 있다.<br>
각각의 손님은 목적지를 가지고 있다.<br>
택시는 모든 손님을 해당 위치에 태워서 목적지까지 옮겨야한다.<br>
(모든 손님의 위치와 목적지는 겹치지 않는다 & 택시는 한명만 태울 수 있다)<br>
이동하다가 연료가 부족해지면 -1을 출력하고 종료<br>
연료는 손님 태울때 & 목적지 이동할때 소모됨 & 목적지 도착하면 출발지부터 목적지까지의 거리의 두배를 연료료 채운다.<br>
>
> 손님 태울때 우선순위는 거리작은것,행작은것,열작은것 이다.

사용한 알고리즘: 쌩 구현, bfs

시간복잡도: $O(m*n^2)$

총 3단계로 구분했다.
0. 각 손님들이 목적지까지 가는데 걸리는 거리를 계산한다. & 각 배열에 저장
1. 택시가 현재 위치에서 가장 가까이 있는 손님을 찾는다. & 그 위치로 택시 이동
2. 해당 손님의 출발지에서 목적지까지 이동

12 과정을 반복하는데 중간에 연료가 부족해지면 바로 -1을 출력하고 종료했다.

0의 시간복잡도 - $O(m*n^2)$ - 손님은 m명, 손님마다 bfs로 거리를 계산했음<br>
1의 시간복잡도 - $O(n^2)$ - 한명찾을때 bfs 이용<br>
2의 시간복잡도 - O(1) - 이미 출발지와 목적지의 거리를 계산해놓았기 때문에 상수시간

    여기서 놓친 반례가 한개 있었다.

    손님의 출발지와 목적지가 벽때문에 연결되어있지 않을때를 처리하지 못했다.
>
    이 문제에서 생길 수 있는 반례

    1. 택시의 시작지점에 손님이 있을 수 있다.
    2. 택시가 손님을 찾는 과정에서 우선순위를 놓칠 수 있다.(최단거리, 행이 작게, 열이 작게)
        여기서 단순히 dr[4],dc[4]의 순서를 정한다고 우선순위가 해결되지 않는다.(왼왼왼 보다 오오위가 우선순위)
        -> 그냥 모든 배열에 접근해서 거리,행,열을 체크해야 한다.
    
    3. 택시가 손님에게 갔다가 목적지를 가는 과정에서 연료가 떨어질 수 있다.
        손님에게 갈때 & 출발지에서 목적지로 갈때 - 두가지 전부 체크해야 한다.
    4. for문에서 bfs를 사용할때 queue와 visited 초기화를 제대로 안 했을 수 있다.
>
    항상 반례를 생각하자

---

### 20055 컨베이어 벨트

https://www.acmicpc.net/problem/20055

> 2n 길이의 컨베이어 벨트가 있다.(0~2n-1)<br>
벨트가 한칸움직이면 그 위의 로봇도 같이 움직이는데, n-1번 위치의 로봇은 다음칸으로 움직이지 않고 벨트에서 내린다.
>
> 1. 모든 벨트가 한칸씩 움직인다.
> 2. 벨트위의 모든 로봇이 다음 칸으로 움직인다.
>   다음 칸으로 움직인다면, 해당 칸의 내구도는 1 감소한다. (내구도가 0이라면 다음칸으로 못감)
> 3. 0번 위치에 새로운 로봇을 올린다.(0번 위치의 내구도가 1 이상이고, 로봇이 그 위치에 없을 때)
> 4. 내구도가 0인 벨트가 k개 이상이 될때까지 123번 과정을 진행한다.
>
> 위 과정이 종료되었을때, 몇번째 단계가 진행중이었을까?

사용한 알고리즘: 구현

시간복잡도: $O()$

벨트가 한칸씩 움직이는걸 표현하기 위해, 자료구조로 deque를 사용했다.

    한칸움직이는걸 pop_back()과 push_front()로 구현, 
    모든 데이터 접근을 위해 queue가 아닌 deque 사용

로봇들의 위치도 자료구조로 표현해야 하는데, 이를 역시 deque를 사용했다.

    로봇들은 선입선출이라 queue도 가능할 것같지만, (1번과정을 진행할때) 모든 로봇의 값을 +1 해줘야 하기때문에,
    인덱스 접근이 가능한 deque를 사용했다.

(위의 두 데이터 모두 선입선출이지만, queue는 인덱스 접근을 못하기 때문에, deque를 이용했다)

그냥 쌩 구현이지만, 중간중간 놓진 부분이 있어, 예상보다 시간이 조금 더 걸렸다.

2번 과정에서 n-1번 칸의 로봇은 다음칸으로 가지 못하고, 내려야 한다. - 처음에 이 과정을 if문으로 처리해주지 못했다.

그리고 로봇을 내리고 나서, 다음 로봇들의 위치를 +1 해줘야 하는데,<br>
로봇을 내렸다 해도, 해당 로봇은 제거되었기 때문에 다음 로봇들의 위치는 인덱스 0부터 시작하는걸 깜빡했다.

3번에서 0번에 올릴때도, 0번 위치에 로봇이 있는지 체크해줘야 하는걸 깜빡했다.

    deque의 모든 데이터를 순차탐색할때, 0번 데이터를 제거했다면, 다음 데이터의 위치는 0번이 된다.
    이를 조심하자

---

### 20056 마법사 상어와 파이어볼(삼성기출)

https://www.acmicpc.net/problem/20056

> 생략

사용한 알고리즘: 구현&시물레이션

시간복잡도: $O()$

그냥 문제를 제대로 읽고 잘 설계해서 구현하는 문제

여기서 놓친 부분이 있었음
1. 속력이 n보다 클때, 다음 위치가 -n보다 작을수도 있었다. -> +n으로는 해결이 안됨
2. 그렇다고 처음부터 속력을 %n 해주면 무조건 틀린다. -> 나중에 새로운 파이어볼을 구할때 속력을 나눠줘야 하는데, 이때 나머지가 달라짐 -> 틀림

    나머지 제대로 체크하자

    (A+B) % C = (A%C + B%C) % C
    (A-B) % C = (A%C - B%C) % C
    (A*B) % C = (A%C * B%C) % C

    (나누는건 안된다)

---

### 23289 온풍기 안녕!

https://www.acmicpc.net/problem/23289

> 너무 길어서 짧게 설명
>
> 1. 온풍기가 분다
> 2. 온도 평준화
> 3. 사이드 온도 1씩 내림
> 4. 초콜릿 먹음(101개 이상 먹으면 종료)
> 5. 지정한 칸들 온도가 K 이상이라면 종료
>
> 위 과정을 계속 반복한다. 먹은 초콜릿 개수를 출력한다.

사용한 알고리즘: 쌩 구현

시간복잡도: $O(n^4 * 100)$
    1 - n^4
    2 - n^2
    3 - n
    4,5 - 1
    => n^4

온풍기가 불때 & 온도 평준화 시킬때 벽이 있는지 없는지 체크해줘야 하는게 너무 귀찮았다.

특히 벽을 구분하는게 힘들었다. 아니 귀찮았다.

그런데 이 문제가 어려운 것은 아니다. 그냥 체크해야 할 것이 많아서 헷갈린다는 점이 문제다.

벽의 유무를 pair\<bool, bool> 2차원 배열로 관리했다. // 아래에 있는지, 오른쪽에 있는지

하지만 이를 구현할때 계속 first와 second를 헷갈려서 시간이 지연됐다.(first가 아래인지 오른쪽인지 헷갈려서 계속 선언부분 왔다갔다 했음)

> 그리고 이 문제에선 괜찮았지만, 하나 놓친 부분이 있었다.
>
> 지정한 칸이 없는 경우를 생각을 안했다.<br>
> (물론 이문제는 지정한 칸이 1개 이상이지만, 다른 문제에서는 없을 수도 있다. 항상 체크하자)

내가 규칙을 정했으면 이를 바로바로 볼 수 있는 곳에 표시를 해두는게 좋다.<br>
(코드가 길어지면 이 규칙을 바로바로 확인하기 힘들다)