### 5557 1학년

https://www.acmicpc.net/problem/5557

> n개의 숫자가 주어졌을때(n <= 100), +와 0을 이용해 마지막 숫자를 제외하고 식을 만드는데, 이 식이 마지막 숫자와 같은 경우의 수를 구하는 문제(계산 값(중간에 나오는 수 모두)은 0에서 20사이)

사용한 알고리즘: DP

시간복잡도: $O(n)$

DP의 시작은 완전탐색

맨처음부터 +를 적용할떄와 -를 적용할때를 다 구하면 풀수 있음. 이 접근의 시간복잡도는 $O(2^n)$

이때 중간에 나오는 수는 모두 0에서 20사이기 때문에, 20*100 크기의 cache를 선언해서 저장해주면 dp로 가능하다.

    cache[i][j]의 의미 = j번쨰 숫자에서, 식의 결과가 i일때의 답이 나올 수 있는 모든 경우의 수

    find(int cur, int n) = n번째 숫자에서, 결과가 cur일때, 답이 나올 수 있는 모든 경우의 수를 반환

DP를 썼을 때 시간복잡도: $O(n)$

> 수의 범위가 0에서 20사이라서 DP로 가능했던 문제

---

### 5582 공통 부분 문자열
> 문자열 두개가 주어졌을때 두 문자열의 공통 부분 문자열을 구하는 문제(연속된 부분 문자열) 

dp를 이용한 문자열 문제

if(str1[i] == str2[j]) dp[i][j] = dp[i-1][j-1] + 1

---

### 9251 LCS(최장 공통 부분 수열)


💡 두 수열이 주어졌을때 모두의 부분 수열중 가장 긴것을 찾는 문제


시간복잡도: $O(n^2)$

이중포문을 이용 행은 첫번째 수열, 열은 두번째 수열

수열의 원소한개씩 비교하는데,

두 원소가 같다면, $dp[i][j]=dp[i-1][j-1]+1$

다르다면, $dp[i][j]=max(dp[i-1][j],dp[i][j-1])$

그리고 dp의 마지막 원소가 정답이다.

풀이

dp[i][j]는 현재 위치에서 LCS의 길이이다. - 최대길이

현재위치(i,j)에서 두 수열의 원소가 같다면,

$A_{i-1}$와 $B_{j-1}$의 최대길이(dp[i-1][j-1]) + 1이  현재위치의 최대길이(dp[i][j])이다.

현재위치에서 두 수열의 원소가 다르다면,

이전 위치에서의 최대길이 $max(dp[i-1][j],dp[i][j-1])$가 현재 위치의 최대길이이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 9328 열쇠

https://www.acmicpc.net/problem/9328

사용한 자료구조 & 알고리즘: 구현, BFS

시간복잡도: $O(26 * n^2)$ (26 = 알파벳 개수)

키를 얻을 때마다, 다시 탐색을 해줘야 한다. (갈 수 있는 위치가 늘어나기 때문)

0. 입구 찾아 저장 해놓기

1. 현재 가지고 있는 열쇠를 가지고 탐색 시작  
1-1. 문서 찾으면 result + 1  
1-2. 열쇠 찾으면 nextKey에 저장

2. curKey와 nextKey 비교  
2-1 같다면 종료(더이상 못찾는다)  
2-2 다르다면 1로 돌아감(더 찾을 수 있음)

3. 결과 출력

`여기서 놓쳐서 시간 잡아먹은 점`
1. 오타(nr -> nc)
2. BFS의 첫번째 위치 경우의 수 코딩 안했음

> BFS는 항상 첫번째 케이스를 놓치지 말고 코딩해줘야 한다.

---

### 9944 NxM 보드 완주하기

https://www.acmicpc.net/problem/9944

사용한 자료구조 & 알고리즘: 구현 & dfs

시간복잡도: $O()$ - 모르겠다....

어떻게 접근했는지, 풀었는지 설명:

1 - 빈 칸 중에서 한 칸을 공을 놓는 위치로 지정 - n^2  
2 - dfs를 통해 공을 이리저리 굴려본다.  
2-1 빈칸이 아예 없다면 그때의 공이 움직인 횟수 비교 - 결과 저장  
2-2 움직이지 못하는데 빈칸이 남았다면 그냥 끝냄  
2-3 빈칸이 남았고 움직일 수 있다면 다른 곳으로 굴린다.  
(최적화를 위해 현재 결과값 보다, 공이 움직인 횟수가 많다면 그냥 끝낸다)

> 여기서 놓친 부분
> 
> 공이 움직이고 나서, 재귀를 실행하기 전 visited를 체크할지,  
> 재귀를 실행하고 나서 visited를 체크할지 고민이 많이 됐다.  
> (놓치진 않았지만, 이것 때문에 시간이 오래걸렸다)
> 
> 출력 예시를 제대로 봤어야 했는데, 자세히 안봐서 어이없게 틀렸다

> 이런 문제는 시간복잡도를 어떻게 구할지 모르겠다.
> 
> 특히 재귀 부분을 어떻게 계산할지를 모르겠다.  
> (이 문제는 visited 체크했다가, 다시 지우고 실행하기 때문에 기존의 dfs와 다르다(더 오래걸린다))

---

### 10800 컬러볼

https://www.acmicpc.net/problem/10800

사용한 자료구조 & 알고리즘: 누적합, 정렬

시간복잡도: $O(n)$

어떻게 접근했는지, 풀었는지 설명:

두개의 컨테이너를 사용했다.

첫번쨰 컨테이너: 현재 볼이 (색깔에 관계없이) 잡을 수 있는 공의 크기의 합  
두번째 컨테이너: 현재 볼이 (같은 색 기준) 잡을 수 있는 공의 크기의 합

(첫번째 컨테이너의 값 - 두번쨰 컨테이너의 값)이 정답

대신 컨테이너들은 크기순으로 정렬되기 떄문에,  
i번째 공이 각각의 컨테이너에서 몇번쨰에 담겨져 있는지 인덱싱이 필요하다.

추가 메모리가 꽤 많이 발생했지만, 인덱싱 덕분에 O(1)에 풀 수 있었다. 

> 이 문제의 핵심은 $O(n^2)$을 트리 or 해시 등를 이용해서 O(logn) or O(n)으로 줄이는 것

> 놓친점
> 
> 크기가 같은 공을 생각하지 못했다.  
> -> 이전 공과 크기가 같다면, 현재 값 = 이전 값 처리
> 
> 크기가 같은 공이 여러개 일때, 다음 공의 case를 생각하지 못했다.  
> -> count를 따로 추가해줘서 겹치는 공이 몇개였는지 체크해줬다.

---

### 11000 강의실 배정

https://www.acmicpc.net/problem/11000

사용한 자료구조 & 알고리즘: 그리디, 우선순위 큐

시간복잡도: $O(nlgn)$

어떻게 접근했는지, 풀었는지 설명:

처음에는 list를 이용해서 풀려고 했음(중간 노드 삭제 편하도록) - 시간복잡도 $O(n^2)$ (시간 초과)

검색을 통해 다른 방법을 알게 되었다. - 우선순위 큐 이용(강의의 끝나는 시간을 오름차순으로 저장) 

(i번째 강의에 접근 중이라면, 우선순위 큐는 i-1번째 강의까지의 끝나는 시간을 저장하고 있다)  
이전 강의까지의 끝나는 시간중 가장 낮은 시간과 현재 강의의 시작 시간을 비교
1. 끝나는 시간 <= 현재 강의 시작 시간 - 우선순위 큐 pop & 현재 강의 시작 시간 push
2. 끝나는 시간 > 현재 강의 시작 시간 - 우선순위 큐 현재 강의 시작 시간 push

우선순위 큐의 size를 출력으로 마무리

우선순위 큐를 이용한 알고리즘의 시간복잡도 - $O(nlgn)$

> 검색을 통해 찾은 방법의 특징은  
> 이전 강의들 중 가장 빨리 끝나는 시간만을 비교해도 상관없다는 특징을 이용했다(그리디)
> 
> (나는 한 강의를 전체 강의와 비교하려고 했다 - 시간 초과)

---

### 11054 가장 긴 바이토닉 부분 수열(요약 LBS)


💡 수열이 주어졌을때, $S_1<S_2<...<S_k>S_{k+1}>...>S_n$을 만족하는 부분수열의 최대길이를 구하는 문제



시간복잡도: $O(n^2)$

가장 긴 증가하는 부분 수열의 응용버전

(Longest Increasing Subsequence)

LIS를 두번 구하면 끝남

0을 기준으로 n-1까지 LIS를 구함 - dp1

그리고 n-1을 기준으로 0까지 LIS를 구함 - dp2

(0을 기준으로 하면 LDS이다)

dp1[i]+dp2[i]-1의 최댓값이 정답이다.

풀이

dp1[i]는 0부터 i까지의 원소중에 LIS

dp2[i]는 n-1부터 i까지의 원소중의 LIS

따라서 dp1[i]+dp2[i]-1은 현재 원소가 가장 큰 원소일때의 LBS를 만족하는 최대 길이이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 11060 점프 점프

https://www.acmicpc.net/problem/11060

> 1xn 크기의 배열이 있을때 0번 위치에서 출발해서 오른쪽 끝에 도달하는 최솟값을 구한다. 점프는 보드에 있는 숫자 내만큼 점프가능하다.
(3번위치에서 3이라면 4,5,6 점프 가능)

사용한 알고리즘: DP

시간복잡도: $O(n^2)$

완전 탐색으로 시작하는데,

현재 위치에서 최소해를 구했다면 이 값을 cache에 저장해놓는다.

다음에는 굳이 같은 위치에서 최소해를 구할필요 없음

    문제 자체는 쉬운 문제였다. 그냥 DP 연습을 위해 풀었음

    최적화 문제를 동적 계획법으로 풀때는
    1. 완전 탐색으로 풀고
    2. 전체 답을 구하지 말고 현재 위치에서 최소해를 구하는 메서드로 변환
    3. 메모이제이션 이용

    위 방법을 생각하면서 풀자

---

### 12869 뮤탈리스크

https://www.acmicpc.net/problem/12869

사용한 자료구조 & 알고리즘: dp

시간복잡도: $O(n^3)$ (n <= 60)

dp를 이용한 재귀 함수로 풀었다.

int find(int x, int y, int z) // 3대 로봇의 체력이 주어졌을 때, 최소 몇번만에 모두 없앨 수 있는지 반환



---

### 14719 빗물

https://www.acmicpc.net/problem/14719

> 2차원 세계에 블록이 쌓여있다. 비가 충분히 많이 왔을 때, 블록 사이에 빗물이 고이는데, 고이는 빗물의 총량을 구하라.

사용한 알고리즘: 구현

시간복잡도: $O(n^2)$ (n <= 500)

(현재 위치에서 빗물이 고이는 조건 - 양쪽 블럭의 높이가 현재 위치보다 높아야 함)  
바닥부터 위로 한 줄씩 서치한다.  
현재 위치보다 높은 칸이 있다면, 다음으로 높은 칸 있는지 서치  
현재 위치보다 높은 칸이 없다면, 그대로 종료(더 이상 빗물이 고일 수 없음)

다음으로 높은 칸 서치할 때, 높은 칸 있다면, 이전 위치들에 빗물을 채움

> 이 문제를 풀 때, 설계와 구현을 분리해서 빨리 풀 수 있었다.  
> 그리고 input을 받는 변수는 대문자로 정의해서 구분하는 것이 좋을 것 같다.

---

### 16194 카드 구매하기2

https://www.acmicpc.net/problem/16194

> n개의 카드팩의 가격이 주어진다. i(1~n)번째 카드팩에는 i개의 카드가 들어있다. 이때 n개의 카드를 구매하기위한 최솟값을 구하는 프로그램을 작성하라(딱 n개, n개 넘으면 안됨)

사용한 알고리즘: DP

시간복잡도: $O(n^2)$

이 문제도 위문제처럼, 완전 탐색으로 시작했다.

find(x)라는 재귀함수를 생성

find(x) = x개의 카드를 구매하기 위한 최솟값을 반환하는 함수

이때 점화식: $find(x) = min^x_{L=1}(card[L] + find(x-L))$

이때 함수를 그냥 실행하면 시간복잡도가 $O(n!)$인데 (그냥 대충 계산했을때)

이때 각 위치의 값을 저장해놓으면(메모이제이션)

시간복잡도가 $O(n^2)$으로 감소한다.

---

### 16637 괄호 추가하기

https://www.acmicpc.net/problem/16637

> n개의 문자로 이루어진 수식이 주어졌을때, 괄호를 추가하여 얻을 수 있는 최댓값을 구하시오<br>
(연산자 우선순위는 없다 - 그냥 왼쪽에서 오른쪽으로 계산)<br>
(괄호 안에 연산자는 1개만, 괄호 중첩은 불가능)

사용한 알고리즘: 브루트포스(그냥 쌩 구현)

시간복잡도: $O()$

처음에는 DP처럼 접근했다.<br>
앞의 식이 뒤의 식에 영향을 안끼친다고 생각해서

그런데 이 접근은 틀렸다.

뒤를 먼저 계산하는건 전체에 괄호를 추가하는 것과 같다 - 이는 잘못된 접근

그냥 무식하게 풀어야 한다.

dfs 방식으로 괄호 넣었다 뺐다 하면서 모든 경우의 수를 체크했다.

인풋 범위가 작아서 가능한 알고리즘

---

### 17135 캐슬 디펜스

https://www.acmicpc.net/problem/17135

> n*m 크기의 보드 위에 몬스터가 있다.  
> n+1 행에 위치한 3명의 궁수가 몬스터를 잡을 수 있다.
> 공격 가능 거리 D  
> (거리 가까운 순, 가장 왼쪽에 있는 순 우선순위)  
> 모든 궁수가 동시에 공격한 뒤 몬스터가 아래로 한칸 이동
> 공격과 이동을 반복한다.
> 
> 궁수의 공격으로 제거할 수 있는 적의 최대 수를 출력하는 문제

사용한 알고리즘: 구현 & BFS

시간복잡도: $O(n^6)$  
(n<=15 가능)

(궁수 3명을 어떻게 배치할지 - 조합(백트래킹))

1 -  궁수 3명을 배치한다.  
2 -  한 라운드씩 진행  
2-1 - 궁수가 적을 찾는다.  
2-2 - 찾은 적들 죽인다.
2-3 - 몬스터 한 칸씩 이동

위 과정을 반복하면서 최댓값을 구한다.

> 무난한 구현문제였지만, 궁수들의 공격 우선순위를 놓쳐서 한번 틀렸다.  
> (처음에는 일반적인 BFS로 풀었음)
>
> 항상 놓치고 있는 건 없는지 확인하자.  
> 처음부터 헷갈릴 만한 것들을 체크해 놓자.

---

### 17136 색종이 붙이기

https://www.acmicpc.net/problem/17136

> 10x10 크기의 보드가 있고<br>
1x1, 2x2, 3x3, 4x4, 5x5 크기의 색종이들이 5장씩 있다<br>
10x10 보드에서 1인 칸을 채우기 위해 색종이를 사용하는데<br>
색종이를 최소 몇개로 보드를 채울 수 있는지 구하라<br>
불가능하면 -1 출력

사용한 알고리즘: 백트래킹, 특이한 dfs

시간복잡도: $O()$

처음부터 무조건 큰 크기의 색종이를 붙이는게 최적해가 되지 않는다.

따라서 5x5 색종이가 가능하면, 5x5도 붙여보고, 그것보다 작은 크기의 색종이도 붙여보면서 일일이 값을 비교해야 한다.

따라서 그리디는 불가능하고, 백트래킹 알고리즘이 가능하다.<br>
(이전에 구한 해보다, 현재 값이 크거나 같다면 그대로 종료)<br>
(무조건 배열의 다음 위치부터 찾는다)

> 여기서 하나 실수한 것이 있는데,<br>
> 백트래킹은 bottom-up만 가능한데, 나는 처음에 top-down으로 접근해서 시간이 많이 지체됐다.<br>
> 그리고 하나 놓친 부분이 있는데, 무조건 배열의 다음 위치부터 찾는걸 놓쳐서<br>
> 처음 시도했을 때 시간초과가 났다.

---

### 17142 연구소 3

https://www.acmicpc.net/problem/17142

> nxn 보드에 비활성화된 바이러스가 있다<br>
여기서 m개를 활성화시켜서 벽을 제외한 모든 빈칸을 바이러스로 채우려고 한다.<br>
바이러스가 1칸 퍼지는데 1초걸릴때, 모든 빈칸이 바이러스로 덮이는 최소시간은?<br>
(비활성화 바이러스가 활성화 바이러스를 만나면 활성화 바이러스로 바뀐다)<br>
(m <= 10)

사용한 알고리즘: bfs & 구현

시간복잡도: $O(_{10}C_5*n^2)$

1. 전체 바이러스가 k개라면(k>=m), 여기서 m개를 골라야 한다. - 최대 $_{10}C_5$
2. bfs를 이용해 바이러스가 퍼지는 시간을 구한다 - $n^2$

처음 제출했을 때는, 시간초과가 났다. <br>
그 이유는 2번을 구현할 때, 매 round마다 바이러스가 모두 퍼졌는지 확인을 해야하는데, 처음에는 이 작업을 모든 칸을 확인했다.(빈칸이 있는지)<br>
그리고 벽때문에 바이러스가 퍼질수 없는지도 확인해야 해서 같이 검사했다.<br>
(이는 이전 보드와 현재 보드 값을 비교했다 - 같은지 다른지)
여기서 시간복잡도가 너무 높게 나왔다.<br>

그래서 모든 칸을 검사하지 않고, 처음 빈칸의 개수를 세주고, 매 round마다 빈칸의 개수가 0이면 바로 탈출하도록 세팅했다.<br>
그리고 한번이라도 바이러스가 퍼졌다면 false로 초기화된 flag에 true를 줬다.

>flag=true // 바이러스가 최소한칸은 퍼졌다. -> 아직 더 퍼질수 있음<br>
flag=false // 한칸도 퍼지지 않았다. -> 더이상 퍼질수 없다.
>   
>빈칸의 개수 > 0 && flag==false<br>
>=> 모든 빈 칸에 바이러스를 퍼뜨릴 수 없다.

bfs 구현은 많이 해봐서 무난했지만, 1번을 구현하는 것이 어색했다. - 시간 많이 잡아먹음

그리고 1번을 수행할때마다, 2번에 필요한 변수들을 초기화해주는것이 많이 헷갈렸다.

문제를 자주 풀어야 익숙해진다.

---

### 17143 단어 뒤집기2

https://www.acmicpc.net/problem/17413

> 문자열이 주어졌을 때, 단어들을 뒤집어서 출력하는 문제(태그와 공백으로 구분, 태그는 그대로 출력)  
<int>fds asdw<max> => <int>sdf wdsa<max>

사용한 알고리즘: 그냥 문자열

시간복잡도: $O(n)$

문자 한개씩 탐색하는데,  
공백이나 태그라면 그대로 출력한다.

여기서 그냥 단어가 나왔다면, 단어의 끝을 찾아서(다음 문자가 공백이나 태그일 때), 단어의 끝부터 시작까지 반대로 출력한다.

문제가 생긴것은, cin >> str; 은 공백을 받지 않기 때문에, 다른 메서드를 써야 했다.  
getline(cin, str) 메서드를 사용해서 문제를 해결했다.

---

### 17779 게리멘더링2

https://www.acmicpc.net/problem/17779

사용한 알고리즘: 구현

시간복잡도: $O(n^6)$  
n <= 20 이라 가능

x y, d1, d2를 세팅하고, 각 구역의 인구 수를 구한다.

구현 과정이 문제에 그대로 써있었다.  
그런데 이를 바로 보지 않고, 내가 나름대로 풀려고 했다. <- 시간 지체 됨

> 문제에 써 있는 과정을 자세히 보고, 이를 활용할 수 있다면 그대로 활용할 수 있어야 한다.  
> 항상 디버깅 제대로 하자

---

### 17609 회문
> 문자열이 주어졌을때 그 문자열이 회문인지, 유사 회문인지, 일반 문자열인지 구하는 문제
> (회문 = 대칭인 문자열, 유사 회문 = 문자 한개 뺐을때 대칭인 문자열)

투포인터를 이용한 문자열 문제

문자열의 양쪽끝에 포인터를 둔 후, 해당 위치의 문자가 같다면 한칸씩 중간으로 옮긴다.

모든 위치의 문자를 통과하면 회문

해당 위치의 문자가 다르다면 세가지 경우의 수가 있음
1. 왼쪽 포인터의 위치를 +1 해주고 다시 진행, 전부 통과하면 유사 회문
2. 오른쪽 포인터의 위치를 -1 해주고 다시 진행, 전부 통과하면 유사 회문
3. 1,2 둘다 실패하면 일반 문자열

---

### 19237 어른 상어

https://www.acmicpc.net/problem/19237

사용한 알고리즘: 구현

시간복잡도: $O(1000 * n^2)$

과정
1. 상어 이동방향 찾음 & 이동
2. 상어 자리에 냄새 뿌리고, 기존 냄새들 -1

사용한 방법

1. 상어에 대한 표현을 두가지로 해줬다.  
2-1. 2차원 배열에서 위치  
2-2. 벡터로 상태 표현

2. 앞번호 상어를 먼저 움직여 주면, 뒷 상어부터는 겹치는 걸 체크해 주지 않아도 된다. -> 어차피 겹치면 앞 번호가 사니까

> 어떤 객체를 두가지 상태로 표현한다면,  
> 상태가 변경될 때 양쪽다 변경될 수 있도록 주의해야 한다.  
>
> 항상 이동할 때 기존것 지워주고, 이동한 지점에 표시를 해줘야 한다.
>
> 항상 시작하는 시점과 끝나는 시점을 주의하자

---

### 19238 스타트택시 (삼성 기출)

https://www.acmicpc.net/problem/19238

> nxn 보드 위에 1개의 택시와 m명의 손님이 있다.<br>
각각의 손님은 목적지를 가지고 있다.<br>
택시는 모든 손님을 해당 위치에 태워서 목적지까지 옮겨야한다.<br>
(모든 손님의 위치와 목적지는 겹치지 않는다 & 택시는 한명만 태울 수 있다)<br>
이동하다가 연료가 부족해지면 -1을 출력하고 종료<br>
연료는 손님 태울때 & 목적지 이동할때 소모됨 & 목적지 도착하면 출발지부터 목적지까지의 거리의 두배를 연료료 채운다.<br>
>
> 손님 태울때 우선순위는 거리작은것,행작은것,열작은것 이다.

사용한 알고리즘: 쌩 구현, bfs

시간복잡도: $O(m*n^2)$

총 3단계로 구분했다.
0. 각 손님들이 목적지까지 가는데 걸리는 거리를 계산한다. & 각 배열에 저장
1. 택시가 현재 위치에서 가장 가까이 있는 손님을 찾는다. & 그 위치로 택시 이동
2. 해당 손님의 출발지에서 목적지까지 이동

12 과정을 반복하는데 중간에 연료가 부족해지면 바로 -1을 출력하고 종료했다.

0의 시간복잡도 - $O(m*n^2)$ - 손님은 m명, 손님마다 bfs로 거리를 계산했음<br>
1의 시간복잡도 - $O(n^2)$ - 한명찾을때 bfs 이용<br>
2의 시간복잡도 - O(1) - 이미 출발지와 목적지의 거리를 계산해놓았기 때문에 상수시간

    여기서 놓친 반례가 한개 있었다.

    손님의 출발지와 목적지가 벽때문에 연결되어있지 않을때를 처리하지 못했다.
>
    이 문제에서 생길 수 있는 반례

    1. 택시의 시작지점에 손님이 있을 수 있다.
    2. 택시가 손님을 찾는 과정에서 우선순위를 놓칠 수 있다.(최단거리, 행이 작게, 열이 작게)
        여기서 단순히 dr[4],dc[4]의 순서를 정한다고 우선순위가 해결되지 않는다.(왼왼왼 보다 오오위가 우선순위)
        -> 그냥 모든 배열에 접근해서 거리,행,열을 체크해야 한다.
    
    3. 택시가 손님에게 갔다가 목적지를 가는 과정에서 연료가 떨어질 수 있다.
        손님에게 갈때 & 출발지에서 목적지로 갈때 - 두가지 전부 체크해야 한다.
    4. for문에서 bfs를 사용할때 queue와 visited 초기화를 제대로 안 했을 수 있다.
>
    항상 반례를 생각하자

---

### 19539 사과나무

https://www.acmicpc.net/problem/19539

사용한 자료구조 & 알고리즘: 그리디

시간복잡도: $O(n)$

어떻게 접근했는지, 풀었는지 설명:

yes or no를 구분하는 기준

1 - 전체 크기의 합이 3으로 나눠 떨어지지 않으면 NO

여기서 3으로 나눴을 때의 몫은, 물뿌리개를 뿌리는 일 수이다.

(ex - 3 5 1 -> 3일동안 뿌려야 가능 = 9 / 3)

-> 2짜리 물뿌리개를 뿌리는 횟수도 일 수와 동일해야 한다.

-> 2를 뿌릴 수 있는 전체 횟수가 일 수보다 크거나 같으면 YES, 아니면 NO

2를 뿌릴 수 있는 전체 횟수가 일 수보다 커도 되는 이유
-> 2 = 1 + 1 -> 2를 한 번 안뿌리고 1을 두번 뿌린다고 생각하면 됨  
-> 2를 뿌리는 전체횟수와 일 수가 같아짐

> 코드로 구현하는 것은 문제가 없지만,  
> 위 아이디어를 생각하는게 힘들었다.



---

### 20055 컨베이어 벨트

https://www.acmicpc.net/problem/20055

> 2n 길이의 컨베이어 벨트가 있다.(0~2n-1)<br>
벨트가 한칸움직이면 그 위의 로봇도 같이 움직이는데, n-1번 위치의 로봇은 다음칸으로 움직이지 않고 벨트에서 내린다.
>
> 1. 모든 벨트가 한칸씩 움직인다.
> 2. 벨트위의 모든 로봇이 다음 칸으로 움직인다.
>   다음 칸으로 움직인다면, 해당 칸의 내구도는 1 감소한다. (내구도가 0이라면 다음칸으로 못감)
> 3. 0번 위치에 새로운 로봇을 올린다.(0번 위치의 내구도가 1 이상이고, 로봇이 그 위치에 없을 때)
> 4. 내구도가 0인 벨트가 k개 이상이 될때까지 123번 과정을 진행한다.
>
> 위 과정이 종료되었을때, 몇번째 단계가 진행중이었을까?

사용한 알고리즘: 구현

시간복잡도: $O()$

벨트가 한칸씩 움직이는걸 표현하기 위해, 자료구조로 deque를 사용했다.

    한칸움직이는걸 pop_back()과 push_front()로 구현, 
    모든 데이터 접근을 위해 queue가 아닌 deque 사용

로봇들의 위치도 자료구조로 표현해야 하는데, 이를 역시 deque를 사용했다.

    로봇들은 선입선출이라 queue도 가능할 것같지만, (1번과정을 진행할때) 모든 로봇의 값을 +1 해줘야 하기때문에,
    인덱스 접근이 가능한 deque를 사용했다.

(위의 두 데이터 모두 선입선출이지만, queue는 인덱스 접근을 못하기 때문에, deque를 이용했다)

그냥 쌩 구현이지만, 중간중간 놓진 부분이 있어, 예상보다 시간이 조금 더 걸렸다.

2번 과정에서 n-1번 칸의 로봇은 다음칸으로 가지 못하고, 내려야 한다. - 처음에 이 과정을 if문으로 처리해주지 못했다.

그리고 로봇을 내리고 나서, 다음 로봇들의 위치를 +1 해줘야 하는데,<br>
로봇을 내렸다 해도, 해당 로봇은 제거되었기 때문에 다음 로봇들의 위치는 인덱스 0부터 시작하는걸 깜빡했다.

3번에서 0번에 올릴때도, 0번 위치에 로봇이 있는지 체크해줘야 하는걸 깜빡했다.

    deque의 모든 데이터를 순차탐색할때, 0번 데이터를 제거했다면, 다음 데이터의 위치는 0번이 된다.
    이를 조심하자

---

### 20056 마법사 상어와 파이어볼(삼성기출)

https://www.acmicpc.net/problem/20056

> 생략

사용한 알고리즘: 구현&시물레이션

시간복잡도: $O()$

그냥 문제를 제대로 읽고 잘 설계해서 구현하는 문제

여기서 놓친 부분이 있었음
1. 속력이 n보다 클때, 다음 위치가 -n보다 작을수도 있었다. -> +n으로는 해결이 안됨
2. 그렇다고 처음부터 속력을 %n 해주면 무조건 틀린다. -> 나중에 새로운 파이어볼을 구할때 속력을 나눠줘야 하는데, 이때 나머지가 달라짐 -> 틀림
>
    나머지 제대로 체크하자

    (A+B) % C = (A%C + B%C) % C
    (A-B) % C = (A%C - B%C) % C
    (A*B) % C = (A%C * B%C) % C

    (나누는건 안된다)

---

### 20061 모노미노도미노 2

https://www.acmicpc.net/problem/20061

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O()$

어떻게 접근했는지, 풀었는지 설명:

1. 블록 옮기고
2. 한줄 채워진 행/열 있다면 점수+1 & 한칸씩 땡겨주기
3. 연두/하늘 보드에 블럭 있다면 한칸씩 땡겨주기
4. 1.2.3 블럭 개수만큼 반복
5. 점수 계산

문제 읽는게 귀찮을 뿐이지, 써놓은 대로 코드 작성하면 풀수 있는 문제

> 여기서 핵심은 각 기능별로 메서드를 구분해 처리하는게 빠르게 할 수 있는 방법

---

### 20210 파일 탐색기

https://www.acmicpc.net/problem/20210

사용한 자료구조 & 알고리즘: 문자열, 정렬

시간복잡도: $O(nlogn * l)$ (l = 문자열의 길이 <= 100)

어떻게 접근했는지, 풀었는지 설명:

정렬은 algorithm 라이브러리의 sort를 사용

결국 두 문자를 비교하는 것이 이 문제의 핵심

두 문자 비교 case
1. 한쪽이 문자, 다른쪽은 숫자 -> 문자가 더 크다.
2. 둘다 문자 -> 문자 비교
3. 둘다 숫자 -> 숫자 비교

문자 비교는 간단하니 생략

숫자 비교  

1. 0을 제외한 자릿수 체크 -> 자릿수 큰 쪽이 더 큰 것
2. (자릿수 같은 상태) 두 숫자 한개씩 비교 -> 숫자 큰 쪽이 더 큰 것
3. (모든 수가 같다) 두 숫자의 길이를 비교한다.

1번 케이스 - 0123 vs 00012 - 0123이 더 크다.

2번 케이스 - 01234 vs 01244 - 01244가 더 크다.

3번 케이스 - 00012 vs 12 - 00012가 더 크다.

> 문자를 일일이 비교하는 것이 매우 귀찮았던 문제  
> 하지만 어려움은 없었다.
> 
> 각 기능별로 메서드를 분리해줌으로써, (isChar, isInt, compareInt, compareChar)  
> 문제를 빠르게 풀 수 있었다.

---

### 23289 온풍기 안녕!(삼성기출)

https://www.acmicpc.net/problem/23289

> 너무 길어서 짧게 설명
>
> 1. 온풍기가 분다
> 2. 온도 평준화
> 3. 사이드 온도 1씩 내림
> 4. 초콜릿 먹음(101개 이상 먹으면 종료)
> 5. 지정한 칸들 온도가 K 이상이라면 종료
>
> 위 과정을 계속 반복한다. 먹은 초콜릿 개수를 출력한다.

사용한 알고리즘: 쌩 구현

시간복잡도: $O(n^4 * 100)$
    1 - n^4
    2 - n^2
    3 - n
    4,5 - 1
    => n^4

온풍기가 불때 & 온도 평준화 시킬때 벽이 있는지 없는지 체크해줘야 하는게 너무 귀찮았다.

특히 벽을 구분하는게 힘들었다. 아니 귀찮았다.

그런데 이 문제가 어려운 것은 아니다. 그냥 체크해야 할 것이 많아서 헷갈린다는 점이 문제다.

벽의 유무를 pair\<bool, bool> 2차원 배열로 관리했다. // 아래에 있는지, 오른쪽에 있는지

하지만 이를 구현할때 계속 first와 second를 헷갈려서 시간이 지연됐다.(first가 아래인지 오른쪽인지 헷갈려서 계속 선언부분 왔다갔다 했음)

> 그리고 이 문제에선 괜찮았지만, 하나 놓친 부분이 있었다.
>
> 지정한 칸이 없는 경우를 생각을 안했다.<br>
> (물론 이문제는 지정한 칸이 1개 이상이지만, 다른 문제에서는 없을 수도 있다. 항상 체크하자)

내가 규칙을 정했으면 이를 바로바로 볼 수 있는 곳에 표시를 해두는게 좋다.<br>
(코드가 길어지면 이 규칙을 바로바로 확인하기 힘들다)