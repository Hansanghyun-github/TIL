### 5582 공통 부분 문자열
> 문자열 두개가 주어졌을때 두 문자열의 공통 부분 문자열을 구하는 문제(연속된 부분 문자열) 

dp를 이용한 문자열 문제

if(str1[i] == str2[j]) dp[i][j] = dp[i-1][j-1] + 1

---

### 9251 LCS(최장 공통 부분 수열)


💡 두 수열이 주어졌을때 모두의 부분 수열중 가장 긴것을 찾는 문제


시간복잡도: $O(n^2)$

이중포문을 이용 행은 첫번째 수열, 열은 두번째 수열

수열의 원소한개씩 비교하는데,

두 원소가 같다면, $dp[i][j]=dp[i-1][j-1]+1$

다르다면, $dp[i][j]=max(dp[i-1][j],dp[i][j-1])$

그리고 dp의 마지막 원소가 정답이다.

풀이

dp[i][j]는 현재 위치에서 LCS의 길이이다. - 최대길이

현재위치(i,j)에서 두 수열의 원소가 같다면,

$A_{i-1}$와 $B_{j-1}$의 최대길이(dp[i-1][j-1]) + 1이  현재위치의 최대길이(dp[i][j])이다.

현재위치에서 두 수열의 원소가 다르다면,

이전 위치에서의 최대길이 $max(dp[i-1][j],dp[i][j-1])$가 현재 위치의 최대길이이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 11054 가장 긴 바이토닉 부분 수열(요약 LBS)


💡 수열이 주어졌을때, $S_1<S_2<...<S_k>S_{k+1}>...>S_n$을 만족하는 부분수열의 최대길이를 구하는 문제



시간복잡도: $O(n^2)$

가장 긴 증가하는 부분 수열의 응용버전

(Longest Increasing Subsequence)

LIS를 두번 구하면 끝남

0을 기준으로 n-1까지 LIS를 구함 - dp1

그리고 n-1을 기준으로 0까지 LIS를 구함 - dp2

(0을 기준으로 하면 LDS이다)

dp1[i]+dp2[i]-1의 최댓값이 정답이다.

풀이

dp1[i]는 0부터 i까지의 원소중에 LIS

dp2[i]는 n-1부터 i까지의 원소중의 LIS

따라서 dp1[i]+dp2[i]-1은 현재 원소가 가장 큰 원소일때의 LBS를 만족하는 최대 길이이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---


### 17609 회문
> 문자열이 주어졌을때 그 문자열이 회문인지, 유사 회문인지, 일반 문자열인지 구하는 문제
> (회문 = 대칭인 문자열, 유사 회문 = 문자 한개 뺐을때 대칭인 문자열)

투포인터를 이용한 문자열 문제

문자열의 양쪽끝에 포인터를 둔 후, 해당 위치의 문자가 같다면 한칸씩 중간으로 옮긴다.

모든 위치의 문자를 통과하면 회문

해당 위치의 문자가 다르다면 세가지 경우의 수가 있음
1. 왼쪽 포인터의 위치를 +1 해주고 다시 진행, 전부 통과하면 유사 회문
2. 오른쪽 포인터의 위치를 -1 해주고 다시 진행, 전부 통과하면 유사 회문
3. 1,2 둘다 실패하면 일반 문자열