### 5052 전화번호 목록

https://www.acmicpc.net/problem/5052

`사용한 자료구조 & 알고리즘:` 해시

`시간복잡도:` $O(n)$

`어떻게 접근했는지, 풀었는지 설명:`

모든 문자열을 하나씩 비교하는건 O(n^2) - 시간초과

해시를 이용하면 굳이 하나씩 비교할 필요가 없다.

현재 글자 s[i]에서,  
s[i]의 첫글자부터, 마지막 글자까지, 해당 글자가 해시에 있는지 검사한다.

> 49911이면,  
> 4, 49, 499, 4991, 49991 이 해시에 있는지 검사

만약 해시에 있다면 그대로 NO 출력  
없다면 다음 문자를 검사한다.

이렇게 되면 O(n*m) 으로 통과할 수 있다.

    이 문제는 해시뿐만 아니라 트라이라는 자료 구조를 이용해 풀 수도 있다.

    트라이: 각 문자를 이진 트리를 이용해 저장
    911 이면 9->1->1 로 저장
   
    다음 문자를 해당 노드들을 검사하면서 저장하면 간단하게 풀 수 있다.

    (대신 이 자료 구조는 글자 수에 제한이 있을 때 쓸 수 있는 것 같다)
    (글자 수 제한 = 트리의 높이 제한)

---

### 5557 1학년

https://www.acmicpc.net/problem/5557

> n개의 숫자가 주어졌을때(n <= 100), +와 0을 이용해 마지막 숫자를 제외하고 식을 만드는데, 이 식이 마지막 숫자와 같은 경우의 수를 구하는 문제(계산 값(중간에 나오는 수 모두)은 0에서 20사이)

사용한 알고리즘: DP

시간복잡도: $O(n)$

DP의 시작은 완전탐색

맨처음부터 +를 적용할떄와 -를 적용할때를 다 구하면 풀수 있음. 이 접근의 시간복잡도는 $O(2^n)$

이때 중간에 나오는 수는 모두 0에서 20사이기 때문에, 20*100 크기의 cache를 선언해서 저장해주면 dp로 가능하다.

    cache[i][j]의 의미 = j번쨰 숫자에서, 식의 결과가 i일때의 답이 나올 수 있는 모든 경우의 수

    find(int cur, int n) = n번째 숫자에서, 결과가 cur일때, 답이 나올 수 있는 모든 경우의 수를 반환

DP를 썼을 때 시간복잡도: $O(n)$

> 수의 범위가 0에서 20사이라서 DP로 가능했던 문제

---

### 5582 공통 부분 문자열
> 문자열 두개가 주어졌을때 두 문자열의 공통 부분 문자열을 구하는 문제(연속된 부분 문자열) 

dp를 이용한 문자열 문제

if(str1[i] == str2[j]) dp[i][j] = dp[i-1][j-1] + 1

---

### 8980 택배

https://www.acmicpc.net/problem/8980

`사용한 자료구조 & 알고리즘:` 그리디

`시간복잡도:` $O(NM)$

`어떻게 접근했는지, 풀었는지 설명:`

현재 i번쨰 마을에서의 최적해를 구하는 방법

현재 트럭에 실고 있는 택배들과, i번쨰 마을에 있는 택배들 중에서  
**목적지 번호 오름차순으로 실는다** (트럭의 최대 용량까지)

> 만약 트럭에 있는 택배의 목적지 번호보다, 마을에서 실을 수 있는 택배의 목적지 번호가 작다면  
> 트럭에 있는 택배를 빼고, 마을 택배를 실는다.

과정
1. 택배들의 정보를 출발지, 목적지 오름차순으로 정렬
2. 맨 처음 마을에서 실을 수 있는 택배들을 실는다.  
   (목적지 오름차순으로)
3. (2번 마을부터 M번 마을까지 반복)
   3-1 i번째 마을에 내릴 수 있는 택배들을 트럭에서 내린다.  
   3-2 i번째 마을의 택배들과, 현재 트럭의 택배들을  
   목적지의 오름차순으로 실는다.  
   (택배의 최대 용량까지)

마을의 개수는 N개, 택배의 최대 개수는 M개  
따라서 시간복잡도는 O(NM)이 된다.

---

### 9251 LCS(최장 공통 부분 수열)


💡 두 수열이 주어졌을때 모두의 부분 수열중 가장 긴것을 찾는 문제


시간복잡도: $O(n^2)$

이중포문을 이용 행은 첫번째 수열, 열은 두번째 수열

수열의 원소한개씩 비교하는데,

두 원소가 같다면, $dp[i][j]=dp[i-1][j-1]+1$

다르다면, $dp[i][j]=max(dp[i-1][j],dp[i][j-1])$

그리고 dp의 마지막 원소가 정답이다.

풀이

dp[i][j]는 현재 위치에서 LCS의 길이이다. - 최대길이

현재위치(i,j)에서 두 수열의 원소가 같다면,

$A_{i-1}$와 $B_{j-1}$의 최대길이(dp[i-1][j-1]) + 1이  현재위치의 최대길이(dp[i][j])이다.

현재위치에서 두 수열의 원소가 다르다면,

이전 위치에서의 최대길이 $max(dp[i-1][j],dp[i][j-1])$가 현재 위치의 최대길이이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 9328 열쇠

https://www.acmicpc.net/problem/9328

사용한 자료구조 & 알고리즘: 구현, BFS

시간복잡도: $O(26 * n^2)$ (26 = 알파벳 개수)

키를 얻을 때마다, 다시 탐색을 해줘야 한다. (갈 수 있는 위치가 늘어나기 때문)

0. 입구 찾아 저장 해놓기

1. 현재 가지고 있는 열쇠를 가지고 탐색 시작  
1-1. 문서 찾으면 result + 1  
1-2. 열쇠 찾으면 nextKey에 저장

2. curKey와 nextKey 비교  
2-1 같다면 종료(더이상 못찾는다)  
2-2 다르다면 1로 돌아감(더 찾을 수 있음)

3. 결과 출력

`여기서 놓쳐서 시간 잡아먹은 점`
1. 오타(nr -> nc)
2. BFS의 첫번째 위치 경우의 수 코딩 안했음

> BFS는 항상 첫번째 케이스를 놓치지 말고 코딩해줘야 한다.

---

### 9944 NxM 보드 완주하기

https://www.acmicpc.net/problem/9944

사용한 자료구조 & 알고리즘: 구현 & dfs

시간복잡도: $O()$ - 모르겠다....

어떻게 접근했는지, 풀었는지 설명:

1 - 빈 칸 중에서 한 칸을 공을 놓는 위치로 지정 - n^2  
2 - dfs를 통해 공을 이리저리 굴려본다.  
2-1 빈칸이 아예 없다면 그때의 공이 움직인 횟수 비교 - 결과 저장  
2-2 움직이지 못하는데 빈칸이 남았다면 그냥 끝냄  
2-3 빈칸이 남았고 움직일 수 있다면 다른 곳으로 굴린다.  
(최적화를 위해 현재 결과값 보다, 공이 움직인 횟수가 많다면 그냥 끝낸다)

> 여기서 놓친 부분
> 
> 공이 움직이고 나서, 재귀를 실행하기 전 visited를 체크할지,  
> 재귀를 실행하고 나서 visited를 체크할지 고민이 많이 됐다.  
> (놓치진 않았지만, 이것 때문에 시간이 오래걸렸다)
> 
> 출력 예시를 제대로 봤어야 했는데, 자세히 안봐서 어이없게 틀렸다

> 이런 문제는 시간복잡도를 어떻게 구할지 모르겠다.
> 
> 특히 재귀 부분을 어떻게 계산할지를 모르겠다.  
> (이 문제는 visited 체크했다가, 다시 지우고 실행하기 때문에 기존의 dfs와 다르다(더 오래걸린다))

---

### 10775

https://www.acmicpc.net/problem/10775

사용한 자료구조 & 알고리즘: 그리디 & 분리 집합

시간복잡도: $O(nlogn)$

어떻게 접근했는지, 풀었는지 설명:

여기서 적용할 아이디어  
i번째 비행기 gi를 할 수 있는 한 가장 높은 게이트(<= gi)에 도킹시켜야 한다.  
그래야 최대한 많은 비행기를 도킹시킬 수 있다.

여기서 문제는  
input이 10만이라는 것 - $O(n^2)$ 안됨  
O(logn)만에 풀 수 있는 알고리즘을 적용해야 한다.

분리 집합을 적용 - O(logn)에 가능

풀이 순서
1. 도킹 가능한 게이트를 찾는다.  
1-1 없다면(가능한 게이트가 0번) 종료
2. Union(docking, docking - 1) // 찾은 게이트와 이전 번호 게이트를 연결(같은 집합으로)

> 여기서 헤맨 이유
> 
> 처음에는 O(logn) 으로 이분 탐색(lower_bound 메서드)를 적용하려고 했다.  
> 그런데 도킹한 게이트는 컨테이너에 제거해야 해서 list 컨테이너를 사용했는데,  
> list 컨테이너는 이분탐색이 불가능하다(O(n)) - 인덱스로 접근이 안되기 때문

---

### 10800 컬러볼

https://www.acmicpc.net/problem/10800

사용한 자료구조 & 알고리즘: 누적합, 정렬

시간복잡도: $O(n)$

어떻게 접근했는지, 풀었는지 설명:

두개의 컨테이너를 사용했다.

첫번쨰 컨테이너: 현재 볼이 (색깔에 관계없이) 잡을 수 있는 공의 크기의 합  
두번째 컨테이너: 현재 볼이 (같은 색 기준) 잡을 수 있는 공의 크기의 합

(첫번째 컨테이너의 값 - 두번쨰 컨테이너의 값)이 정답

대신 컨테이너들은 크기순으로 정렬되기 떄문에,  
i번째 공이 각각의 컨테이너에서 몇번쨰에 담겨져 있는지 인덱싱이 필요하다.

추가 메모리가 꽤 많이 발생했지만, 인덱싱 덕분에 O(1)에 풀 수 있었다. 

> 이 문제의 핵심은 $O(n^2)$을 트리 or 해시 등를 이용해서 O(logn) or O(n)으로 줄이는 것

> 놓친점
> 
> 크기가 같은 공을 생각하지 못했다.  
> -> 이전 공과 크기가 같다면, 현재 값 = 이전 값 처리
> 
> 크기가 같은 공이 여러개 일때, 다음 공의 case를 생각하지 못했다.  
> -> count를 따로 추가해줘서 겹치는 공이 몇개였는지 체크해줬다.

---

### 10999 구간 합 구하기 2

https://www.acmicpc.net/problem/10999

`사용한 자료구조 & 알고리즘:` 세그먼트 르리 & lazy propagation

`시간복잡도:` $O(MlogN)$

어떻게 접근했는지, 풀었는지 설명:

세그먼트 트리와 lazy propagation을 실습해보는 문제

여기서 헷갈린 점이 있었다.  
부모 노드의 값을 자식노드로 전파할 때,  
만약 자식 노드에 lazy value가 없다면 부모 노드의 lazy value를 그대로 입력하면 된다.  
하지만 자식 노드에 이미 lazy value가 있다면 거기에 + 해줘야 한다.

    트리를 만들 때, 벡터의 주소 값을 줘야 하는데,
    그냥 벡터를 전해서 벡터를 복사하는 시간때문에
    시간 초과가 났다.
    항상 값의 복사에 주의하자

---

### 11000 강의실 배정

https://www.acmicpc.net/problem/11000

사용한 자료구조 & 알고리즘: 그리디, 우선순위 큐

시간복잡도: $O(nlgn)$

어떻게 접근했는지, 풀었는지 설명:

처음에는 list를 이용해서 풀려고 했음(중간 노드 삭제 편하도록) - 시간복잡도 $O(n^2)$ (시간 초과)

검색을 통해 다른 방법을 알게 되었다. - 우선순위 큐 이용(강의의 끝나는 시간을 오름차순으로 저장) 

(i번째 강의에 접근 중이라면, 우선순위 큐는 i-1번째 강의까지의 끝나는 시간을 저장하고 있다)  
이전 강의까지의 끝나는 시간중 가장 낮은 시간과 현재 강의의 시작 시간을 비교
1. 끝나는 시간 <= 현재 강의 시작 시간 - 우선순위 큐 pop & 현재 강의 시작 시간 push
2. 끝나는 시간 > 현재 강의 시작 시간 - 우선순위 큐 현재 강의 시작 시간 push

우선순위 큐의 size를 출력으로 마무리

우선순위 큐를 이용한 알고리즘의 시간복잡도 - $O(nlgn)$

> 검색을 통해 찾은 방법의 특징은  
> 이전 강의들 중 가장 빨리 끝나는 시간만을 비교해도 상관없다는 특징을 이용했다(그리디)
> 
> (나는 한 강의를 전체 강의와 비교하려고 했다 - 시간 초과)

---

### 11003 최솟값 찾기

https://www.acmicpc.net/problem/11003

`사용한 자료구조 & 알고리즘:` 우선순위 큐 or 덱

`시간복잡도:` $O(nlogn) or O(n)$

어떻게 접근했는지, 풀었는지 설명:

`설명1 - 우선순위 큐`

매 단계마다 {idx, value}을 넣어준다.  
(우선순위 큐 pq는 value가 가장 작은 값이 top에 오도록 정렬)

그리고 현재 pq의 top의 idx가 현재 i 보다 작다면 pop 해준다.  
(top의 idx가 현재 i 보다 크거나 같을 때까지 반복)

그리고 매 단계마다 top의 value를 출력해준다.

> 위 방법의 시간복잡도는 O(nlogn)이다.  
> N이 최대 5백만이라 c++은 빡빡하게 가능하다.  
> (```ios::sync_with_stdio(0); cin.tie(0);``` 필수)

`설명2 - 덱`

덱 dq에는 {idx, value}가 저장되어 있다.  
아래의 과정을 매 단계마다 반복한다.

dq의 front의 idx가 현재 i 보다 작다면 pop  
dq의 back의 value가 input[i]보다 작다면 pop  
(커질떄까지 반복)  
마지막으로 dq.push_back({i,input[i]})

> 위 방법의 시간복잡도는 평균 O(N)이다.
> 
> pop하는 횟수가 매 단계마다 다르지만  
> 어차피 N번 진행하는 동안 pop되는 횟수는 최대 N번이기 떄문에  
> 1번 진행할 때의 pop되는 횟수는 평균적으로 한번이다.

      현재 idx의 value만 가지고 연산하는게 아니라 
      idx도 같이 넣어서 관리함으로써 연산량을 줄이는 아이디어가 중요한 문제였다.

      맨 처음 나는 그냥 multiset을 활용해서 value가지고 연산하려고 했다.
      하지만 N이 5백만까지 커지면 시간초과가 나서 실패했다.
      (N* 3logN 이라서 살짝 시간초과가 났다)
      (아마 N이 백만 정도라면 가능 했을 듯)

      이런 문제처럼 하나의 문제를 가지고
      여러 아이디어가 나온다는게 참 신기하고 재밌다.

---

### 11054 가장 긴 바이토닉 부분 수열(요약 LBS)


💡 수열이 주어졌을때, $S_1<S_2<...<S_k>S_{k+1}>...>S_n$을 만족하는 부분수열의 최대길이를 구하는 문제



시간복잡도: $O(n^2)$

가장 긴 증가하는 부분 수열의 응용버전

(Longest Increasing Subsequence)

LIS를 두번 구하면 끝남

0을 기준으로 n-1까지 LIS를 구함 - dp1

그리고 n-1을 기준으로 0까지 LIS를 구함 - dp2

(0을 기준으로 하면 LDS이다)

dp1[i]+dp2[i]-1의 최댓값이 정답이다.

풀이

dp1[i]는 0부터 i까지의 원소중에 LIS

dp2[i]는 n-1부터 i까지의 원소중의 LIS

따라서 dp1[i]+dp2[i]-1은 현재 원소가 가장 큰 원소일때의 LBS를 만족하는 최대 길이이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 11060 점프 점프

https://www.acmicpc.net/problem/11060

> 1xn 크기의 배열이 있을때 0번 위치에서 출발해서 오른쪽 끝에 도달하는 최솟값을 구한다. 점프는 보드에 있는 숫자 내만큼 점프가능하다.
(3번위치에서 3이라면 4,5,6 점프 가능)

사용한 알고리즘: DP

시간복잡도: $O(n^2)$

완전 탐색으로 시작하는데,

현재 위치에서 최소해를 구했다면 이 값을 cache에 저장해놓는다.

다음에는 굳이 같은 위치에서 최소해를 구할필요 없음

    문제 자체는 쉬운 문제였다. 그냥 DP 연습을 위해 풀었음

    최적화 문제를 동적 계획법으로 풀때는
    1. 완전 탐색으로 풀고
    2. 전체 답을 구하지 말고 현재 위치에서 최소해를 구하는 메서드로 변환
    3. 메모이제이션 이용

    위 방법을 생각하면서 풀자

---

### 11066 파일 합치기

https://www.acmicpc.net/problem/11066

`사용한 자료구조 & 알고리즘:` DP

`시간복잡도:` $O(n^3)$

어떻게 접근했는지, 풀었는지 설명:

```getResult(int s, int f);``` = s번째 파일부터 f번재 파일을 합칠 때의 최솟값을 반환하는 메서드

여기서 겹치는 부분이 생기는데,  
getResult(s, f)를 한번만 실행하고 이를 메모리에 저장해 최적화 할 수 있다.

dp[i][j] = min(i <= k < j)(getResult(i, k) + getResult(k + 1, j) + sum(i,j))

위 공식을 이용해 최적화 한다.

    결국 DP의 핵심은 브루트포스로 푼 문제에서  
    겹치는 부분을 찾아내서, 
    겹치는 부분의 값을 메모리에 저장해 최적화하는 것이 핵심

    DP의 맨 첫번째 단계는 
    문제 예시를 풀어보면서 
    겹치는 부분을 찾아야 하는 것이다.

---

### 12015 가장 긴 증가하는 부분 수열 2

https://www.acmicpc.net/problem/12015

`사용한 자료구조 & 알고리즘:`

`시간복잡도:` $O(nlogn)$

`어떻게 접근했는지, 풀었는지 설명:`

기본적인 DP를 이용하면 $O(n^2)$라서, 시간초과가 발생한다.

이분 탐색을 이용해서 O(nlogn)까지 줄일 수 있다.

비어있는 컨테이너 v에서 시작한다.

(i번째 원소에서)
1. if v.empty() == true, then push_back(input[i])
2. if v.lower_bound(input[i]) == v.end(), then push_back(input[i])
   else *iter = input[i]
3. v.size()가 정답

v[i]가 의미하는 것: LIS가 i+1인 수열의 마지막 원소 중 가장 작은 값

(v.lower_bound(input[i]) == v.end()) 이 말은,  
v의 모든 원소가 input[i]보다 작다는 것 -> input[i]이 마지막 원소인 LIS의 길이가 v.size() + 1이 된다.  
-> v.push_back(input[i]) // LIS가 v.size()+1인 수열의 마지막 원소가 input[i]가 된다.

(v.lower_bound(input[i]) != v.end()) 이 말은,  
input[i]가 이전 위치보다는 크다 && input[i]가 현재 LIS인 수열의 마지막 원소보다 값이 작다는 것
-> *iter = input[i] // 현재 LIS인 수열의 마지막 원소를 input[i]로 대체

lower_bound의 시간복잡도는 O(logn)이기 때문에 O(nlogn)으로 풀 수 있다.

---

### 12869 뮤탈리스크

https://www.acmicpc.net/problem/12869

사용한 자료구조 & 알고리즘: dp

시간복잡도: $O(n^3)$ (n <= 60)

dp를 이용한 재귀 함수로 풀었다.

int find(int x, int y, int z) // 3대 로봇의 체력이 주어졌을 때, 최소 몇번만에 모두 없앨 수 있는지 반환



---

### 12904 A와 B

https://www.acmicpc.net/problem/12904

사용한 자료구조 & 알고리즘: 그리디

시간복잡도: $O(n^2)$

어떻게 접근했는지, 풀었는지 설명:

str1을 str2로 만들 떄의 시간복잡도는 너무 높다 - $O(2^1000)$

하지만 str2를 str1으로 만드는 시간복잡도는 n^2 밖에 안된다.  
(전체 문자열의 길이 * 뒤집을 떄의 시간복잡도)

왜냐하면 str1을 str2로 만드는 경우의 수가 딱 한가지이기 때문이다.  
-> str2에 끝에 있는 문자를 보고 한개씩 계속 제거하면 된다.

> B를 ABBA로 만드는 방법  
> A 추가 & 뒤집고 B 추가 & A 추가  
> (이 외에는 안됨)

---

### 13913 숨바꼭질 4

https://www.acmicpc.net/problem/13913

`사용한 자료구조 & 알고리즘:` BFS

`시간복잡도:` $O(N)$

`어떻게 접근했는지, 풀었는지 설명:`

기본적인 BFS 문제  
각 위치마다 visited 체크해주면서 queue를 이용해 방문해주면 최솟값을 찾을 수 있다.

      여기서 다음 위치를 탐색할 때  
      주어진 인풋의 범위는 10만을 못 넘지만  
      visited는 10만을 넘을 수 있다.  
      (이 경우가 더 빠를 수 있음)  
      -> 넉넉하게 20만으로 세팅했다.

---

### 14719 빗물

https://www.acmicpc.net/problem/14719

> 2차원 세계에 블록이 쌓여있다. 비가 충분히 많이 왔을 때, 블록 사이에 빗물이 고이는데, 고이는 빗물의 총량을 구하라.

사용한 알고리즘: 구현

시간복잡도: $O(n^2)$ (n <= 500)

(현재 위치에서 빗물이 고이는 조건 - 양쪽 블럭의 높이가 현재 위치보다 높아야 함)  
바닥부터 위로 한 줄씩 서치한다.  
현재 위치보다 높은 칸이 있다면, 다음으로 높은 칸 있는지 서치  
현재 위치보다 높은 칸이 없다면, 그대로 종료(더 이상 빗물이 고일 수 없음)

다음으로 높은 칸 서치할 때, 높은 칸 있다면, 이전 위치들에 빗물을 채움

> 이 문제를 풀 때, 설계와 구현을 분리해서 빨리 풀 수 있었다.  
> 그리고 input을 받는 변수는 대문자로 정의해서 구분하는 것이 좋을 것 같다.

---

### 15730 수영장 사장님

https://www.acmicpc.net/problem/15730

사용한 자료구조 & 알고리즘: BFS

시간복잡도: $O(NMH)$

어떻게 접근했는지, 풀었는지 설명:

높이 1 ~ 10000까지,  
모든 칸들을 탐색하면서 물을 채울 수 있는 확인하면 된다.
(높이 h 보다 낮은 칸들을 탐색하는데, 가장자리에 있는 칸이 h보다 작다면 물을 채울 수 없음)

> 논리 자체는 간단한 문제였지만,  
> 삽질을 많이 했다....

---

### 15949 Piet

https://www.acmicpc.net/problem/15949

`사용한 자료구조 & 알고리즘:` 구현, BFS

`시간복잡도:` $O(N^2)$

`어떻게 접근했는지, 풀었는지 설명:`

문제에서 제시한 조건들을 그대로 코드로 구현하면 되는 문제

여기서 헷갈린 만한 점은  
다음 칸으로 가기 위한 방향이 두개가 있다는 것(DP, CC)  
그리고 CC는 DP에 의해 결정되는 방향이라는 것(DP의 오른쪽/왼쪽)

이를 통일하기 위해 상수를 정해놨다.  
```
const int dr[4] = {-1,0,1,0}, dc[4] = {0,-1,0,1};
const int UP = 0;
const int LEFT = 0;
const int DOWN = 0;
const int RIGHT = 0;
```  
(curD+1)%4 는 반시계방향 회전 or 현재 방향의 오른쪽으로 가는 것이고,  
(curD+3)%4 는 시계방향 회전 or 현재 방향의 왼쪽으로 가는 것으로 정했다.  
이를 이용해 다음 방향을 정하는 것을 편하게 할 수 있게 되었다.

다음 블록 구하는 과정
1. 현재 블록에서 DP 기준에 해당하는 블록들을 구한다.
2. 구한 블록들 중에서 CC 기준에 해당하는 블록 1개를 구한다.
3. 마지막으로 구한 블록 1개의 위치와 DP 방향을 이용해 다음 블록의 위치를 구한다.
4. 다음 블록이 검정 or 불가능한 위치라면 (CC를 반대로 or DP 시계방향 회전)하고 다시 1번으로 돌아간다.

모든 방향에서 다음 블록을 구하는 것을 실패했다면 함수를 종료한다.  
다음 블록을 구했다면 다음 블록을 기준으로 위 과정을 반복한다.

    주어진 테스트 케이스를 가지고
    처음부터 끝까지 내가 원하는대로 동작하는지
    직접 출력하면서 디버깅 해보는게 중요한 것 같다.
    (직접 내가 짠 코드의 반례를 찾는 것은 쉽지 않기 때문)

    그리고 방향을 구하는 함수, 방향에 따른 기준에 해당하는지 체크해주는 함수 등
    기능을 분리해둠으로써 코드 작성을 편하게 할 수 있었다.

---

### 16194 카드 구매하기2

https://www.acmicpc.net/problem/16194

> n개의 카드팩의 가격이 주어진다. i(1~n)번째 카드팩에는 i개의 카드가 들어있다. 이때 n개의 카드를 구매하기위한 최솟값을 구하는 프로그램을 작성하라(딱 n개, n개 넘으면 안됨)

사용한 알고리즘: DP

시간복잡도: $O(n^2)$

이 문제도 위문제처럼, 완전 탐색으로 시작했다.

find(x)라는 재귀함수를 생성

find(x) = x개의 카드를 구매하기 위한 최솟값을 반환하는 함수

이때 점화식: $find(x) = min^x_{L=1}(card[L] + find(x-L))$

이때 함수를 그냥 실행하면 시간복잡도가 $O(n!)$인데 (그냥 대충 계산했을때)

이때 각 위치의 값을 저장해놓으면(메모이제이션)

시간복잡도가 $O(n^2)$으로 감소한다.

---

### 16566 카드 게임

https://www.acmicpc.net/problem/16566

`사용한 자료구조 & 알고리즘:` 이분 탐색, 분리 집합

`시간복잡도:` $O(KlogM)$

`어떻게 접근했는지, 풀었는지 설명:`

k번 탐색할 동안  
해당 숫자 보다 큰 수를 찾아서 출력하면 되는 문제  

이때 한번 쓴 숫자는 다시 못 쓴다.

이를 연결 리스트를 통해 편하게 제거해줄 수 있지만,  
리스트는 이분 탐색이 불가능하기 떄문에 시간초과가 발생한다.

따라서 벡타를 이용하는데,  
이때 한번 쓴 카드는 쓰지 못하게 표시해줘야 한다.

그리고 다음 카드가 계속 이전에 쓴 카드라서  
순차 탐색을 하면, 이때도 시간 초과가 발생할 수도 있다.

이떄 분리 집합을 적용한다.

```int findNext(int x)``` // 사용 가능한 x의 다음 인덱스를 반환

처음 next[i]는 i+1로 초기화 시키고,
visited[i]가 true라면 `return next[i] = findNext(next[i])`를 통해  
사용 가능한 카드를 바로 반환시킨다.

> 이 문제는 모든 경우에서 카드를 낼 수 있다는 조건이 있기 떄문에  
> 추가적으로 예외 처리를 해줄 필요가 없었다.
> 
> 마지막 인덱스 i의 next[i]는 i+1 == M 을 가리키기 떄문에  
> 이때 visited[i]를 사용하면 인덱스 에러가 발생할 수 있다.
> 
> 주의하자

      처음 문쪠를 볼 때
      "상대방이 본인이 낼 카드를 마음대로 조작할 수 있다"
      이 문장을 보고 당황했다.
      그런데 이 말은 결국 내가 가지고 있는 카드와, 
      상대방이 가지고 있는 카드가 다르다는 것 만을 의미하는 말이다.

      이런 문장 하나하나에 당황하지 말자

---

### 16637 괄호 추가하기

https://www.acmicpc.net/problem/16637

> n개의 문자로 이루어진 수식이 주어졌을때, 괄호를 추가하여 얻을 수 있는 최댓값을 구하시오<br>
(연산자 우선순위는 없다 - 그냥 왼쪽에서 오른쪽으로 계산)<br>
(괄호 안에 연산자는 1개만, 괄호 중첩은 불가능)

사용한 알고리즘: 브루트포스(그냥 쌩 구현)

시간복잡도: $O()$

처음에는 DP처럼 접근했다.<br>
앞의 식이 뒤의 식에 영향을 안끼친다고 생각해서

그런데 이 접근은 틀렸다.

뒤를 먼저 계산하는건 전체에 괄호를 추가하는 것과 같다 - 이는 잘못된 접근

그냥 무식하게 풀어야 한다.

dfs 방식으로 괄호 넣었다 뺐다 하면서 모든 경우의 수를 체크했다.

인풋 범위가 작아서 가능한 알고리즘

---

### 16638 괄호 추가하기 2

https://www.acmicpc.net/problem/16638

`사용한 자료구조 & 알고리즘:` 구현, 백트래킹, 덱큐

`시간복잡도:` $O()$

`어떻게 접근했는지, 풀었는지 설명:`

괄호를 추가하는 함수 (1)  
추가한 괄호를 바탕으로 전체 식을 계산하는 함수 (2)  
두가지를 구현했다.

괄호를 추가할 때는, 조합을 이용해서 구현했다.  
여기서 괄호는 붙어있으면 안된다는 조건만 추가해주면 간단하게 구현 가능하다.

1번 함수가 끝날 때마다, 2번 함수를 호출한다.

2번 함수의 구현이 조금 복잡했다.
우선순위가 괄호, * 연산, +- 연산 이기 떄문에  
총 for문을 3번 해줘야 했다.

여기서 덱큐를 이용했다.  
1. 맨 처음에는 괄호를 탐색한다.  
   ()라면, 양 옆의 숫자를 계산해서 dq에 push_back  
   ()가 아니라면, 다음 숫자를 push_back
2. 1번에서 저장한 dq를 바탕으로 *를 연산해준다.  
   (처음에 dq.front()를 dq2에 push)  
   *라면, dq2.back()과 dq[cnt]를 계산해서, dq2에 push_back & cnt++  
   *가 아니라면, dq[cnt]를 dq2에 push_back & cnt++  
   ()라면, continue
3. dq2를 바탕으로 += 연산을 진행한다.  
   \* or (), continue  
   +-라면, dq2.front()와 dq[1]을 계산 & dq2.pop_front() * 2 & dq2.push_front()
4. 마지막으로 dq2.front()를 반환



      연산 순서를 고려해야 하는 점이 까다로운 문제였다.
      컨테이너를 이용해서 그나마 깔끔하게 풀 수 있었다.

---

### 16926 배열 돌리기 1

https://www.acmicpc.net/problem/16926

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(n^2*r)$

어떻게 접근했는지, 풀었는지 설명:

현재 배열 위치에서 다음 위치를 찾는 규칙을 찾으면 금방 풀린다.

> 배열 돌리는 문제를 너무 안풀어서,  
> 이런 문제들을 많이 풀어봐야겠다.

---

### 16927 배열 돌리기 2

https://www.acmicpc.net/problem/16927

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(n^2 * r)$

어떻게 접근했는지, 풀었는지 설명:

16926번 문제에서 약간의 아이디어만 추가한 문제

배열을 회전하는데 회전해야 하는 횟수가 너무 크면 최적화를 해야 한다.

    4*5 배열을 10000번 회전한다면,
    할 수는 있지만, 너무 비효율적
    회전하는 횟수를 줄인다.

    가장 외곽라인은 14번마다 값이 반복된다. 
    그리고 안쪽라인은 6번마다 값이 반복된다.
    => R %= 2*(N+1-2*k) + 2*(M+1-2*k)
    (k는 안쪽라인으로 들어가는 횟수)

---

### 16935 배열 돌리기 3

https://www.acmicpc.net/problem/16935

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(N*M*R)$

어떻게 접근했는지, 풀었는지 설명:

배열 좌우반전, 상하반전, 90도 시계방향/반시계방향 회전,  
4등분으로 나눠서 시계방향/반시계방향 회전을  
코드로 구현하면 끝나는 문제

좌우반전 - [r][M-c-1] = [r][c]  
상하반전 - [N-r-1][c] = [r][c]  
90도 시계방향 회전 - [c][N-r-1] = [r][c]  
90도 반시계방향 회전 - [M-c-1][r] = [r][c]  

> 여기서 헷갈린 부분
> 
> 1  
> 90도 회전할 때 N과 M이 다를 수가 있다.  
> 그래서 처음에는 회전시키고 앞부분의 빈공간을 땡겨야한다고 생각했는데,  
> 그럴 필요가 없었다.  
> (그냥 N과 M만 swap 해주면 끝남)  
> (만약 N과 M을 더 큰 값으로 통일 시킨다면 떙겨줘야 한다)
> 
> 2  
> 4등분으로 나눠서 회전시키는 부분에서  
> r은 0부터 N/2 전까지만 탐색해줘야 하고,  
> c는 0부터 M/2 전까지만 탐색해줘야 한다는 것을 처음에 놓쳤다.
> 
> -> 항상 테스트 케이스를 잘 확인하자

---

### 16986 인싸들의 가위바위보

https://www.acmicpc.net/problem/16986

사용한 자료구조 & 알고리즘: 구현, 백트래킹

시간복잡도: $O(9!)$

어떻게 접근했는지, 풀었는지 설명:

그냥 게임을 진행한다.  
first or second가 지우라면, 지우가 낼 수 있는 손동작을 하나씩 다 내보면서 재귀함수를 실행한다.  
(재귀함수의 결과가 true라면 그대로 종료, false라면 다음 손동작을 내고 재귀 실행)  
f or s 모두 지우가 아니라면, 이미 있는 족보대로 게임을 진행한다.

(지우는 손동작이 겹치면 안되기 떄문에 visited로 체크해줬다)

게임을 진행하다가, 지우의 승수가 K라면 true, 지우가 아닌 다른 사람의 승수가 K라면 false

> 이런 방법도 가능할 것 같다.
> 
> 먼저 지우의 가위바위보 순서를 정해놓고, 게임을 진행하는 것  
> (훨씬 깔끔한데?)  
> 
> f or s가 지우인지 체크안해도 된다.  
> 그냥 미리 정해놓은 족보대로 게임 진행하면 되니까

> 이 문제에서 놓친점
> 
> 가위바위보 순서  
> 나는 이긴 사람, 남은 사람 순서로 진행하는 줄 알았는데  
> 지우,경희,민호 순으로 게임을 진행하는 것이었다.  
> (이것때문에 1시간 까먹음)
> 
> 재귀함수 테스트  
> 재귀함수 테스트를 cout로 일일이 확인하는 과정이 너무 오래걸렸다.
> 
> 파라미터 범위 벗어남  
> 파라미터의 값이 배열의 범위를 벗어나서 런타임 에러  
> -> assert를 이용해 체크해줘야 한다.

> 이 문제를 통해 느낀것
> 
> 1. 문제를 제대로 읽자(테스트 케이스도 제대로 보자)  
>   내가 이해한 룰대로 테스트 케이스를 따라가 보자 - 제대로 되는지
> 2. enum을 활용해보자(숫자로는 귀찮을때가 있다)
> 3. assert를 활용해보자(테스트 빠르게 해준다)
> 4. 재귀함수 테스트 케이스는 분석이 너무 어렵다.

---

### 17135 캐슬 디펜스

https://www.acmicpc.net/problem/17135

> n*m 크기의 보드 위에 몬스터가 있다.  
> n+1 행에 위치한 3명의 궁수가 몬스터를 잡을 수 있다.
> 공격 가능 거리 D  
> (거리 가까운 순, 가장 왼쪽에 있는 순 우선순위)  
> 모든 궁수가 동시에 공격한 뒤 몬스터가 아래로 한칸 이동
> 공격과 이동을 반복한다.
> 
> 궁수의 공격으로 제거할 수 있는 적의 최대 수를 출력하는 문제

사용한 알고리즘: 구현 & BFS

시간복잡도: $O(n^6)$  
(n<=15 가능)

(궁수 3명을 어떻게 배치할지 - 조합(백트래킹))

1 -  궁수 3명을 배치한다.  
2 -  한 라운드씩 진행  
2-1 - 궁수가 적을 찾는다.  
2-2 - 찾은 적들 죽인다.
2-3 - 몬스터 한 칸씩 이동

위 과정을 반복하면서 최댓값을 구한다.

> 무난한 구현문제였지만, 궁수들의 공격 우선순위를 놓쳐서 한번 틀렸다.  
> (처음에는 일반적인 BFS로 풀었음)
>
> 항상 놓치고 있는 건 없는지 확인하자.  
> 처음부터 헷갈릴 만한 것들을 체크해 놓자.

---

### 17136 색종이 붙이기

https://www.acmicpc.net/problem/17136

> 10x10 크기의 보드가 있고<br>
1x1, 2x2, 3x3, 4x4, 5x5 크기의 색종이들이 5장씩 있다<br>
10x10 보드에서 1인 칸을 채우기 위해 색종이를 사용하는데<br>
색종이를 최소 몇개로 보드를 채울 수 있는지 구하라<br>
불가능하면 -1 출력

사용한 알고리즘: 백트래킹, 특이한 dfs

시간복잡도: $O()$

처음부터 무조건 큰 크기의 색종이를 붙이는게 최적해가 되지 않는다.

따라서 5x5 색종이가 가능하면, 5x5도 붙여보고, 그것보다 작은 크기의 색종이도 붙여보면서 일일이 값을 비교해야 한다.

따라서 그리디는 불가능하고, 백트래킹 알고리즘이 가능하다.<br>
(이전에 구한 해보다, 현재 값이 크거나 같다면 그대로 종료)<br>
(무조건 배열의 다음 위치부터 찾는다)

> 여기서 하나 실수한 것이 있는데,<br>
> 백트래킹은 bottom-up만 가능한데, 나는 처음에 top-down으로 접근해서 시간이 많이 지체됐다.<br>
> 그리고 하나 놓친 부분이 있는데, 무조건 배열의 다음 위치부터 찾는걸 놓쳐서<br>
> 처음 시도했을 때 시간초과가 났다.

---

### 17142 연구소 3

https://www.acmicpc.net/problem/17142

> nxn 보드에 비활성화된 바이러스가 있다<br>
여기서 m개를 활성화시켜서 벽을 제외한 모든 빈칸을 바이러스로 채우려고 한다.<br>
바이러스가 1칸 퍼지는데 1초걸릴때, 모든 빈칸이 바이러스로 덮이는 최소시간은?<br>
(비활성화 바이러스가 활성화 바이러스를 만나면 활성화 바이러스로 바뀐다)<br>
(m <= 10)

사용한 알고리즘: bfs & 구현

시간복잡도: $O(_{10}C_5*n^2)$

1. 전체 바이러스가 k개라면(k>=m), 여기서 m개를 골라야 한다. - 최대 $_{10}C_5$
2. bfs를 이용해 바이러스가 퍼지는 시간을 구한다 - $n^2$

처음 제출했을 때는, 시간초과가 났다. <br>
그 이유는 2번을 구현할 때, 매 round마다 바이러스가 모두 퍼졌는지 확인을 해야하는데, 처음에는 이 작업을 모든 칸을 확인했다.(빈칸이 있는지)<br>
그리고 벽때문에 바이러스가 퍼질수 없는지도 확인해야 해서 같이 검사했다.<br>
(이는 이전 보드와 현재 보드 값을 비교했다 - 같은지 다른지)
여기서 시간복잡도가 너무 높게 나왔다.<br>

그래서 모든 칸을 검사하지 않고, 처음 빈칸의 개수를 세주고, 매 round마다 빈칸의 개수가 0이면 바로 탈출하도록 세팅했다.<br>
그리고 한번이라도 바이러스가 퍼졌다면 false로 초기화된 flag에 true를 줬다.

>flag=true // 바이러스가 최소한칸은 퍼졌다. -> 아직 더 퍼질수 있음<br>
flag=false // 한칸도 퍼지지 않았다. -> 더이상 퍼질수 없다.
>   
>빈칸의 개수 > 0 && flag==false<br>
>=> 모든 빈 칸에 바이러스를 퍼뜨릴 수 없다.

bfs 구현은 많이 해봐서 무난했지만, 1번을 구현하는 것이 어색했다. - 시간 많이 잡아먹음

그리고 1번을 수행할때마다, 2번에 필요한 변수들을 초기화해주는것이 많이 헷갈렸다.

문제를 자주 풀어야 익숙해진다.

---

### 17143 단어 뒤집기2

https://www.acmicpc.net/problem/17413

> 문자열이 주어졌을 때, 단어들을 뒤집어서 출력하는 문제(태그와 공백으로 구분, 태그는 그대로 출력)  
<int>fds asdw<max> => <int>sdf wdsa<max>

사용한 알고리즘: 그냥 문자열

시간복잡도: $O(n)$

문자 한개씩 탐색하는데,  
공백이나 태그라면 그대로 출력한다.

여기서 그냥 단어가 나왔다면, 단어의 끝을 찾아서(다음 문자가 공백이나 태그일 때), 단어의 끝부터 시작까지 반대로 출력한다.

문제가 생긴것은, cin >> str; 은 공백을 받지 않기 때문에, 다른 메서드를 써야 했다.  
getline(cin, str) 메서드를 사용해서 문제를 해결했다.

---

### 17298 오큰수

https://www.acmicpc.net/problem/17298

`사용한 자료구조 & 알고리즘:` 스택

`시간복잡도:` $O(n)$

`어떻게 접근했는지, 풀었는지 설명:`

현재 위치보다 오른쪽에 있는 수들 중에서,  
현재 위치에 있는 수보다 큰 수이고 가장 왼쪽에 있는 수를 찾는 문제

스택을 이용했다.

1. input[s.top()] < v[i] => result[s.top()] = v[i] && s.pop()
   (위 과정을 s가 비거나 조건에 해당 안될떄까지 반복)
2. s.push(i)

위 과정을 반복한 후, 현재 s에 남아있는 인덱스들에는 -1을 넣어준다.  
그리고 결과를 출력하면 된다.


---

### 17406 배열 돌리기 4

https://www.acmicpc.net/problem/17406

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(6! * 6 * 50^2)$

어떻게 접근했는지, 풀었는지 설명:

배열을 돌리는 입력의 순서를 임의로 정할 수 있다. -> next_permutation  
(그냥 순열)

1. 임의의 순서 정함 - 6!
2. 정한 순서대로 배열 돌린다 - 6 * 50^2
3. 2번 결과 얻는다. - 50^2
4. 23을 1번의 모든 경우의 수만큼 반복

---

### 17470 배열 돌리기 5

https://www.acmicpc.net/problem/17470

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(R)$ (R <= 2000000)

어떻게 접근했는지, 풀었는지 설명:

주어진 회전 명령 개수대로 배열을 돌리면  
시간복잡도: $O(N^2*R)$ - 시간 초과  
명령을 최적화하는 작업이 필요하다.

6개의 명령이 있는데, 각 명령들의 특징은  
`한 부분 배열이 다른 부분 배열에 영향을 주지 않는다`  
(부분 배열의 위치 & 반전/회전 정보만 바꾸면 됨)
-> 각 부분 배열을 독립적으로 계산가능하다.  
-> 배열을 압축하여 계산할 수 있다.

부분 배열의 개수 = 2x2  
-> 2x2 배열로 R개의 연산을 진행한 후  
-> 2x2 배열의 결과를 input 배열에 적용한다.

그리고 부분 배열 내에서도, 반전 & 회전 연산을 해야 한다.  
-> 2*2 반전&회전 정보를 담은 배열도 R개의 연산 거치면 된다.
-> 이 정보대로 input 배열에 반전&회전 연산 진행

부분 배열의 위치에 대한 정보 (1)  
부분 배열 내에서 반전&회전 정보 (2)  
-> 두개의 2*2 배열이 필요하다.

> 이 문제는 5,6번 명령이 N/2 * M/2 인 4개의 부분 배열로 나누기 때문에  
> 부분 배열 위치에 대한 정보에 대한 배열의 크기가 2*2 인 것  
> (만약 부분 배열의 개수가 많아진다면, 위치 정보에 대한 배열의 크기도 커져야 한다)
> 
> (부분 배열 개수가 많아져도, 반전&회전 정보를 담기 위한 배열의 크기는 2*2로도 충분할 듯)

문제 푸는 순서
1. R개의 명령을 2*2 배열 (1), (2)에 적용한다.  
   1번 - 1,2 배열 상하반전  
   2번 - 1,2 배열 좌우반전  
   3번 - 1,2 배열 시계방향 90도 회전  
   4번 - 1,2 배열 반시계방향 90도 회전  
   5번 - 1번 배열만 시계방향 90도 회전  
   (부분 배열이 회전 하지는 않음, 위치만 옮김)  
   6번 - 1번 배열만 반시계방향 90도 회전  
   (부분 배열이 회전 하지는 않음, 위치만 옮김)
2. 1번 배열 위치대로 전체 배열의 위치를 옮김
3. 2번 배열 정보대로 전체 배열 반전&회전 적용  
    12  
    34  
    => 안 움직여도 됨  
    21  
    43  
    => 좌우반전  
    31  
    42  
    => 시계방향 90도 회전  
    ...

시간복잡도: $O(N^2+R)$ = O(R)

> 오래걸린 이유  
> 1. 부분 배열의 위치를 옮기는 건 생각해냈지만,  
>   부분 배열 내의 반전&회전을 어떻게 적용할지 시도를 못했다.  
>   -> 구글링으로 반전&회전 정보에 대한 2x2 배열 적용 방법 확인
> > 나는 그냥 수학적으로만 접근했음, but (3,1 명령 != 1,3 명령) 이라서 수학적으로 접근 불가능
> 2. 행과 열의 크기가 달라서 회전할 때 부분 배열 인덱싱 작업이 헷갈렸다.  
>    -> 회전하면 r과 c가 바뀌기 때문에 input R,C도 바꾸면 된다.  
>    (단순하게 생각해)

> 이 문제를 통해 얻은 것
> 
> 반전 & 회전 연산을 그대로 전체 배열에 진행하지 않고,  
> 2*2 배열에 진행 한 후, 전체 배열에 적용하면 최적화될 듯

---

### 17472 다리 만들기 2

https://www.acmicpc.net/problem/17472

사용한 자료구조 & 알고리즘: bfs, mst

시간복잡도: $O()$

어떻게 접근했는지, 풀었는지 설명:

1 - 각 섬을 숫자로 구분 & 보드에 표시 - bfs  

2 - 각 섬으로부터 다른 섬까지의 모든 최단거리를 구한다. - bfs, 그냥 구현  
2-1 거리가 1이라면 break  
2-2 저장된 거리가 0이라면 업데이트  
2-3 0이 아니고 이전 값보다 현재 값이 작다면 업데이트

3 - 모든 섬을 포함하는 최단거리를 구한다 - mst(프림)  
(모든 섬이 포함되었는지 체크)

> 여기서 놓친 부분
> 
> 2-3 조건을 코드로 구현하는 걸 깜빡했다
> 
> 3번을 풀때 mst를 생각못했다.  
> (그리고 mst를 오랜만에 풀어서 잊었음)

---

### 17609 회문
> 문자열이 주어졌을때 그 문자열이 회문인지, 유사 회문인지, 일반 문자열인지 구하는 문제
> (회문 = 대칭인 문자열, 유사 회문 = 문자 한개 뺐을때 대칭인 문자열)

투포인터를 이용한 문자열 문제

문자열의 양쪽끝에 포인터를 둔 후, 해당 위치의 문자가 같다면 한칸씩 중간으로 옮긴다.

모든 위치의 문자를 통과하면 회문

해당 위치의 문자가 다르다면 세가지 경우의 수가 있음
1. 왼쪽 포인터의 위치를 +1 해주고 다시 진행, 전부 통과하면 유사 회문
2. 오른쪽 포인터의 위치를 -1 해주고 다시 진행, 전부 통과하면 유사 회문
3. 1,2 둘다 실패하면 일반 문자열

---

### 17779 게리멘더링2

https://www.acmicpc.net/problem/17779

사용한 알고리즘: 구현

시간복잡도: $O(n^6)$  
n <= 20 이라 가능

x y, d1, d2를 세팅하고, 각 구역의 인구 수를 구한다.

구현 과정이 문제에 그대로 써있었다.  
그런데 이를 바로 보지 않고, 내가 나름대로 풀려고 했다. <- 시간 지체 됨

> 문제에 써 있는 과정을 자세히 보고, 이를 활용할 수 있다면 그대로 활용할 수 있어야 한다.  
> 항상 디버깅 제대로 하자

---

### 17780 새로운 게임

https://www.acmicpc.net/problem/17780

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(k^2 * 1000)$

어떻게 접근했는지, 풀었는지 설명:

그냥 문제에 나온 설명대로 구현하면 된다.

여기서 문제는  
말은 같은 칸에 겹칠 수 있고,  
겹칠때는 순서가 있다는 것이다.  
(그리고 빨간색으로 움직이면 순서를 뒤집어야 함)

이를 처리하기 위해,  
보드의 각 칸을 벡터로 선언해 일일이 push/pop 해줬다.

그리고 빨간색과 흰색으로 움직일때의 차이점은,  
현재 말들의 순서를 뒤집냐 안뒤집냐이기 때문에,  
이 부분만 if문으로 처리해주고, 다른 부분은 같이 처리할 수 있다.

그리고 말의 상태를 표현하는 자료구조가,  
2차원 배열과 벡터 두가지이기 때문에,  
두가지 모두 상태를 변경해줘야 한다.

> 만약 말이 움직이려고 하는 칸이 파란색일때, 반대로 움직여야 하는데,  
> 이떄 반대로 움직이는 경우를 모두 코드로 구현했다면 시간이 매우 오래 걸렸을 것이다.
> 
> 나는 반대 칸이, 칸을 벗어나거나 파란색일때는 그대로 종료하고,  
> 흰색/빨간색 이라면 말을 움직이는 메서드를 한번더 호출해주는 것으로 처리했다.  
> (이렇게 함으로써, 코드가 많이 줄었다)
> 
> 진짜 기능의 분리가 중요한 것같다.

> 약간 헷갈린 점
> 
> 나는 말하나를 처리할 때,  
> 새로운 변수에 call by value로 입력 했기 때문에,
> 
> 컨테이너에 있는 말의 상태를 변경해도,  
> 새로운 변수에는 입력되지 않았다.
> 
> call by value, call by reference를 항상 생각하자

---

### 17837 새로운 게임 2

https://www.acmicpc.net/problem/17837

`사용한 자료구조 & 알고리즘:` 구현, 시뮬레이션

`시간복잡도:` $O(1000 * K)$

`어떻게 접근했는지, 풀었는지 설명:`

인풋의 범위가 매우 작기 때문에  
어떻게든 구현하면 시간복잡도는 통과할 수 있다.

대신 구현하는게 조금 복잡하다는게 함정

1. 말이 번호순으로 이동하는데,  
   움직이려는 위치에 이미 말이 있다면,  
   그 말위에 현재 움직이는 말을 쌓아야 한다.
2. 움직일 떄 현재 말 위에 다른 말들이 있다면,  
   위의 말들도 다 같이 움직여야 한다.

위 내용을 구현하기 위해 현재 말의 정보를 두가지로 표현했다.

1. `vector<pair<int,int>> infor[n][n]` - (r,c) 위치에 어떤 말들이 놓여있는지
   {말의 번호, 말의 방향}
2. `vector<pair<int,int>> loc` - 각각의 말들이 어떤 위치에 있는지  
   {행 번호, 열 번호}, 각각의 위치가 각각의 번호가 된다.

위 두가지 정보를 이용해 문제를 풀었다.

`bool moveNext(int index, bool flag)`: index 번호의 말을 다음 위치로 이동시키는 함수  
(말의 번호, 다시 실행됐는지) 를 파라미터로 받는다. 
말이 4개 이상 쌓였는지를 반환한다.

> 다시 실행됐는지 란?
> 
> 다음 위치가 파란색이라면 반대방향으로 이동해야 하는데  
> 이때 함수를 한번더 실행해줌으로써 최적화를 했다.
> 
> 처음 실행할 때 -> `moveNext(index, false)`  
> 다음 위치가 blue라서 실행할 때 `moveNext(index, true)`

다음 위치가 blue  
-> flag == true -> return false;  
-> flag == false -> return moveNext(index, true);  
다음 위치가 white  
-> 말들을 그대로 옮긴다.  
다음 위치가 red  
-> 말들을 뒤집어서 옮긴다.



---

### 18405 경쟁적 전염

https://www.acmicpc.net/problem/18405

사용한 자료구조 & 알고리즘: 구현, BFS

시간복잡도: $O(n^3)$

어떻게 접근했는지, 풀었는지 설명:

그냥 일반적인 bfs에 아이디어를 살짝 더한 문제

바이러스를 S초 동안 퍼뜨린다면, 시간복잡도가 O(n*n*S)라서 시간초과가 발생하는데,  
여기서 이 문제만의 특징을 이용해 최적화를 할 수 있다.

바이러스가 모든 보드에 퍼지는데 S초가 걸리지 않는다는 것  
(최악의 경우에도 2n 초 정도 걸린다)

따라서 1초 동안 바이러스를 퍼뜨렸을 때, 만약 이전과 보드의 상태가 똑같다면,  
이는 더 퍼질 수 없다고 판단하여 그대로 프로그램을 종료하면 된다.

---

### 19237 어른 상어

https://www.acmicpc.net/problem/19237

사용한 알고리즘: 구현

시간복잡도: $O(1000 * n^2)$

과정
1. 상어 이동방향 찾음 & 이동
2. 상어 자리에 냄새 뿌리고, 기존 냄새들 -1

사용한 방법

1. 상어에 대한 표현을 두가지로 해줬다.  
2-1. 2차원 배열에서 위치  
2-2. 벡터로 상태 표현

2. 앞번호 상어를 먼저 움직여 주면, 뒷 상어부터는 겹치는 걸 체크해 주지 않아도 된다. -> 어차피 겹치면 앞 번호가 사니까

> 어떤 객체를 두가지 상태로 표현한다면,  
> 상태가 변경될 때 양쪽다 변경될 수 있도록 주의해야 한다.  
>
> 항상 이동할 때 기존것 지워주고, 이동한 지점에 표시를 해줘야 한다.
>
> 항상 시작하는 시점과 끝나는 시점을 주의하자

---

### 19238 스타트택시 (삼성 기출)

https://www.acmicpc.net/problem/19238

> nxn 보드 위에 1개의 택시와 m명의 손님이 있다.<br>
각각의 손님은 목적지를 가지고 있다.<br>
택시는 모든 손님을 해당 위치에 태워서 목적지까지 옮겨야한다.<br>
(모든 손님의 위치와 목적지는 겹치지 않는다 & 택시는 한명만 태울 수 있다)<br>
이동하다가 연료가 부족해지면 -1을 출력하고 종료<br>
연료는 손님 태울때 & 목적지 이동할때 소모됨 & 목적지 도착하면 출발지부터 목적지까지의 거리의 두배를 연료료 채운다.<br>
>
> 손님 태울때 우선순위는 거리작은것,행작은것,열작은것 이다.

사용한 알고리즘: 쌩 구현, bfs

시간복잡도: $O(m*n^2)$

총 3단계로 구분했다.
0. 각 손님들이 목적지까지 가는데 걸리는 거리를 계산한다. & 각 배열에 저장
1. 택시가 현재 위치에서 가장 가까이 있는 손님을 찾는다. & 그 위치로 택시 이동
2. 해당 손님의 출발지에서 목적지까지 이동

12 과정을 반복하는데 중간에 연료가 부족해지면 바로 -1을 출력하고 종료했다.

0의 시간복잡도 - $O(m*n^2)$ - 손님은 m명, 손님마다 bfs로 거리를 계산했음<br>
1의 시간복잡도 - $O(n^2)$ - 한명찾을때 bfs 이용<br>
2의 시간복잡도 - O(1) - 이미 출발지와 목적지의 거리를 계산해놓았기 때문에 상수시간

    여기서 놓친 반례가 한개 있었다.

    손님의 출발지와 목적지가 벽때문에 연결되어있지 않을때를 처리하지 못했다.
>
    이 문제에서 생길 수 있는 반례

    1. 택시의 시작지점에 손님이 있을 수 있다.
    2. 택시가 손님을 찾는 과정에서 우선순위를 놓칠 수 있다.(최단거리, 행이 작게, 열이 작게)
        여기서 단순히 dr[4],dc[4]의 순서를 정한다고 우선순위가 해결되지 않는다.(왼왼왼 보다 오오위가 우선순위)
        -> 그냥 모든 배열에 접근해서 거리,행,열을 체크해야 한다.
    
    3. 택시가 손님에게 갔다가 목적지를 가는 과정에서 연료가 떨어질 수 있다.
        손님에게 갈때 & 출발지에서 목적지로 갈때 - 두가지 전부 체크해야 한다.
    4. for문에서 bfs를 사용할때 queue와 visited 초기화를 제대로 안 했을 수 있다.
>
    항상 반례를 생각하자

---

### 19539 사과나무

https://www.acmicpc.net/problem/19539

사용한 자료구조 & 알고리즘: 그리디

시간복잡도: $O(n)$

어떻게 접근했는지, 풀었는지 설명:

yes or no를 구분하는 기준

1 - 전체 크기의 합이 3으로 나눠 떨어지지 않으면 NO

여기서 3으로 나눴을 때의 몫은, 물뿌리개를 뿌리는 일 수이다.

(ex - 3 5 1 -> 3일동안 뿌려야 가능 = 9 / 3)

-> 2짜리 물뿌리개를 뿌리는 횟수도 일 수와 동일해야 한다.

-> 2를 뿌릴 수 있는 전체 횟수가 일 수보다 크거나 같으면 YES, 아니면 NO

2를 뿌릴 수 있는 전체 횟수가 일 수보다 커도 되는 이유
-> 2 = 1 + 1 -> 2를 한 번 안뿌리고 1을 두번 뿌린다고 생각하면 됨  
-> 2를 뿌리는 전체횟수와 일 수가 같아짐

> 코드로 구현하는 것은 문제가 없지만,  
> 위 아이디어를 생각하는게 힘들었다.



---

### 19640 화장실의 규칙

https://www.acmicpc.net/problem/19640

`사용한 자료구조 & 알고리즘:` 우선순위 큐

`시간복잡도:` $O(nlogn)$

`어떻게 접근했는지, 풀었는지 설명:`

만약 브루트포스로 푼다면,  
매번 화장실을 이용할 사람을 고를떄마다 M개의 줄을 모두 점검해야 한다.  
-> $O(n^2)$ -> 시간 초과

결국 M개의 줄의 선두만 확인하면 되므로,  
이를 우선순위 큐를 이용해 구현한다.

`pririryt_queue<Infor> pq;` // M개의 줄의 선두에 있는 원소들을 저장

여기서 pq의 정렬 조건을 연산자 오버로딩을 통해 구현했다.  
d 내림차순 -> h 내림차순 -> m 오름차순  
(d: 근무 일수, h: 화장실이 급한 정도, m: 줄 번호)

> 이때 m = i % M;

pq의 top이 지금 화장실을 이용할 사람이기 떄문에,  
해당 원소를 pop 시키고,  

해당 원소의 i(번호) + M(줄 개수) 가 N보다 작다면  
(해당 줄에 다음 사람이 있다)  
그 사람을 pq에 push 해준다.

이렇게 계속 pop & push 해주면서  
현재 pop할 사람의 i가 K라면  
결과를 출력하고 프로그램을 종료한다.

    우선순위 큐를 통한 접근은 좋은 접근이지만
    하나 놓친 것이 있었다.

    pq의 top을 먼저 pop 해주고, 그 다음 원소를 push 해줘야 하는데,
    나는 top 객체를 복사하는것이 귀찮아서 먼저 push 해주고, pop 해줬다.
    이때 push 하는 원소가 top으로 갈 수 있으므로,  
    이떄 무한루프로 인해 시간초과가 났다.

---

### 20055 컨베이어 벨트

https://www.acmicpc.net/problem/20055

> 2n 길이의 컨베이어 벨트가 있다.(0~2n-1)<br>
벨트가 한칸움직이면 그 위의 로봇도 같이 움직이는데, n-1번 위치의 로봇은 다음칸으로 움직이지 않고 벨트에서 내린다.
>
> 1. 모든 벨트가 한칸씩 움직인다.
> 2. 벨트위의 모든 로봇이 다음 칸으로 움직인다.
>   다음 칸으로 움직인다면, 해당 칸의 내구도는 1 감소한다. (내구도가 0이라면 다음칸으로 못감)
> 3. 0번 위치에 새로운 로봇을 올린다.(0번 위치의 내구도가 1 이상이고, 로봇이 그 위치에 없을 때)
> 4. 내구도가 0인 벨트가 k개 이상이 될때까지 123번 과정을 진행한다.
>
> 위 과정이 종료되었을때, 몇번째 단계가 진행중이었을까?

사용한 알고리즘: 구현

시간복잡도: $O()$

벨트가 한칸씩 움직이는걸 표현하기 위해, 자료구조로 deque를 사용했다.

    한칸움직이는걸 pop_back()과 push_front()로 구현, 
    모든 데이터 접근을 위해 queue가 아닌 deque 사용

로봇들의 위치도 자료구조로 표현해야 하는데, 이를 역시 deque를 사용했다.

    로봇들은 선입선출이라 queue도 가능할 것같지만, (1번과정을 진행할때) 모든 로봇의 값을 +1 해줘야 하기때문에,
    인덱스 접근이 가능한 deque를 사용했다.

(위의 두 데이터 모두 선입선출이지만, queue는 인덱스 접근을 못하기 때문에, deque를 이용했다)

그냥 쌩 구현이지만, 중간중간 놓진 부분이 있어, 예상보다 시간이 조금 더 걸렸다.

2번 과정에서 n-1번 칸의 로봇은 다음칸으로 가지 못하고, 내려야 한다. - 처음에 이 과정을 if문으로 처리해주지 못했다.

그리고 로봇을 내리고 나서, 다음 로봇들의 위치를 +1 해줘야 하는데,<br>
로봇을 내렸다 해도, 해당 로봇은 제거되었기 때문에 다음 로봇들의 위치는 인덱스 0부터 시작하는걸 깜빡했다.

3번에서 0번에 올릴때도, 0번 위치에 로봇이 있는지 체크해줘야 하는걸 깜빡했다.

    deque의 모든 데이터를 순차탐색할때, 0번 데이터를 제거했다면, 다음 데이터의 위치는 0번이 된다.
    이를 조심하자

---

### 20056 마법사 상어와 파이어볼(삼성기출)

https://www.acmicpc.net/problem/20056

> 생략

사용한 알고리즘: 구현&시물레이션

시간복잡도: $O()$

그냥 문제를 제대로 읽고 잘 설계해서 구현하는 문제

여기서 놓친 부분이 있었음
1. 속력이 n보다 클때, 다음 위치가 -n보다 작을수도 있었다. -> +n으로는 해결이 안됨
2. 그렇다고 처음부터 속력을 %n 해주면 무조건 틀린다. -> 나중에 새로운 파이어볼을 구할때 속력을 나눠줘야 하는데, 이때 나머지가 달라짐 -> 틀림
>
    나머지 제대로 체크하자

    (A+B) % C = (A%C + B%C) % C
    (A-B) % C = (A%C - B%C) % C
    (A*B) % C = (A%C * B%C) % C

    (나누는건 안된다)

---

### 20061 모노미노도미노 2

https://www.acmicpc.net/problem/20061

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O()$

어떻게 접근했는지, 풀었는지 설명:

1. 블록 옮기고
2. 한줄 채워진 행/열 있다면 점수+1 & 한칸씩 땡겨주기
3. 연두/하늘 보드에 블럭 있다면 한칸씩 땡겨주기
4. 1.2.3 블럭 개수만큼 반복
5. 점수 계산

문제 읽는게 귀찮을 뿐이지, 써놓은 대로 코드 작성하면 풀수 있는 문제

> 여기서 핵심은 각 기능별로 메서드를 구분해 처리하는게 빠르게 할 수 있는 방법

---

### 20210 파일 탐색기

https://www.acmicpc.net/problem/20210

사용한 자료구조 & 알고리즘: 문자열, 정렬

시간복잡도: $O(nlogn * l)$ (l = 문자열의 길이 <= 100)

어떻게 접근했는지, 풀었는지 설명:

정렬은 algorithm 라이브러리의 sort를 사용

결국 두 문자를 비교하는 것이 이 문제의 핵심

두 문자 비교 case
1. 한쪽이 문자, 다른쪽은 숫자 -> 문자가 더 크다.
2. 둘다 문자 -> 문자 비교
3. 둘다 숫자 -> 숫자 비교

문자 비교는 간단하니 생략

숫자 비교  

1. 0을 제외한 자릿수 체크 -> 자릿수 큰 쪽이 더 큰 것
2. (자릿수 같은 상태) 두 숫자 한개씩 비교 -> 숫자 큰 쪽이 더 큰 것
3. (모든 수가 같다) 두 숫자의 길이를 비교한다.

1번 케이스 - 0123 vs 00012 - 0123이 더 크다.

2번 케이스 - 01234 vs 01244 - 01244가 더 크다.

3번 케이스 - 00012 vs 12 - 00012가 더 크다.

> 문자를 일일이 비교하는 것이 매우 귀찮았던 문제  
> 하지만 어려움은 없었다.
> 
> 각 기능별로 메서드를 분리해줌으로써, (isChar, isInt, compareInt, compareChar)  
> 문제를 빠르게 풀 수 있었다.

---

### 20237 배열 돌리기 6

https://www.acmicpc.net/problem/20327

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(n^2 * R)$

어떻게 접근했는지, 풀었는지 설명:

기본적인 배열의 상하반전, 좌우반전, 시계/반시계 방향 90도 회전의 업그레이드 문제  
문제는 배열을 $2^n x 2^n$ 개의 부분 배열로 나눠서 배열 연산을 진행한다는 점

부분 배열 내에서 연산(1,2,3,4): 

4개의 함수가 필요  
1 - 연산을 진행 할 부분 배열의 위치를 정해주는 함수  
2-1 - 현재 부분 배열을 temp로 옮겨주는 함수  
2-2 - 파라미터로 받은 부분 배열의 위치대로 연산을 진행하는 함수  
2-3 = temp의 값을 현재 부분 배열의 위치로 옮겨주는 함수  
(현재 부분 배열은 {sr,sc}에서 시작, temp는 {0,0}에서 시작)

> 이렇게 되면 2-2 인 1,2,3,4 연산을 위한 함수만 따로 구현하고, 1, 2-1, 2-3은 재사용 가능하다

부분 배열을 하나의 한 칸으로 보고 진행하는 연산(5,6,7,8): 

한칸이라고 생각하고 for문을 작성하는데,  
```
for (int i = 0; i < len; i++) {
    for (int j = 0; j < len; j++) {
        fTOs(i * len2, j * len2, j * len2, (len - i - 1) * len2, len2); // 90도 시계방향 회전
        // {fr,fc} -> {sr,sc} len2*len2 만큼 저장
        // 진짜 한칸이었으면 temp[j][len-i-1] = input[i][j]; 라고 작성 됨
    }
}
```  
이처럼 시작위치를 전달해준다.

> 핵심은 계산해야 할 부분 배열의 위치를 구하는 기능과,  
> 연산을 진행하는 기능의 분리  
> -> 연산을 진행할 때 부분 배열의 위치를 신경 안써도 됨  
> -> 코드가 깔끔해짐 & 재사용성 올라감
> 
> (코테에서도 이렇게 해야 한다)

> 1시간 쫌 넘게 걸렸다.
> 
> 시간이 지체된 이유 - i랑 j를 헷갈렸다.  
> (2차원 배열 접근은 i,j 말고 r,c 쓰자 - 가독성 그나마 좋다)

---

### 20541 앨범정리

https://www.acmicpc.net/problem/20541

`사용한 자료구조 & 알고리즘:` 트리

`시간복잡도:` $O(NlogN)$ // 대략?

`어떻게 접근했는지, 풀었는지 설명:`

커스텀 클래스를 만들어야 한다.

커스텀 클래스의 조건
1. 현재 앨범에 자식앨범이나 사진을 넣을 수 있어야 한다.
2. 현재 앨범에서 부모 앨범으로 이동할 수 있어야 한다.
3. 현재 앨범의 이름을 알 수 있어야 한다.
4. 현재 앨범에서 자식앨범과 사진은 이름이 중복되면 안된다.

```
class Infor{
public:
    string name; // 현재 앨범의 이름
    Infor* parent; // 부모 앨범을 가리킨다
    set<string> picture; // 사진들을 저장한다.
    map<string, Infor> childs; // 자식 앨범들을 저장한다.
}
```

자식앨범이나 사진을 찾는 시간복잡도를 줄이기 위해 set, map을 사용했다.

앨범을 삭제할 때 주의해야 할 것이 있다.  
자식 앨범을 삭제할 떄   
삭제되는 앨범들과 사진들의 수를 출력해줘야 한다.  
이때 자식 앨범 내에, 또 다른 자식 앨범과 사진이 있을 수 있으므로  
이를 재귀함수로 구현해 count 해줘야 한다.

그리고 현재 어떤 앨범을 가리키고 있는지 표현하기 위해  
```Infor* cur``` 을 선언해줬다.

    당황하지 말고 문제를 풀자.
    처음 멍때리는 시간이 너무 길다.
    이 시간만 없애면 충분히 빨리 풀 수 있다.

    그리고 이런 문제처럼, 
    인풋 받고 출력 하는 과정을 반복한다면
    무조건 cin.tie(nullptr)를 붙여줘야 한다.

    안붙히면 통과하는 코드가 TLE가 난다.

---

### 21610 마법사 상어와 비바라기

https://www.acmicpc.net/problem/21610

`사용한 자료구조 & 알고리즘:` 시뮬레이션

`시간복잡도:` $O(n^2*M*S)$

`어떻게 접근했는지, 풀었는지 설명:`

간단한 구현 문제

여기서 구름이 이동하는 횟수를 최적화 할 수 있다.  
N번 움직이면 같은 자리로 오기 때문에 s %= N 가능

구름이 움직일 떄는 N -> 1 , 1 -> N 으로 움직이는게 가능하지만,  
물복사를 할 때는 위 행동이 안된다는 것을 주의해야 한다.

---

### 23289 온풍기 안녕!(삼성기출)

https://www.acmicpc.net/problem/23289

> 너무 길어서 짧게 설명
>
> 1. 온풍기가 분다
> 2. 온도 평준화
> 3. 사이드 온도 1씩 내림
> 4. 초콜릿 먹음(101개 이상 먹으면 종료)
> 5. 지정한 칸들 온도가 K 이상이라면 종료
>
> 위 과정을 계속 반복한다. 먹은 초콜릿 개수를 출력한다.

사용한 알고리즘: 쌩 구현

시간복잡도: $O(n^4 * 100)$
    1 - n^4
    2 - n^2
    3 - n
    4,5 - 1
    => n^4

온풍기가 불때 & 온도 평준화 시킬때 벽이 있는지 없는지 체크해줘야 하는게 너무 귀찮았다.

특히 벽을 구분하는게 힘들었다. 아니 귀찮았다.

그런데 이 문제가 어려운 것은 아니다. 그냥 체크해야 할 것이 많아서 헷갈린다는 점이 문제다.

벽의 유무를 pair\<bool, bool> 2차원 배열로 관리했다. // 아래에 있는지, 오른쪽에 있는지

하지만 이를 구현할때 계속 first와 second를 헷갈려서 시간이 지연됐다.(first가 아래인지 오른쪽인지 헷갈려서 계속 선언부분 왔다갔다 했음)

> 그리고 이 문제에선 괜찮았지만, 하나 놓친 부분이 있었다.
>
> 지정한 칸이 없는 경우를 생각을 안했다.<br>
> (물론 이문제는 지정한 칸이 1개 이상이지만, 다른 문제에서는 없을 수도 있다. 항상 체크하자)

내가 규칙을 정했으면 이를 바로바로 볼 수 있는 곳에 표시를 해두는게 좋다.<br>
(코드가 길어지면 이 규칙을 바로바로 확인하기 힘들다)

---

### 23291 어항 정리

https://www.acmicpc.net/problem/23291

사용한 자료구조 & 알고리즘: 구현, 시뮬레이션

시간복잡도: $O()$

어떻게 접근했는지, 풀었는지 설명:

구현은 그냥 문제에 표현된대로 하면 된다.  
문제는 구현할 것들이 너무 많다는 것  
-> 그냥 기능 잘 분리해서, 각 기능별로 구현

물고기 수 조절 함수와 어항을 바닥에 일렬로 놓는 함수 두가지는 재사용 가능

> 2시간 쫌 넘게 걸렸다.
>
> 중간에 시간 지체된 이유
> 1. for문 탈출 조건으로 temp[r][c] != 0 조건을 사용했는데,  
     >    문제는 temp 변수는 여기저기서 사용하기 때문에, 위 조건문을 사용하면 안 됐다.  
     >    그냥 r의 범위와 c의 범위를 직접 입력해야만 했다.
> 2. 어항 간의 물고기 수 조절 함수 구현 중에 실수가 많았다.  
     >    처음에는 그냥 상 & 우 방향으로 push 하면서, 물고기 수를 조절했다. -> 같은 위치를 두번 push 함  
     >    그 다음으로, visited를 이용해 이미 방문했다면, 바로 continue 했다. -> 방문했더라도 비교 연산은 해야 한다.  
     >    다음 위치와 물고기 수를 조절한다음, visited를 이용(방문 안했다면 push x) -> 정답

> 결국 집중 잘해서 문제 계속 시도하면, 풀 수 있다.
>
> 1. 배열 회전을 진행하면, 행 열을 교체해 줘야 한다.
> 2. 항상 배열 내의 값을 다른 위치로 옮기면, 옮기기 전의 위치 값을 0으로 세팅해줘야 한다.