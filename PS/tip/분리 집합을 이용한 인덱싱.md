### 문자열 문제에서 활용하는 컨테이너

문자열 관련 문제를 풀다 보면, 중간에 있는 문자를 삭제해야 하는 경우가 많은데

이를 구현하기 위해 사용하는 자료구조는, 대표적으로 벡터(배열)과 연결리스트가 있다.

벡터의 장점: 인덱싱을 통한 접근 가능  
벡터의 단점: 중간 위치에 있는 원소를 삭제할 때의 시간복잡도는 O(n)  
(한 칸씩 당겨야 해서)

리스트의 장점: 중간 위치에 있는 원소를 삭제할 때의 시간복잡도 O(1)  
(iterator를 이용해 원하는 위치까지 접근했을 때를 가정)  
리스트의 단점: 인덱싱을 통한 접근 불가능

---

### 그냥 벡터를 이용했을 때 한계점

리스트의 단점은 너무 크리티컬하다.  
(인덱싱을 통한 접근이 필요한 경우가 많기 떄문에)  
그래서 대부분 벡터를 이용하는데,  
중간 위치에 있는 원소 한개를 삭제하기에는 시간복잡도가 별로다.

그래서 벡터 크기만큼의 `vector<bool> isErased`을 선언해서,  
삭제한 곳의 isErased[i]에 true를 입력해,  
나중에 해당 위치에 접근할 때는 그냥 넘기는 방법도 있다.  
```if(isErased[i] == true) continue;```

하지만 이 방법은 삭제한 곳도 계속 탐색하기 떄문에  
생각 없이 문제를 풀다가 TLE가 날 수 있다.

---

### 인덱싱을 적용한 벡터 이용

그래서 생각한 방법인데,  
문자열의 길이만큼의 `vector<int> nextI`를 선언해서,  
현재 위치의 다음 위치를 바로 반환해주는 방법이 있다.

> 대부분의 nextI[i]는 i+1이다.
> 
> 만약  
> isErased[2] = true;  
> isErased[3] = true;  
> 라면
> 
> nextI[1] = 4; 가 된다.

---

### nextI의 초기화

맨 처음엔

```
str T; // input string
vector<bool> isErased; // 삭제 표시하는 컨테이너
vector<int> nextI; // 다음 위치 알려주는 컨테이너

nextI.resize(T.size());
for(int i=0;i<T.size();i++)
    nextI[i] = i + 1;
```

바로 다음 위치로 초기화 해준다.  
(삭제한 문자열이 없기 때문에)

---

### 다음 인덱스 업데이트 방법(분리 집합의 find 메서드 이용)

문자열에서 특정 구간을 삭제할 때마다  
(`erased[i] = true;`로 삭제 표시)  
nextI를 업데이트 해줘야 한다.

업데이트 하는 방법은 분리 집합의 find 메서드를 이용했다.

```
int findNextI(int index) {
	assert(index >= 0 && index < T.size());
	
	if (nextI[index] >= T.size()) return nextI[index];
	if (isErased[nextI[index]] == true)
		return nextI[index] = findNextI(nextI[index]);

	return nextI[index];
}
```

위 메서드를 이용하면 평균 O(1)만에 다음 위치로 이동할 수 있다.

> 물론 문자열을 삭제하고 nextI를 처음으로 업데이트할떄는  
> 시간복잡도가 삭제한 문자열의 길이에 비례할 것이다.
> 
> 하지만  
> ```
> if (isErased[nextI[index]] == true)
>   return nextI[index] = findNextI(nextI[index]);
> ```
> 
> 위 코드에서 return할 때 nextI[index]를 업데이트 하기 때문에  
> 두번쨰부터는 O(1)으로 다음 위치를 얻을 수 있다.


---

### 이 방법의 장단점

이 방법의 장점은  
인덱싱 접근이 가능하면서도,  
기존 문자열을 삭제하지 않고 바로 다음 위치로 (시간복잡도는 O(1)) 이동할 수 있다.

대신 단점이 있는데,  
문자열의 길이만큼 `vector<int>`를 선언해야 해서 메모리가 추가적으로 필요하고,  
구현이 귀찮다는 단점이 있다.

> 문자열의 길이가 10 이라면,  
> nextI[9]는 10일 것이다.  
> 이를 그대로 T[10]을 탐색하면 바로 런타임 에러가 난다.  
> 이런 예외 처리를 따로 구현해줘야 한다.

---

> 그리고 대부분의 문자열 문제는  
> 오름차순 탐색만 하는 것이 아니라,  
> 내림차순 탐색을 할 때도 많기 떄문에
> 
> 이를 위한 `vector<int> prevI`도 구현해줘야 한다.

---

https://www.acmicpc.net/problem/10775

위 문제를 풀어보고 떠올린 방법이다.