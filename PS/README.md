형식

### 문제 번호

사이트주소

> 문제 설명

사용한 알고리즘: 

시간복잡도: $O()$

// 어떻게 접근했는지, 풀었는지 설명

---

### 문제를 원하는 시간안에 못풀었을때 해야할 것

1 - 다른 사람의 정답 코드를 제대로 이해할 것

2 - 내가 접근한 방법이 왜 안됐는지 이해할 것

위 두가지를 기록한다.

    그리고 나중에 꼭 한번 더 풀자


---

### 항상 설계와 구현을 분리하자

설계를 완벽하게 하고 구현을 마지막에 하자

문제푸는시간이 1시간이면 설계는 40분이상 & 코드로 구현은 20분 이내로 - 이런 느낌

### 항상 메서드를 분리해서 테스트하자

단위테스트처럼

    너무 테스트를 자주하지는 말자
    (구현문제에서 할 일이 많을 때 나눠서 테스트하는건 ok)

---

### c++로 코테 준비할때 중요한점

개행 쓸때는 ```endl```쓰지말고 무조건 ```'\n'```써야함

```endl```은 개행을 입력하고 flush를 하기때문에 시간복잡도 증가함


```cpp
ios::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
``````

이거 중요

```ios::sync_with_stdio(false);```

c++의 입출력 속도를 향상시킬 수 있다.
하지만 c와 c++의 입출력 함수를 혼용하면 출력 순서를 보장할 수 없다.

> 이걸 사용했을떄와 안했을때의 시간복잡도가 거의 2배씩 났음

```cin.tie(0);```
```cout.tie(0);```

flush를 덜 자주 하기 때문에 입출력 속도를 향상시킬 수 있다.
하지만 입출력의 순서를 보장받을 수 없다.(입력과 출력 각각의 순서는 보장받을 수 있다는 의미)

> 프로그래머스 문제를 풀때는 의미가 없을수도 있지만,
> 백준 문제를 풀때 
>
> 한줄 입력받고, 한줄 출력하는 걸 반복하는 문제에서는 이 코드가 매우 중요함
>
> -> 시간초과 나는 코드가 그냥 통과되는 경우도 있음

---

`vector 정렬할 때 필요한 cmp 함수`

```cpp
bool cmp(int t1, int t2){
    return t1 < t2; // 오름차순 정렬(default)
    // return t1 > t2; // 내림차순 정렬
}
// int 말고 다른 복잡한 타입 정렬할 때 유용

sort(v.begin(), v.end(), cmp);
```

`우선순위 큐 정렬기준 커스텀으로 제공하기`

```cpp
struct cmp{
    bool operator()(int& a, int& b) {
        return a < b; // 큰값이 제일 위로 (default)
        // return a > b; // 작은값이 제일 위로
    }
};

// int 말고 다른 복잡한 타입 정렬할 때 유용

priority_queue<int,vector<int>,cmp> pq;
```

---

`c++ 자료형의 범위`
|타입|비트|간단한 범위|2진수범위|
|--|--|--|--|
|int|32bit/4byte|-21억 ~ 21억|$-2^{31}$ ~ $2^{31}-1$
|long long|64bit/8byte|그냥 큼|$-2^{63}$ ~ $2^{63}-1$|

    2^31 or 21억을 넘어간다면 long long 사용
    안넘어가더라도 중간에 범위 벗어나는지 확인 필요

---

결국 코딩테스트 문제를 푸는건 수학문제를 푸는것의 응용버전? 이라고 생각한다.

수학문제 푸는 과정
1. 문제를 이해하고
2. 문제에 맞는 공식을 연결해서
3. 계산

코테문제 푸는 과정
1. 문제를 이해하고
2. 문제에 맞는 알고리즘을 연결해서
3. 구현

    여기서 코테문제는 실생활의 응용문제가 많기 떄문에 
    인풋 데이터를 전처리하는 과정이 필요한 경우도 있다.
>
    둘다 2번에서 응용력이 필요하다 -> 많이 풀어봐야 한다.
>
    결국 공식(알고리즘)이 언제&어디에서 쓰이는지를 다 알아야 한다.
    그래야 문제와 연결시킬 수 있다.
    
    -> 문제를 풀고나서 항상 어떻게 풀었는지 & 어떻게 접근했는지 적어놓자