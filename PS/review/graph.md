# 그래프 이론

- 그래프 탐색(DFS, BFS)
- 최단 거리(다익스트라, 플로이드 와샬)
- 최소 스패닝 트리(크루스칼, 프림)
- 위상 정렬

등의 알고리즘을 다룬다.

---

## 그래프란

자료나 개념을 표현하는 정점(V),  
이들을 연결하는 간선(E)  
로 이루어진 자료구조

---

## 그래프를 표현하는 방법

인접 행렬 표현과 인접 리스트 표현이 있다.

인접 행렬 표현: ```int graph[1001][1001];```

인접 리스트 표현: ```vector<vector<int>> graph```

|구분|인접 행렬| 인접 리스트    |
|---|---|-----------|
|메모리|O(V^2)| O(V + E)  |
|연결 여부 확인|O(1)| O(V)      |
|연결된 정점 찾기|O(V)| O(degree) |
|메모리 사용량|많음| 적음        |

|구분|인접 행렬|인접 리스트|
|---|---|---|
|장점|구현이 쉽다|메모리를 적게 사용한다|
|단점|메모리를 많이 사용한다|구현이 복잡하다|

---

## 암시적 그래프 구조

그래프 같은 형태를 갖는 구조가 아니라도,  
그래프를 통해서 표현하면 쉽게 해결할 수 있는 구조

대표적으로 위상 정렬이 있다.

---

## 그래프 문제들 정리

### 일반적인 그래프 탐색 문제(BFS, DFS 둘 다 가능한 문제)

1260, 2606, 2667, 1012, 11724

14502 연구소  
보드에 랜덤하게 3개 기둥을 놓고, 그래프 탐색으로 안전 구역을 구하는 문제  
시간복잡도: C(64,3) * 64  
(백준에는 BFS만 나와있지만, DFS도 충분히 가능하다 생각)

2468, 11725, 4963

2583 영역 구하기  
입력받은 좌표를 살짝 수정하면,  
일반적인 그래프 탐색으로 풀 수 있다.



### BFS를 이용하는 문제 

> DFS가 아닌 BFS로 풀었을 때,  
> 더 쉽게(효율적으로) 풀 수 있는 문제

2178, 7576

1697  
BFS를 이용하면, O(n)으로 쉽게 풀 수 있는 문제  
(문제 자체는 그래프를 유도하지는 않았음)

10026, 7569, 7562

2206  
전형적인 BFS + visited 확장  
(벽을 부쉈을 때, 안 부쉈을 때의 visited 두개로 관리)

### DFS를 이용하는 문제

1987  
DFS + 백트래킹을 이용하는 문제  
알파벳을 한번만 밟아야 하기 떄문에,  
알파벳에 대한 visited를 체크해준다.  
그리고 일반적인 DFS는 한번 밟으면 visited를 체크해주고,  
나중에는 업데이트 하지 않는데,  
이 문제는 같은 위치에 접근하더라도, 접근 방식에 따라서,  
경우가 나뉘기 떄문에,  
(처음 도착했을 때가 최적이 아니다)  
visited = true & 다음 위치에 대한 dfs() 를 해주고,  
visited = false 를 해줘야 한다.

시간복잡도는 O(4^26) 이지만, 이보다는 매우 적을 것이다.

> 이 문제의 핵심은  
> "어떤 경로를 통해 가장 많은 알파벳을 거쳐갈 수 있는가?"  
> 이다.
> -> 각 단계에서 가능한 모든 선택을 고려하여 최적의 해를 찾아야 한다.

> 이 문제에 BFS가 힘든 이유  
> 이 문제는 방문할 수 있는 칸의 최대 개수를 찾는 문제,  
> BFS는 최단 거리를 탐색할 때 유용하지만, 이런 문제에는 유용하지 않다.
> 
> 방문한 알파벳을 다시 방문할 수 없기 때문에, 경로마다 가질 수 있는 상태가 달라진다.  
> -> 같은 위치를 다른 상태로 여러번 방문할 수 있어서, 큐의 메모리 사용량이 불필요하게 증가된다.

> 그래프 탐색에서 일반적인 visited를 사용할 수 있는 케이스
>
> board[i][j]에 접근할 때,  
> 어떤 곳에서 접근하든({i,j-1}, {i,j+1}, {i-1,j}, {i+1,j}),  
> 먼저 도착한 놈이 최적이라는 것을 보장하는 문제들만 가능하다.  
> (이 문제는 불가능하다)  
> (위치가 같아도 이전 경로가 다르다면 상태가 달라지는 경우는 불가능)

> 이 문제를 통해 깨달은 점
> 
> BFS보다 DFS를 적용하는 것이 좋은 문제들의 특징은,  
> 저장해야 할 상태가 많을 때이다.  
> 
> BFS는 큐에 다양한 노드를 저장하고 있다.  
> -> 노드 한개에 저장할 상태 값들이 많아지면, 메모리 부하가 심해진다.  
> 
> 하지만 DFS는 한번 탐색할 때, 무조건 한 노드에 대한 상태만 가지고 있다.  
> (정확히는 현재 노드가 이동했던 이전 노드들의 상태 포함)
> -> 그래서 BFS보다 메모리를 덜 사용하게 된다. (상태 값이 클 때 경우)

### 최단 거리 문제

1753(다익스트라)

11403(플로이드-워셜)  
그냥 경로가 있는지 체크하는 문제이지만,  
모든 정점에 대해 찾기 떄문에,  
플로이드-워셜로 풀었다.  
(최단 거리를 체크하지 않고, 갈 수 있는지 없는지만 (0 or INF))

### 최소 스패닝 트리 문제



### 그래프 구조는 아니지만, 그래프를 이용해 푸는 문제