# 그래프 이론

- 그래프 탐색(DFS, BFS)
- 최단 거리(다익스트라, 플로이드 와샬)
- 최소 스패닝 트리(크루스칼, 프림)
- 위상 정렬

등의 알고리즘을 다룬다.

---

## 그래프란

자료나 개념을 표현하는 정점(V),  
이들을 연결하는 간선(E)  
로 이루어진 자료구조

---

## 그래프를 표현하는 방법

인접 행렬 표현과 인접 리스트 표현이 있다.

인접 행렬 표현: ```int graph[1001][1001];```

인접 리스트 표현: ```vector<vector<int>> graph```

|구분|인접 행렬| 인접 리스트  |
|---|---|---------|
|메모리|O(V^2)| O(V + E) |
|연결 여부 확인|O(1)| O(V)    |
|연결된 정점 찾기|O(V)| O(E)    |
|메모리 사용량|많음| 적음      |

|구분| 인접 행렬                              | 인접 리스트                            |
|---|------------------------------------|-----------------------------------|
|장점| 특정 노드가 연결됐는지 확인하는 로직이 빠르다  | 메모리를 적게 사용한다(딱 엣지 개수만큼 필요)        |
|단점| 메모리를 많이 사용한다, 중복 엣지를 표현하는 것이 불가능하다 | 특정 노드가 연결됐는지 확인하는 로직이 (상대적으로) 느리다 |

---

## 암시적 그래프 구조

그래프 같은 형태를 갖는 구조가 아니라도,  
그래프를 통해서 표현하면 쉽게 해결할 수 있는 구조

대표적으로 위상 정렬이 있다.

---

## 그래프 문제들 정리

### 일반적인 그래프 탐색 문제(BFS, DFS 둘 다 가능한 문제)

1260, 2606, 2667, 1012, 11724

14502 연구소  
보드에 랜덤하게 3개 기둥을 놓고, 그래프 탐색으로 안전 구역을 구하는 문제  
시간복잡도: C(64,3) * 64  
(백준에는 BFS만 나와있지만, DFS도 충분히 가능하다 생각)

2468, 11725, 4963

2583 영역 구하기  
입력받은 좌표를 살짝 수정하면,  
일반적인 그래프 탐색으로 풀 수 있다.

2644

1520  
이 문제는 BFS + 그리디 or DFS + DP 를 이용하는 문제  

BFS + 그리디  
(여기서 적용되는 최적해 - "높이가 높은 원소부터 탐색한다")  
높이가 높은 곳에서 낮은 곳으로만 움직일 수 있기 때문에,  
BFS의 큐에 있는 원소들 중에서 가장 높이가 높은 원소부터 탐색하면  
상태가 겹치지 않으면서 탐색할 수 있다.  
높이가 높은 원소부터 탐색하기 위해 우선순위 큐를 활용한다.  
시간복잡도: O(nlogn) - 우선순위 큐 push, pop 시간

DFS + DP  
(DP를 적용할 수 있는 이유 - 특정 위치에서 목적지로 갈 수 있는 경우에 수는 이전 상태와 관계없이 항상 같다)  
모든 위치에 대한 dp 값을 -1로 초기화 한 후,  
DFS로 탐색하는데,  
dp 값이 -1 이 아니라면, 이미 탐색을 했다는 뜻이다.  
그래서 더 탐색할 필요없이 바로 반환할 수 있다.  
시간복잡도: O(n)

> DP를 적용할 수 있는 이유를 정확히 설명하면,  
> 높은 위치에서 무조건 낮은 위치로만 갈 수 있기 때문이다.
> 
> 그래서 현재 위치에서, 갈 수 있는 주위의 칸들의 경우의 수를 모두 받아서  
> 더해준 것이 dp[x][y]의 값이 된다.  
> (이 값은 나중에 다시 접근해도 변하지 않는다)

16234  
그래프 탐색(BFS or DFS)를 이용해 연합을 구하고 계산하는 문제

2573  
빙산을 녹일 때 + 빙산이 갈라졌는지 확인할 때  
그래프 탐색을 이용한다.  
(빙산을 녹이는 기준은 바닷물에서 그래프 탐색을 할 때, 빙산을 만나면 녹인다)  
(빙산에서 그래프 탐색하는 건 x)

1167, 1967  
그래프 탐색 두번을 하면 풀 수 있다.  
맨처음 임의의 노드에서 가장 거리가 먼 점을 찾는다.  
해당 점이 끝 점이 된다.  
해당 점에서 가장 먼 점까지의 거리가 트리의 지름이 된다.  
(DFS로 많이 풀지만, BFS도 가능하다)

> 여기서 적용되는 최적해 한가지  
> 임의의 정점에서 가장 먼 정점이 지름의 한 꼭짓점이다.

17070  
이 문제는 그냥 순서대로 방문해서 DP를 적용하는게 핵심인 문제
(그래프 탐색은 그렇게 안 중요함)

1068  
부모 노드 정보를 알려주면,  
부모 노드의 간선에 자식 노드를 추가하면 된다.

1976

5639(트리 문제)  
중간 노드의 위치와, 대소 비교를 통해  
트리를 구성하는 문제

2636

1043  
그래프 탐색 or 분리 집합을 이용하는 문제  
처음에 진실을 아는 사람들을 이용해  
각 파티별로 진실을 아는 사람들을 구한다.  
(이 과정에서 그래프 탐색 or 분리 집합을 이용한다)

> 분리 집합을 이용하는 것이 더 효율적이다.  
> 특정 번호를 진실을 아는 사람으로 설정하고,  
> 파티에 있는 사람들끼리 union 해주면 된다.




### BFS를 이용하는 문제

> DFS가 아닌 BFS로 풀었을 때,  
> 더 쉽게(효율적으로) 풀 수 있는 문제

2178, 7576

1697  
BFS를 이용하면, O(n)으로 쉽게 풀 수 있는 문제  
(문제 자체는 그래프를 유도하지는 않았음)

10026, 7569, 7562

2206  
전형적인 BFS + visited 확장  
(벽을 부쉈을 때, 안 부쉈을 때의 visited 두개로 관리)

16236  
가장 가까운 물고기를 찾을 때, BFS를 이용한다.  
(최단 거리라서 DFS는 불가능)  
이때 우선순위가 있어서, 가장 먼저 찾은 물고기가 대상이 아닐 수 있다.  
-> BFS로 모든 영역을 탐색한 후, 거리가 가장 짧고, 가장 위에 있고, 가장 왼쪽에 있는 물고기를 타겟으로 정한다.

13549  
1697의 응용 문제,  
2*X의 위치로 이동할 때는 0초가 걸리는 것이 포인트  
원래는 1초가 걸려서, 똑같이 q.push()를 해주면 되지만  
0초이기 때문에 맨 뒤에 놓으면 순서가 맞지 않는다.  
-> 덱큐를 이용해 0초는 맨앞에 놓는다.  
(내가 생각했지만 되게 기발하다)  

> 지금은 우선순위 큐를 이용해야 하나? 생각했지만,  
> 더 좋은 방법을 예전에 생각했었네
> 
> 우선순위 큐를 사용했을 때 시간복잡도: O(nlogn)  
> 덱큐를 사용했을 때 시간복잡도: O(n) (기존 BFS와 동일)

> 이 문제가 덱큐가 가능한 이유
> 
> 기존 bfs에서 큐를 이용하는 이유는,  
> 먼저 도착한 노드를 먼저 탐색하기 위함이다.
> 
> 이때 순간이동은 0초가 걸리기 때문에,  
> 덱큐의 뒷부분에 push 하는 것이 아니라,  
> 덱큐의 앞부분에 push 하는 것이다.

16953  
BFS도 가능하지만, 그리디도 가능한 문제  
(B에서 A를 만들 때 그리디로 가능)  
이 문제에는 visited가 없어도 되는데,  
그 이유는 모든 원소가 단조롭게 증가하기 때문이다.

> 인풋의 범위가 0~10억이라서 시간초과라고 생각할 수 있지만,  
> 원소가 2배씩 증가 or 10을 곱해서 1을 더하는 경우 두개가,  
> 숫자를 매우 크게 증가시키기 때문에 시간초과가 발생하지 않는다.

13460  
visited를 확장한 문제  
파란 구슬에 대한 visited & 빨간 구슬에 대한 visited 가 필요하다. -> 4차원 배열 visited

5014, 9019, 3055

1261  
bfs를 이용하는데,  
큐에 {행, 열, cnt}를 넣어주는데,  
다음 위치가 벽이면 cnt + 1 아니면 그냥 cnt가 다음 노드의 cnt 값이 된다.  
이때 방문 순서를 제어해야 한다.  
큐에서, 벽을 뚫는 케이스는 벽을 뚫지 않는 케이스보다 뒤에 있어야 한다.  
-> bfs 탐색을 할 때, 벽을 뚫지 않는 노드들 먼저 탐색, 그 다음으로 벽뚫는 다음 노드들 탐색  
위 과정을 반복한다.  
O(n)

16928

12851  
일반적인 BFS  
여기서 원하는 위치에 도달했을 때  
걸린 시간을 바로 반환하지 않고,  
남은 원소들을 확인해줘야 한다. (걸린 시간이 같은 경우를 생각해야 함)

13913  
BFS + 경로 출력  
경로 출력을 위해 visited가 bool 타입이 아닌 int 타입으로 선언한다.  
(이전 위치를 저장하기 위해)  

> 이때 다음 위치가 아닌 이전 위치를 저장해야 한다.  
> 다음 위치를 저장하면 경로가 여러개가 나올 수 있기 때문이다.

12852  
DP + BFS + 경로 출력

### DFS를 이용하는 문제

1987  
DFS + 백트래킹을 이용하는 문제  
알파벳을 한번만 밟아야 하기 떄문에,  
알파벳에 대한 visited를 체크해준다.  
그리고 일반적인 DFS는 한번 밟으면 visited를 체크해주고,  
나중에는 업데이트 하지 않는데,  
이 문제는 같은 위치에 접근하더라도, 접근 방식에 따라서,  
경우가 나뉘기 떄문에,  
(처음 도착했을 때가 최적이 아니다)  
visited = true & 다음 위치에 대한 dfs() 를 해주고,  
visited = false 를 해줘야 한다.

시간복잡도는 O(4^26) 이지만, 이보다는 매우 적을 것이다.

> 이 문제의 핵심은  
> "어떤 경로를 통해 가장 많은 알파벳을 거쳐갈 수 있는가?"  
> 이다.
> -> 각 단계에서 가능한 모든 선택을 고려하여 최적의 해를 찾아야 한다.

> 이 문제에 BFS가 힘든 이유  
> 이 문제는 방문할 수 있는 칸의 최대 개수를 찾는 문제,  
> BFS는 최단 거리를 탐색할 때 유용하지만, 이런 문제에는 유용하지 않다.
> 
> 방문한 알파벳을 다시 방문할 수 없기 때문에, 경로마다 가질 수 있는 상태가 달라진다.  
> -> 같은 위치를 다른 상태로 여러번 방문할 수 있어서, 큐의 메모리 사용량이 불필요하게 증가된다.

> 그래프 탐색에서 일반적인 visited를 사용할 수 있는 케이스
>
> board[i][j]에 접근할 때,  
> 어떤 곳에서 접근하든({i,j-1}, {i,j+1}, {i-1,j}, {i+1,j}),  
> 먼저 도착한 놈이 최적이라는 것을 보장하는 문제들만 가능하다.  
> (이 문제는 불가능하다)  
> (위치가 같아도 이전 경로가 다르다면 상태가 달라지는 경우는 불가능)

> 이 문제를 통해 깨달은 점
> 
> BFS보다 DFS를 적용하는 것이 좋은 문제들의 특징은,  
> 저장해야 할 상태가 많을 때이다.  
> 
> BFS는 큐에 다양한 노드를 저장하고 있다.  
> -> 노드 한개에 저장할 상태 값들이 많아지면, 메모리 부하가 심해진다.  
> 
> 하지만 DFS는 한번 탐색할 때, 무조건 한 노드에 대한 상태만 가지고 있다.  
> (정확히는 현재 노드가 이동했던 이전 노드들의 상태 포함)  
> -> 그래서 BFS보다 메모리를 덜 사용하게 된다. (상태 값이 클 때 경우)

9466(사이클 문제)  
그래프의 사이클을 구하는 대표적인 문제

> 그래프의 사이클을 찾는 문제는 DFS를 이용한다.

### 최단 거리 문제

> 다익스트라 - 한 정점에서 다른 모든 정점으로의 최단 거리를 구하는 알고리즘

1753(다익스트라)

11403(플로이드-워셜)  
그냥 경로가 있는지 체크하는 문제이지만,  
모든 정점에 대해 찾기 떄문에,  
플로이드-워셜로 풀었다.  
(최단 거리를 체크하지 않고, 갈 수 있는지 없는지만 (0 or INF))

11404(플로이드-워셜)

1916(다익스트라)

1389(플로이드-워셜)

1238(다익스트라)  
모든 정점에서 X 정점으로 오는 시간 + 다시 돌아가는 시간이 최소인 정점을 찾는 문제  
-> 다익스트라를 두번 써서 해결한다.

1504(다익스트라)  
3개의 정점을 거쳐야 하기 때문에,  
다익스트라를 3번 쓰면 되는 문제

18353(다익스트라)

### 최소 스패닝 트리 문제

1197(크루스칼, 프림)

### 그래프 구조는 아니지만, 그래프를 이용해 푸는 문제

2252(위상 정렬)

1005  
위상 정렬 + DP
해당 건물을 짓기 전에, 지어야 하는 건물들이 있어서 위상 정렬을 이용한다.  
이때 지을 수 있는 건물은 동시에 지을 수 있기 때문에,  
가장 오래걸리는 건물의 시간이 다음 건물을 지을 수 있는 시간이 된다.  
이를 이용해 DP를 적용한다.

1766  
위상 정렬 + 우선순위 큐  
일반적인 위상정렬 문제에서 추가 조건이 있다.  
(가장 쉬운 문제를 먼저 풀어야 한다 -> 번호가 작은 문제를 먼저 풀어야 한다)  
이를 구현하기 위해 우선순위 큐를 이용한다.



---

## 한번 더 생각해볼 문제

1987 - DFS 응용 버전 문제(최대한 많이 방문해야 하는 케이스)

2644 - 다익스트라인 줄 알았지만, 간단한 그래프 탐색이었던 문제  
(다익스트라도 그래프 탐색의 한 종류이기 때문)  
(문제 자체가 간단해서, 여러 방법으로 풀 수 있다)

13549 - 덱큐를 이용해 BFS의 응용 문제를 푼다.

1520 - DFS, BFS 둘 다 다른 접근으로 가능한 문제

1167 - 트리의 지름 문제

1043 - 그래프 탐색 or 분리 집합을 이용하는 문제

13913 - 경로 출력을 위한 BFS 응용 문제

---

## DFS vs BFS

한 정점에서 다른 정점까지의 최단 거리를 구한다? - BFS

한 정점에서 다른 모든 정점까지의 최단 거리가 필요하다? - 다익스트라

모든 정점에서 모든 정점 - 플로이드-워셜

그 외 DFS

> DFS만 된다는 것은 아니다.    
> DFS가 가장 편하다.
> 
> BFS는 큐의 원소 하나에 모든 상태를 저장해야 하기 때문에 메모리 초과가 발생할 수 있다.

## 그래프의 사이클을 구하는 문제 - DFS 응용

이때는 visited, done 배열 두가지를 사용한다.  
visited = 해당 노드를 방문했는지 체크  
done = 이 배열을 이용해 사이클인지 아닌지를 구분한다.

```cpp
int dfs(int index){
    visited[index] = true;
    int next = v[index];
    
    if(visited[next] == false) // 아직 방문하지 않았다
        dfs(next);
    else if(done[next] == false){
        // 방문했고, 사이클이 형성되지 않았다.
        // -> 현재 노드가 사이클에 해당하는 노드의 마지막 노드
    
    }
    done[next] = true;
}
```

if(visited[next] == true && done[next] == true) // 해당 노드는 사이클에 속해 있지 않다.