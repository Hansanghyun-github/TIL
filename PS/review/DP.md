# DP(Dynamic Programming)

Dynamic Programming의 적절한 번역은 동적 프로그래밍이 아니라 동적 계획법입니다.  
여기서 Programming은 최적의 프로그램을 찾아낸다는 의미로 사용된다고 합니다.

## 동적 계획법

동적 계획법은 큰 문제를 작은 문제로 나누어 푸는 방법이다.  
이때 작은 문제들은 중복되어 여러번 계산되는데, 이를 피하기 위해 메모이제이션을 사용한다.

동적 계획법은 다음과 같은 특징을 가진다.
- 큰 문제를 작은 문제로 나누어 푼다.
- 작은 문제들은 중복되어 여러번 계산된다.
- 이를 피하기 위해 메모이제이션을 사용한다.
- 메모이제이션은 작은 문제들의 답을 저장해두고, 같은 문제가 나오면 저장된 답을 반환한다.

> 결국 DP를 잘하려면 완전 탐색을 잘해야 한다.  
> 완탐 후 이를 겹치는 상태를 메모이제이션을 통해 시간복잡도를 줄이는게 DP의 핵심이다.


---

## 메모이제이션 구현 패턴

동적 계획법은 가장 흔한 문제 유형 중 하나이기 때문에 메모이제이션은 굉장히 자주 구현하게 된다.  
그런 만큼 한가지 패턴을 정해두고 항상 같은 형태로 구현하기로 하면 작성하기도, 버그를 찾기도 쉬워진다.

```cpp
int cache[A][B]; // 원하는 크기로

// 항상 a<A, b<B
// 반환 값은 int형 안에 들어가는 정수, int 범위 밖이라면 long long 활용 시도
int someObscureFunction(int a, int b){
    // 기저 사례를 처음에 처리한다.
    if(...) return ...;

    // a와 b에 대한 답이 있다면 곧장 반환
    int& ret = cache[a][b];
    if(ret != -1) return ret;

    // 여기서 답을 계산한다.
    ...
    return ret;
}
```

`someObscureFunction(a,b)`는 같은 인자로 여러번 호출되더라도 항상 같은 값을 반환한다.

> 위처럼 재귀 호출을 이용해 구현할 수도 있지만,  
> 반복문을 이용해 구현할 수도 있다.
> 
> 이를 Bottom-Up 방식이라고 한다.

---

### 반복적 동적 계획법과 재귀적 동적 계획법의 비교

재귀적 동적 계획법의 장단점

장점 
1. 좀더 직관적인 코드를 짤 수 있다.
2. 부분 문제 간의 의존 관계나 계산 순서에 대해 고민할 필요가 없다.
3. 전체 부분 문제 중 일부의 답만 필요한 경우 더 빠르게 동작한다.

단점
1. 슬라이딩 윈도우 기법을 쓸 수 없다.
2. 스택 오버플로를 조심해야 한다.

반복적 동적 계획법의 장단점

장점
1. 구현이 대개 더 짧다.
2. 재귀 호출에 필요한 부하가 없기 때문에 조금 더 빠르게 동작한다.
3. 슬라이딩 윈도우 기법을 쓸 수 있다.

단점
1. 구현이 좀더 비직관적이다.
2. 부분 문제 간의 의존관계를 고려해 계산되는 순서를 고민해야 한다.

> 취향에 따라 어느 쪽을 선택할지의 여부가 달라질 수 있지만 중요한 것은 `가능한 한 자신이 선택한 방향으로 일관되게 계속 연습하는 것`입니다.

---

## DP 문제 정리

2839  
5kg 봉지를 한개씩 줄이면서 탐색하는 방법(그리디) or  
dp[3]=dp[5]=1을 이용해서, dp[N]까지 구한다.  
(dp[i] = min(dp[i-3] + 1, dp[i-5] + 1))

1463  
BFS or DP 로 가능한 문제  
BFS는 visited 채우면서 1만드는 최소 횟수 찾으면 된다.  
DP는 dp[i] = min(dp[i-1], dp[i/2], dp[i/3])+1 을 이용해 dp[n]을 구한다.  
(이때 2나 3으로 나누어 떨어질 때만 가능한 걸 생각)

9095  
dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

1003  
DP의 대표적인 피보나치 함수 관련 된 문제

11726  
dp[i]=dp[i-1]+dp[i-2]  
2xi 타일은 2x(i-1) 타일 + 2x1 타일 + 2x(i-2) + 1x2 2개 타일로 채운 것과 같다.

2775 

2579  
dp[n][2] 배열 선언  
dp[i][j] = i번째 위치의 계단에서 j+1번 연속으로 계단을 밟았을 때의 점수  
dp[k][0] = max(dp[k-2][0], dp[k-2][1]) + v[i]  
dp[k][1] = dp[k-1][0] + v[i]  
max(dp[n][0], dp[n][1])이 정답이 된다.  

> dp[i] = max(dp[i-2]+v[i], dp[i-3]+v[i-1]+v[i]) 도 되네  
> 한개만 밟았을 때 값, 두개 연속으로 밟았을 때 값 중 최댓값이 현재 위치의 값이 된다.

1149  
이전 집과 색만 다를 때 최댓값을 각 색 별로 구한다.  
-> 마지막 집의 최댓값이 정답

11053  
DP의 대표적인 문제 - LIS
O(n^2)으로 풀 수 있다.

1932  
dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + v[i][j]

1912  
연속합의 최댓값을 찾아야 하는데,  
처음부터 현재까지 다 더했을 때 양수라면 계속 가져간다.  
만약 0보다 작거나 같다면, 지금까지 더했던 것들을 버리고 다음으로 넘어간다.  
dp[i] = max(dp[i-1]+v[i], v[i]);  
(여기서 겹치는 부분 문제: 이전 인덱스까지의 연속합의 최댓값)

1010  
다리를 최대한 많이 지으려면, 겹치지 않게 지으면 된다.  
-> m개 중에 n개 골라서 지을 수 있는 경우의 수  
-> mCn 이 정답

9461  
dp[i] = dp[i-1] + dp[i-5]

11727  
11726의 응용 문제  
dp[i] = dp[i-1]+dp[i-2]*2  
i-1에서 2x1 타일 붙인 경우의 수 + i-2에서 1x2 타일 2개 or 2x2 타일 붙인 경우의 수 가 정답

2748

2156   
연속으로 3잔을 마실 수 없다 == 연속으로 계단을 3칸 밟을 수 없다.  
-> 계단 밟는 문제랑 같아진다.  
dp[i] = max(dp[i-2]+v[i], dp[i-1], dp[i-3]+v[i-1]+v[i])

10844  
마지막 숫자가 i인 숫자를 의미하는 배열 10개를 만들어서 푼다.

14501  

2193  
1로 끝나는 숫자의 개수, 0으로 끝나는 숫자의 개수 를 이용해 푼다.  

12865  
배낭 문제  
최대 무게 x 아이템 개수 크기에 해당하는 배열 dp 선언  
dp[i][j] - 무게가 i일 때 j번 아이템까지 담았을 때 최대 가치  
dp[i][j] = max(v[j] + dp[i-w[j]][j-1], dp[i][j-1])

---

## 한번 더 생각해볼 문제

1912 바로 생각이 나지 않았다

2156 dp 배열을 3개 쓰는 방법과 한개로 푸는 방법 두가지가 있다.















