# 그리디 알고리즘

탐욕법은 가장 직관적임 알고리즘 설계 패러다임 중 하나입니다.  
탐욕법을 이용한 알고리즘은 우리가 원하는 답을 재귀 호출과 똑같이 여러 개의 조각으로 쪼개고,  
각 단계마다 답의 한 부분을 만들어 간다는 점에서 완전 탐색이나 동적 계획법 알고리즘과 다를 것이 없습니다.

그러나 모든 선택지를 고려해 보고 그중 전체 답이 가장 좋은 것을 찾는 두 방법과 달리,  
탐욕법은 각 단계마다 지금 당장 좋은 방법만을 선택합니다.

탐욕법은 `지금의 선택이 앞으로 남은 선택들에 대해 어떤 영향을 끼칠지는 고려하지 않습니다`.

---

실제로 최적해를 얻을 수 있는 접근이 직관적이지 않은 경우도 많기 때문에 실수에 더 유의해야 합니다.  
그러니 탐욕적 알고리즘을 연습 문제를 풀때는 알고리즘의 정당성을 증명하는 과정을 빼먹지 않고 연습하는 것이 좋습니다.

> 탐욕적 선택 속성(greedy choice property)  
> 동적 계획법처럼 답의 모든 부분을 고려하지 않고 탐욕적으로만 선택하더라도 최적해를 구할 수 있다는 것
> 
> 최적 부분 구조  
> 항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있음
> 
> 위 두가지를 증명해야 탐욕법을 적용할 수 있다.  
> (최적 부분 구조는 대부분 자명해서 증명할 필요가 없다고 한다)

---

## 그리디 알고리즘 문제들

2839  
봉지의 개수를 줄이려면, 최대한 5킬로 봉지를 많이 사용해야 한다.  
-> 5킬로 봉지 개수를 줄이면서, 가능한 경우를 탐색한다.

11399  
최솟값을 구하려면, 인출 시간이 짧은 사람은 앞에 둬야 한다.

11047  
동전 개수를 줄이려면, 최대한 가치가 높은 동전을 사용해야 한다.  

1931  
회의 개수를 최대로 하기 위해, 끝나는 시간이 빠른 회의를 먼저 담아야 한다.  

1541  
값을 최소로 하기 위해, 마이너스 부호 뒤의 수를 최대한 키워야 한다.  
-> 다음 마이너스 부호가 오기 전까지의 숫자를 모두 괄호로 묶는다.

1026  
S의 최솟값을 구하려면, 가장 큰 수에는 가장 작은 수를 곱해줘야 한다.

5585, 2217

1789  
서로 다른 N개의 자연수의 합이 S일때, N이 최대려면,  
결국 1부터 N까지 더한다고 가정해야 한다.  
(N을 제외한 모든 수는 최소가 되야 하기 때문)  
-> 1 + ... + N 이 S를 넘어설 때의 N(or N-1)이 정답이다.

1715  
최대한 적은 수를 먼저 사용해야 한다. (우선순위 큐 이용)

16953  
A를 B로 바꾸는 문제인데,  
B를 A로 그리디하게 바꾸면 간단하게 풀 수 있다.  
B의 끝이 1 -> 1 뺀다, B의 끝이 짝수 -> 2 나눈다.  
(그 외의 수는 -1 처리)

1439  
그냥 0일 때와 1일 때의 개수를 세서 최소인 값을 반환하면 끝

1946  
면접과 서류 순위에서, 다른 지원자의 성적보다 떨어지지 않는다면 뽑는다.  
-> 한쪽 순위를 정렬해놓고 비교하면 편해진다.  
1. 면접 순위 오름차순으로 정렬
2. i번째 사람은 왼쪽 사람들 보다 서류 순위가 높으면 뽑는다.  
   (오른쪽 사람들보다 면접 순위가 높기 때문에)

1339  
맨 앞자리 알파벳부터 가중치를 부여한다.  
가중치 내림차순으로 9~1 숫자를 부여해서 계산한다.

1202  
기존 배낭 문제에서, 배낭의 개수가 늘어난 케이스  
여기서 가방에 보석은 딱 1개만 넣을 수 있다는게 핵심이다.  
-> 보석과 가방을 최대한 딱 맞게 넣어야 한다.  
(무게가 5인 보석을 중량이 10인 가방 보다는 6인 가방에 넣는 것이 더 이득이다)
1. 보석을 가치 내림차순으로 정렬
2. 가방을 무게 오름차순으로 정렬
3. 가치가 높은 보석순으로 가장 딱 맞는 가방을 탐색한다. (lower_bound)

1744  
수를 두개씩 묶어서 합을 최대화 하려면, 몇가지 규칙이 있다.  
(두 수를 묶다 -> 두 수를 곱한다)
1. 2 이상의 양수는 큰 놈들 끼리 묶는 것
2. 음수가 2개 이상이라면, 최대한 큰 놈끼리 묶는 것
3. 음수가 홀수개 이고 0이 있다면, 절댓값이 가장 작은 음수와 0을 묶어야 한다.
4. 2 이상의 양수 1개와 1이 있다면, 둘은 묶지 않아야 한다. (그냥 더하는게 더 크다)

11000  
적용하는 최적해 - '끝나는 시간과 다음으로 시작하는 시간의 텀이 최대한 짧아야 한다'  

> 나는 map 으로 일일이 업데이트 하려 했지만,  
> 우선순위 큐 쓰는 방법도 있었네  
> (어차피 시간복잡도는 둘 다 같다)

1049  
m개의 가격이 주어지지만, 결국 제일 낮은 가격을 고르면 된다.  
여기서 주의해야 할 것
1. 6개 묶음 가격이 낱개 6개의 가격보다 높을 수 있다.
2. 5개 이하가 필요해도, 낱개로 사는 것보다 6개 묶음으로 사는게 더 저렴할 수 있다.

14916  

1213  
문자열이 팰린드롬이 되게 조합하려면,  
홀수개인 문자는 1개 이하여야 한다.  
그리고 사전순으로 가장 앞서는 걸 출력해야 하기 때문에,  
가장 값이 작은 문자 먼저 출력해야 한다.

1449  
숫자들을 정렬해서  
테이프 길이와 위치를 비교하면서 결과를 구할 수 있다. 

12904  
A 문자열에서 B 문자열을 만들지 않고,  
규칙의 반대로 B 문자열에서 A 문자열로 만들면 된다.

2812  
앞자리 부터 K개 중에 가장 큰 수를 찾는다.  
해당 자리 이전의 숫자를 모두 지우고, 지운만큼 K--  
다시 다음 자리부터 K개 중에 가장 큰 수를 찾고, 지운다.

1700  
해당 물건이 이미 플러그에 있거나, 플러그가 빈 곳이 있다면 넣고 continue  
플러그의 물건을 바꿔야 한다면, 물건들 중에서 가장 나중에 나오는 물건과 바꾸면 된다.

3109  
여기서 적용되는 최적해 - '최대한 위에서 위로 이동해야 한다?'

> 경우의 수를 높이려면, 최대한 위로 바짝 붙어서 이동해야 한다.  
> (겹치면 안되기 떄문에)

이때 이전 위치가 이동한 경로에 마킹을 함으로써,  
시간복잡도를 줄일 수 있다.  
(O(RRC) -> O(RC))

> 이동할 때마다, 성공 여부에 관계없이 마킹해도 문제 없는 이유  
> 
> 성공했을 때 마킹 -> 이미 지나간 곳이므로 겹칠 수 없어서 마킹 해야 한다.  
> 실패했을 때 마킹 -> 해당 자리는 실패하는 자리이므로 마킹을 해서 방지한다.

      맨 처음 나는 이 문제를 DP만 이용해서 풀려고 했다.  
      (이전 열에서 현재 열로 이동할 수 있으면 바로 이동하게 함, 위부터 아래로 우선순위)  
      하지만 이 접근은 틀린 접근이다.

      이유: 이전 열과 현재 열의 관계만으로 최적해를 구할 수 없다.
      (최적 부분 구조가 성립되지 않는다)

      DP가 틀리는 케이스
      3 5
      .x.x.
      ..xx.
      .x...

      3번째 열에서 이전 위치의 파이프는 아래로 이동해야 한다.
      하지만 0,3 위치에서 먼저 가져갔기 때문에 
      2,3 위치에서 가져가지 못하게 된다.
      -> 답이 1이 아닌 0이 나온다. (x)

      그렇다고 0,3 2,3 둘다 가져간다? -> 그러면 다른 예시에서 답이 더 크게 나올 수 있다.
      결국 직접 한개씩 이동하면서 답을 구해야 한다. -> DFS

10775  
적용되는 최적해 - '현재 비행기를 최대한 큰 번호의 게이트에 도킹 시켜야 한다'  
(번호가 작은 비행기는 도킹 시킬 수 있는 게이트가 적기 때문이다)  
도킹 할 수 있는 게이트를 찾기 위해 분리 집합을 사용한다.

1417  
적용되는 최적해 - '득표수가 가장 높은 후보의 표를 뺏어와야 한다'  
이때 우선순위 큐를 사용해 편하게 풀 수 있다.

1092  
적용되는 최적해 - '현재 크레인이 들 수 있는 가장 무거운 박스를 선택한다'  
박스들, 크레인들을 무게순으로 정렬한 다음,  
모든 박스가 옮길 수 있는 크레인 들 중 cnt가 가장 작은 크레인을 골라서, cnt + 1 해준다.  
(이때 최대한 작은 크레인을 골라야 함)

1041  
적용되는 최적해 - '최대한 작은 조합의 주사위 면들을 이용한다'  
면이 1개가 쓰이는 주사위 -> 가장 작은 값 이용  
면이 2개가 쓰이는 주사위 -> 가장 작은 2개의 값 조합 이용  
면이 3개가 쓰이는 주사위 -> 가장 작은 3개의 값 조합 이용

-> 결국 입력된 주사위 값을 이용해, 가장 작은 값을 찾아서 구해주면 된다.

13904  
적용되는 최적해 -> '점수가 가장 높은 과제를 최대한 늦게 처리한다'  

> 접근 방법  
> 마감일이 제일 짧은 것 중, 점수가 제일 높은 걸 해야 한다.  
> 하지만 점수가 높은 것들이 전부 마감일이 늦어도 괜찮을 것일 수도 있다.  
> -> 오히려 마감일이 짧은 것들은 전부 할 필요가 없을 수도 있다. (점수가 낮아서)  
> -> 마감일 순으로 정렬한 다음, 앞이 아닌 뒤부터 탐색한다.
> 
> 어차피 마감일이 남은 과제는, 마감일에 하든 마감일 전날에 하든 점수는 같다.  
> -> 최대한 뒤로 미룬다.  
> (전날에는 다른 과제를 해야할 수 있기 때문에)

1. 점수 내림차순으로 정렬
2. 모든 원소를 탐색
3. 현재 과제의 마감일부터 내림차순으로 탐색해서, 비는 날에 해당 과제를 처리한다.

> 이때 과제를 처리할 수 있는 날을 탐색할 때,  
> 분리집합을 이용하면 더 최적화가 될 듯

2109  
위 문제랑 형식이 똑같음  
그런데 input이 크다.

위 두 문제를 두가지 방법으로 풀 수 있다.  
1. 마감일로 정렬 -> 우선순위 큐 이용  
   마감일이 낮은 것부터 탐색  
   현재 원소를 우선순위 큐 pq에 push
   pq의 top을 처리한다.  
   그리고 pq.top의 마감일이 
2. 점수로 정렬 -> 분리 집합 이용
   점수가 높은 것부터 탐색  
   해당 원소를 최대한 마감일에 가깝게 처리한다.  
   (이때 마감일 전에 해당하는 날짜를 찾기 위해 분리 집합 적용)

---

### 문제를 풀면서 나온 팁들

맨 처음에는 주어진 예시를 한번 풀어보는게 좋다.  
그리고 예시를 풀면서 내가 어떻게 접근했는지를 의식하면서 푼다면,  
최적해를 그나마 쉽게 찾을 수 있다.

경우의 수가 많아 풀기 힘들다면,  
한쪽을 정렬해서 풀면 수월해질 수도 있다.

이제는 문제를 분석하는 건 괜찮아서,  
문제에 맞는 자료 구조를 떠올리는게 중요해진 것 같다.  
(map, set, unordered_map, unordered_set, priority_queue 등)

> 그리고 아직까지 list가 유용하게 쓰이는 문제를 발견하지는 못했다.

---

## 한번 더 생각해볼 문제들

1946 - 한쪽을 정렬해서 편하게 푸는 케이스

3109 - 그리디와 DFS 같이 쓰는 문제  
(마킹하는 걸 못 떠올렸다)  
(DP만 적용해서는 불가능한 문제)

1041 - 최적해는 간단한데, 주사위 이용하는게 귀찮다

13904, 2109  
그리디인데, 두가지로 풀 수 있음  
(우선순위 큐, 분리 집합)