### 1082 방번호

https://www.acmicpc.net/problem/1082

> n개의 숫자에 대한 값이 주어졌을때, m원을 이용해서 최대한 큰 숫자를 만드는 방법을 만들어라
>
> 3<br>
> 6 7 8<br>
> 21<br>
> 답: 210(8/7/6)

사용한 알고리즘: DP, 문자열

시간복잡도: $O(m^2)$

완탐으로 시작

find(num, money) = num번째 위치에서 money원을 이용해서 만들 수 있는 최대의 숫자를 반환

$find(num, money) = max^n_{L=1}(L + find(num+1, money-room[i]))$

뽑은 숫자를 앞에 두는 이유: 만약 1과 2를 살 수 있다면, 위 답은 12와 21중 max값인 21을 고를것이다.<br>
-> 순서가 바껴도 알아서 체크가능

따라서 굳이 순서에 제한을 줘서, 간단하게 정리가능

    여기서 주의할 점
    첫번째 값은 0번 숫자에 대한 값이기 때문에
    처음부터 0을 사면 안됨(숫자가 2개 이상일때) - 021(x), 210(o)
    따라서 처음부터 재귀로  시작하지 않고 for문을 1부터 시작하도록 세팅
    (재귀에서는 0부터 for문 시작함, 자릿수는 0상관없기 때문)
    (만약 0만 살수 있다면 답은 0, 예외 처리 해줘야함)

여기서 dp를 적용

m의 최댓값이 50이기 때문에 50x50 크기의 string type cache 선언하면 됨(최대 50자리라서 행도 50)

(이때 string type이라 초깃값 확인이 어렵기 때문에, 따로 bool type 50x50 크기의 visited 선언)

---

### 1213 펠린드롬 만들기

https://www.acmicpc.net/problem/1213

사용한 알고리즘: 덱, 문자열

시간복잡도: $O()$

1. 문자열을 탐색하여, 각 문자들의 빈도를 저장
2. 특정 문자의 빈도 수가 홀수인지 체크  
    2-1 홀수라면 프로그램 종료
3. 각 문자들의 빈도를 정렬(0이 아닌 문자들이 앞으로, 아스키코드가 큰 순으로)
4. 빈도 수가 홀수인 문자를 덱에 저장
5. 정렬한 문자들을 바탕으로 덱 완성  
    5-1 (문자는 짝수개로 있음) 덱의 front와 back에 현재 문자 push  
    5-2 현재 문자의 count 2 빼줌

> 정렬할 때 bool 함수 구현이 헷갈렸음
> 
> return a < b - 내림차순
> return a > b - 오름차순(default)

---

### 1309 동물원


💡 2*n 우리가 있을때 넣을수있는 사자의 경우의수를 구하는 문제



dp[0][n] = dp[0][n-1]+dp[1][n-1]+dp[2][n-1]

dp[1][n] = dp[0][n-1]+dp[2][n-1]

dp[2][n] = dp[0][n-1]+dp[1][n-1]

답: dp[0][n]+dp[1][n]+dp[2][n]

풀이

n번째 우리에서의 경우의 수는

n-1 우리에서 바로전 우리(n-1번째 울타리)에 사자가 있을때, 왼쪽에 있을떄, 오른쪽에 있을때

가 0,1,2 면

0에서 n번째 울타리에 사자를 안 넣거나, 왼쪽에 넣거나, 오른쪽에 넣거나

1에서 n번째 울타리에 사자를 안 넣거나, 오른쪽에 넣거나

2에서 n번째 울타리에 사자를 안 넣거나, 왼쪽에 넣거나

즉 n번째 울타리에 사자를 안넣은 경우의 수 - 0+1+2 (n-1 기준)

즉 n번째 울타리에 사자를 왼쪽에 넣은 경우의 수 - 0+2 (n-1 기준)

즉 n번째 울타리에 사자를 오른쪽에 넣은 경우의 수 - 0+1 (n-1 기준)

식을 정리하면

dp[0][n]+dp[1][n]+dp[2][n] = (dp[0][n-1]+dp[1][n-1]+dp[2][n-1])*2 + dp[0][n-1]

= dp[n-1]*2+dp[n-2] (깔끔)

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 1339 단어 수학

https://www.acmicpc.net/problem/1339

사용한 알고리즘: 그리디

시간복잡도: $O(nk)$ - n=단어개수, k=단어길이

과정
1. 단어들 길이로 내림차순 정렬
2. 단어 앞자리부터 가중치를 부여
3. 가중치순으로 알파벳에 숫자 입력
4. 알파벳에 입력된 숫자들을 바탕으로 문자를 숫자로 바꿔서 결과 출력

>
    2번 과정 설명
    
    ABCDA  
     DBCA  
      BAA
     
    위 단어들이 입력으로 주어졌을 때 2번 과정  
    
    1247(10)  
     358(11)   
      69(12)
    

> 이때 유의할 점   
> 가중치 부여할 때 유의해야 한다.
>
> ex)  
> BA 1개와 A 11개가 있으면  
> A가 B보다 가중치가 높아야 한다.
>
> => 자리수 올라갈 때, 가중치 * 10




---

### 1347 미로 만들기

https://www.acmicpc.net/problem/1347

> 주인공이 이동한 경로가 주어졌을 때, 해당 미로의 지도를 출력하라<br>
> (주인공은 이동할 수 있는 모든 곳을 다녔고, 미로의 모든 행과 열은 벽이 아닌 칸이 최소 한개는 존재한다)

사용한 알고리즘: 구현

시간복잡도: $O(n^2)$

주인공이 이동한 경로로 미로의 지도를 출력하는건 쉽지만,

처음 주인공의 위치가 주어지지 않아서 당황했다.

여기서 `모든 행과 열에는 적어도 하나의 이동할 수 있는 칸이 있다`이 말을 보고 문제를 풀 수 있었다.

경로의 최대 길이가 50이라서, 150x150정도의 크기인 2차원 배열에서, 주인공은 가운데서 시작한다.

경로대로 움직이면서, 주인공이 방문한 곳을 모두 표시하고, 주인공이 움직인 위치에서 행의 최댓값&최솟값, 열의 최댓값&최솟값을 모두 기록했다.

그 값들이 결과를 출력할 때의 범위가 된다. (모든 행과 열에는 적어도 하나의 이동할 수 있는 칸이 있기 때문)

    역시 문제를 제대로 봐야 한다.

---

### 1520 내리막길 & 1937 욕심쟁이 판다


💡 그래프와 dp가 섞인 문제

1520은 경우의수, 1937은 경우의수중 최댓값 구하는 문제



2차원 배열이 주어지는데, 각 위치마다 값이 있고

상하좌우의 값을 비교해서 값보다 작다면(크다면) 이동할수 있음

그상황에서 가장 많은 경우의 수 or 최대 이동값을 찾는 문제

⇒ 우선순위 큐를 이용, 내림차순(오름차순)으로 정렬후 한개씩 받아서 현재위치 dp값+1이

다음위치 dp값보다 크다면 저장함.

이게 성립하는 이유는 (내림차순 기준), 무조건 값이 작을때만 이동할수 있기때문에, 가장 큰값을 쓰면 그 위치는 다시 갈수없다. 따라서 dp가 적용됨

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 1722 순열의 순서

https://www.acmicpc.net/problem/1722

사용한 자료구조 & 알고리즘: 구현, 조합

시간복잡도: $O(n^2)$

(숫자 하나 받고 그 숫자에 해당하는 순열 출력하는 문제 가정)

N = 4인 순열은

(1,2,3,4), (1,2,4,3), (1,3,2,4), (1,3,4,2), (1,4,2,3), (1,4,3,2), (2,1,3,4), ...

여기서, 전체 24개 중에, 6(=24/4)개씩 앞자리 숫자가 같다. (1, ...) 6개, (2, ...) 6개, (3, ...) 6개, (4, ...) 6개  
그 다음으로 (1, ...)에서, 전체 6개 중에, 2(24/(4*3))개씩 순서가 같다. (1,2, ...) 2개, (1,3, ...) 2개, (1,4, ...) 2개

따라서 인풋 K가 몇보다 크고 몇보다 작냐에 따라서 순열을 예측할 수 있다.

> N = 4, K = 3
> 
> 0 < K <= 6 -> 첫번째 숫자 1  
> 2 < K <= 4 -> 두번째 숫자 3, (K -= 2)  
> 0 < K <= 1 -> 세번째 숫자 2  
> 마지막 숫자 4

1. K가 몇보다 크고 몇보다 작은지 구한다.
2. 순서를 찾아서, 순서에 해당하는 숫자를 찾는다.
3. 위의 과정을 반복

> 순열의 특징을 이용한 문제  
> 특징을 잡는건 빨랐는데, 이를 코드로 구현하는데 시간이 지연됐다.  
> 역시 제대로 설계를 해놓고 코드 구현을 해야 한다.

---

### 1725 히스토그램

https://www.acmicpc.net/problem/1725

> 막대그래프가 주어졌을때 막대그래프에 대해, 가장 큰 직사각형의 넓이를 구하는 문제

사용한 알고리즘: 분할 정복

시간복잡도: $O(nlgn)$

종만북을 보면서 이 문제를 풀 수 있었다.

브루트포스는 $O(n^2)$이 걸리지만, 분할정복을 사용해서 시간복잡도를 더 줄일 수 있었다.

    가운데 좌표를 기준으로
    1. 왼쪽 블럭만으로 구하는 최대 넓이
    2. 오른쪽 블럭만으로 구하는 최대 넓이
    3. 가운데 좌표를 포함했을때 구하는 최대 넓이

    위 세가지중 최대 넓이가 정답이다.

가운데 좌표를 포함하는 직사각형의 최대넓이를 구하는 방법은,<br>
가운데에서 시작해서, 왼쪽 높이와 오른쪽 높이를 비교해서 더 높은쪽으로 좌표를 옮긴다.(투포인터)

위 방법을 계속하면 최대 넓이를 구할 수 있다.

    왼쪽 오른쪽 좌표를 옮길때 좌표가 범위를 벗어나는 걸 생각해야하는데
    처음부터 이를 포함해서 if문을 짜지 말고,
    한개씩 전부다 if문으로 일일이 짜주자
    그래야 빠르다

---

### 1806 부분합
> n개의 자연수로 이루어진 수열이 주어졌을때, 
> 이 수열에서 연속된 수들의 부분합 중에 그 합이 s 이상 되는 것중 가장 짧은 것의 길이를 구하는 문제

시간복잡도 $O(n)$
두개의 포인터 l,r (l=0, r=1), result = MAX (MAX > n)

l번째 위치부터 r-1번째 위치까지의 합을 cur이라 하면

cur < s 일때 l++

cur >=s 일때 r++,
현재 r - l 이 result보다 작다면 result = r - l

답은 result

---

### 1915 가장 큰 정사각형


💡 2차원 배열이 주어졌을때, 해당 배열중 가장 큰 정사각형의 넓이를 찾는 문제



나는 누적합을 이용해서 겨우 풀었지만

dp를 이용한 방법은 몰랐다.

if (board[i][j] == '1') dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;

dp는 해당 위치에서의 정사각형의 최대 길이

풀이

1 1

1 1

이 정사각형이 있다면, min(1,min(1,1))+1 = 2

1 1

0 1

이라면, min(1, min(0,1)) + 1 = 1

결국 모두 1로 채워져야 최대값이 갱신된다.

dp는 많이 풀어봐야 한다.

---

### 2239 스도쿠

https://www.acmicpc.net/problem/2239

> 9x9 스도쿠 판 주어졌을 때, 스도쿠를 채워서 출력하는 문제  
경우의 수가 여러 개라면, 값이 가장 작은 걸 출력

사용한 알고리즘: 구현 & 백트래킹

시간복잡도: 모르겠음... (재귀라서...)  
worst case는 9^81 예상이지만 실제로는 매우 작음

값이 가장 스도쿠 출력하려면, 앞 칸부터 작은 숫자를 넣어봐서 체크하면 된다.

스도쿠 법칙은 알고있어서 설계하는 건 어렵지 않았다.

문제는
1. 재귀라서 시간복잡도 예측이 제대로 안됐음  
-> 그냥 구현했는데 통과...
2. 재귀함수는 항상 예외(탈출 case)를 생각해야 하는데 놓쳤다...  
그래서 segfault로 2번 틀림

> 재귀함수를 사용한다면 항상 탈출 case를 생각하자.  
> 복붙 하고나서 눈을 부릅뜨고 체크해야 한다.

---

### 2293 동전 1


💡 n가지 종류의 동전이 주어졌을때, 이 동전을 이용해서 합이 k원이 되는 경우의 수를 구하는 문제

(동전은 무제한 이용 가능)



시간복잡도: $O(n)$

dp[0]=1 (0원일때의 경우의 수)

i - 0 ~ n-1 (모든 동전들 탐색)

j - 0 ~ k (0원부터 k원까지 탐색)

if(j ≥ coin[i])

dp[j] += dp[j - coin[i]];

dp[k]가 정답

풀이

1,2,5원을 이용해서 k원까지의 경우의수를 구하는 과정

1 - 1

2 - 11, 2

3 - 111, 12

4 - 1111, 112, 22

5 - 11111, 11122, 122, 5

…

여기서 4원을 보면 1원만 쓴 경우의 수와(1111),

2원에서 2를 더한 경우의 수(112, 22)

5원은 1원만 쓴 경우의 수(11111),

3원에서 2를 더한 경우의 수(11122, 122)에 5를 새로 추가

이를 점화식으로 표현하면

dp[i] = dp[i - coin[1]] + dp[i - coin[2]] + … + dp[i - coin[n]]

결국 dp[0]부터 … dp[k]까지 구하면 정답나옴

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 2294 동전 2


💡 n가지 종류의 동전이 주어졌을때, 이 동전을 이용해서 합이 k원이 될때 사용한 동전의 개수가 최소일때의 동전의 개수를 구하는 문제

(동전은 무제한 이용 가능)



시간복잡도: $O(n^2)$

dp[0]=MAX (못구함)

i - 0 ~ k (0원부터 k원까지 탐색)

j - 0 ~ n-1 (모든 동전들 탐색)

if (coin[j] ≤ i)

dp[i] = min(dp[j], dp[i - coin[j]] + 1);

풀이

1,2,5원이 있을때

3원은 1원3개 or 1원,2원으로 구할수있음

5원은 1원5개,1원1개,2원2개, 1원3개,2원1개, 5원1개로 구할수있음

여기서 5원은 3원+2원 or 4원+1원임

따라서 점화식은

dp[i] = min(dp[i-coin[1]], dp[i-coin[2]], … , dp[i-coin[n]]) + 1이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 2504 괄호의 값

https://www.acmicpc.net/problem/2504

> (, ), [, ] 로만 이루어진 문자열이 주어졌을 때, 해당 문자열의 점수를 구하는 문제  
() = 2, [] = 3, (x) = 2x, \[y] = 3y  
올바르지 않은 괄호는 0 - ([)], ()( 등

사용한 알고리즘: 문자열, 재귀

시간복잡도: 거의 $O(n^2)$ 이지만, 구현 문제라 인풋이 작음

올바르지 않은 괄호를 찾아내는 것이 귀찮은 문제였다.  

올바르지 않은 괄호의 특징 
- (, [의 개수와 ), ]의 개수가 다르다 - 짝이 안맞는다
- 순서가 겹친다 - [ ( ] ), ) (

그리고 점수를 계산할 때 재귀 함수를 이용했다.  

```cpp
int countResult(int s,int e) {...} // [s, e) 에 해당하는 점수를 반환하는 함수
// 1. 첫번째 괄호를 찾는다
// 2. 첫번째 괄호와 맞는 괄호를 찾는다.
// 3. 점수 계산
// 3-1. 두번째 괄호가 끝에 있다면,  그 안의 재귀를 호출하면서 반환
// 3-2. 끝이 아니라면, 찾은 괄호의 점수(재귀 호출)와 그 다음 위치의 점수(재귀 호출)를 더해서 반환
```

문제를 풀면서, 설계와 구현을 같이 하다보니 시간이 지체됐다.  
수도코드로 완전히 설계를 한 뒤, 구현을 하는 것이 훨씬 효율적으로 풀 수 있다 생각했음.

---

### 2565 전깃줄


💡 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 구하는 문제



시간복잡도: $O(n^2)$

v[i] - {i번째 전깃줄 번호, 가리키는 전깃줄 번호}

sort(v, v.first순으로)

v.second로 LIS구하면 끝

풀이

v를 정렬후에 각각의 전깃줄이 가리키는 번호가

{8,2,9,1,4,6,7,10}일때 없애야 하는 전깃줄은

1,3,4이다.(1,2,3도 가능) 1,3,4를 없애면

{8,**2**,9,1,**4**,**6**,**7**,**10**} - 2,4,6,7,10이다.

이는 LIS를 구하는 문제랑 같음

그냥 LIS 실생활 응용문제였음

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 2602 돌다리 건너기

https://www.acmicpc.net/problem/2602

> 두줄의 돌다리가 주어지고, input이 주어졌을떄 돌다리를 input 순서대로 건널수있는 경우의 수를 구하는 문제
>
> 1. 한번 밟고 반대쪽의 돌다리를 밟아야 한다.
> 2. 밟을때마다 무조건 다음칸으로 이동해야 한다.(같은줄밟기 안됨)

사용한 알고리즘: DP

시간복잡도: $O(n)$

// c={0,1}, cnt={0~input길이}, n={0~돌다리길이}
find(c, cnt, n) = 현재 위치에서 돌다리를 건널수 있는 경우의 수를 반환

현재 위치에서 cnt번째 input과 n번째 돌다리의 문자가 같다면<br>
find((c+1)%2, cnt+1, n+1) + find(c, cnt, n+1) 반환

다르다면<br>
find(c, cnt, n+1) 반환

    같을때는 다음 돌다리를 구하는 경우의 수를 구해야하고, 현재 돌다리에서 다음 위치의 돌다리도 체크해야함

    다를때는 다음 위치의 돌다리만 체크하면됨

항상 결과 범위(int, long long), 범위 벗어나는지 체크하자

    이상한 값나오면 그건 잘못된 접근을 한것 - 범위 생각, 알고리즘은 관련없을 확률 높음

---

### 2616 소형기관차

https://www.acmicpc.net/problem/2616

> n개의 승객 정보와 소형기관차의 길이 m이 주어졌을때, 3개의 소형기관차에 승객을 연속해서 나눠 실을때 최대로 실을 수 있는 경우의 수를 구하는 문제

사용한 알고리즘: DP

시간복잡도: $O(n)$

처음에는 완탐으로 접근

그냥 3중for문으로 모든 조합에서 가장 최대값을 반환하도록 세팅<br>
시간복잡도 $O(_nC_3) => O(n^3)$이라 안됨

이를 dp로 변환하려 했지만, 못했음, 어디서 상태가 겹치는지 체크가 안됐음

그래서 정답을 봤다

find(x,cnt) = max(현재 기관차에 승객을 안 실었을때, 현재 기관차에 승객을 실었을때)<br>
find(x,cnt) = max(find(x+1,cnt), find(x+c, cnt+1)+ 승객 총합)

이 점화식은 해당 기관차를 쓰냐 안쓰냐, 둘 중하나에서 max 값을 찾는 식

사실 내식도 이 점화식과 비슷하다.

> 내식<br>
> find(x,cnt) = $max^n_{L=1}(find(x+c,cnt+1)+승객 총합)$
>
> 찾아본 점화식<br>
> find(x,cnt) = max(find(x+1,cnt), find(x+c, cnt+1)+ 승객 총합)

> 여기서 dp[cnt][x]가 의미하는 것
>
> cnt번 이후의 기관차부터 x번호 이상의 승객을 담을 수 있는 경우의 수 중 최댓값<br>
>> (여기서 이전 기관차와 지금 기관차는 관련이 없다)<br>
>> 1번 기관차가 1,2번 승객을 실든, 2,3번 승객을 실든<br>
>> 2번 기관차가 4번 위치에서 구할 수 있는 최댓값은 1번과 관련이 없다.<br>
>> (대신 1번보다 빠른 번호의 승객을 담을 순 없다)<br>
>> (기관차끼리는 순서가 의미가 없기 때문에 문제는 안됨)
>
>
> dp를 적용해서 $n^3$을 $3n$으로 줄임

> 그럼 원래 내가 썼던 식에서 dp를 적용할 수 있을까?
>
> for문 안에서 일일이 int& ret으로 dp를 설정가능하다.
> 근데 이건 좀 귀찮음..

---

### 2629 양팔저울

https://www.acmicpc.net/problem/2629

> n개의 추의 무게가 주어지고, m개의 구슬의 무게가 주어졌을때, 양팔저울과 n개의 추를 이용해 구슬들의 무게를 감별할 수 있는지 출력하는 프로그램을 작성하라

사용한 알고리즘: DP

시간복잡도: $O(n * sum)$ // 추들의 무게의 합 => 최대 30 * 15000

완탐으로 접근 시작

find(int cur, int num, int l, int r) = cur번째 구슬을 num번째 추까지 이용했을때 감별할 수 있는지 체크하는 함수

이때의 시간복잡도 = $O(3^n)$
> num번째 추를 왼쪽에 놓을지, 오른쪽에 놓을지, 안놓을지 3가지의 선택지가 생김

이제 cache를 이용해서 dp를 적용해야 하는데, 제대로 접근 못함 그래서 답 확인했음

cache[num][w] = num번째 추까지 이용했을때 w 무게의 구슬을 구별할 수 있는지 체크하는 변수

    일단 처음에는 cur번째 구슬을 이용해서 cache를 만들었는데 이럴 필요가 없음
    결국 추를 이용했을때 잴 수 있는 무게들은 정해져 있음 -> 구슬과는 관련이 없다.
    find(cur, num, l, r) -> find(num, l, r)
>
    find에서는 l과 r을 사용해서, 
    find(num+1, l+구슬무게, r)
    find(num+1, l, r+구슬무게)
    find(num+1, l, r)
    양쪽을 체크했지만, 이럴 필요가 없다.    

    find(num+1, w+구슬무게)
    find(num+1, abs(w-구슬무게))
    find(num+1, w)
    왼쪽에 놓으면 +, 오른쪽에 놓으면 -> 왼쪽에 - 해주면됨 & 절댓값, 그리고 안놓았을때
    이렇게 하면 간단해짐

---

### 2579 계단 오르기


💡 계단에 해당하는 점수가 주어졌을때 3번연속 밟지않고, 마지막 계단을 밟았을때의 최댓값 구하는 문제



시간복잡도: O(n)

방법1

1번 연속으로 밟았을때의

dp[i] = max(dp[1][i-2],dp[2][i-2])+x[i];

2번 연속으로 밟았을때의

dp[i] = dp[i-1]+x[i];

답: max(dp[1][n],dp[2][n])

방법2

dp - 현재 위치에서 계단 밟았을때의 최댓값

dp[i] = max(dp[i-2]+x[i], dp[i-3]+x[i-1]+x[i]);

답: dp[n]


💡 dp[i-1]을 사용하지 않고 x[i-1]을 사용하니까 3번연속금지에 위배되지않음



[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---
### 2636 치즈

https://www.acmicpc.net/problem/2636

> 문제 설명

사용한 알고리즘: bfs

시간복잡도: $O(n^3)$

이전에 이런 문제를 푼적이 있었다.<br>
https://www.acmicpc.net/problem/2638<br>
똑같은 문제였네

그냥 bfs를 이용하는 구현 문제,

여기서 치즈 안에 있는 구멍이랑, 치즈 밖에 있는 구멍을 구분해야 함

여기서 치즈를 보지말고, 가장자리에 붙어 있는 구멍을 보면됨

가장자리에 붙어 있는 치즈는 녹을 치즈

0,0에서 bfs돌리면 끝

그리고 치즈가 남았는지 체크할때 일일이 탐색하지 말고, 이전 bfs 과정중에 치즈 개수를 세주면됨

이전 치즈 개수 - 현재 제거되는 치즈 개수 => 이 값이 0이되면 break