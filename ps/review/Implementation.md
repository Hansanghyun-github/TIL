# 구현

그냥 문제를 잘 읽고, 이것을 코드로 구현하는 것들

> 그냥 많이 풀어보면 된다.  
> (감을 익히는 것이 중요하다)

---

## 인풋들을 저장하는 방식

> 2차원 배열 위에서 동작하는 문제라고 가정

1. 컨테이너에 각 정보를 저장
2. 2차원 배열에 저장

1번의 장점: 다양한 상태를 가지고 있는 인풋을 저장하기 적합  
1번의 단점: 각 인덱스와 2차원 배열의 위치를 매핑할 추가 자료구조 필요

2번의 장점: 각 원소의 위치를 바로바로 2차원 배열 위에서 확인 가능

// todo 문제 리뷰하고, 다시 다듬기

---

## 구현 문제들

14502  
1. 3개의 칸에 벽을 세운다.
2. BFS를 이용해 바이러스를 퍼뜨린다.
3. 안전 구역을 count 한다.
4. 위 과정을 1번의 모든 경우의 수에 대해 반복

1번의 시간복잡도가 높지만,  
인풋이 작아서 가능하다.  
(O(64C3))

15686  
1. 치킨 집들 중 M개만 남기고, 나머진 폐업시킨다.
2. 각 집들의 치킨 거리를 구한다.
3. 위 과정을 1번의 모든 경우의 수에 대해 반복

여기서 인풋은 2차원 배열로 주어지지만,  
집과 치킨집만 고려하면 되기 떄문에,  
각 집, 치킨집 정보를 컨테이너에 저장시키고 이를 이용해 문제를 푸는 것이 좋다.

> 여기서 2번 과정을 DP를 이용해 최적화를 할 수 있다.  
> (집과 치킨집 사이의 거리는 변하지 않기 떄문)

5430  
주어진 명령대로 배열을 뒤집거나 첫번째 원소를 삭제하면 된다.  
하지만 배열을 뒤집는 행위는 시간복잡도가 높다.  
이를 최적화하기 위해, 진짜로 뒤집지 않고 가상으로 뒤집는다.  
뒤집기 명령이 올 때마다 flag bit를 바꾼다.  
(flag=1 순방향, flag=0 역방향, 초깃값 flag=1)  
flag bit를 가지고 연산을 진행하면 최적화 가능하다.

> 맨 앞 원소나, 맨 뒷 원소를 삭제해야 하므로 덱을 이용한다.

14503

14500  
테트로미노의 모든 경우를 2차원 배열을 탐색하면서 풀면 된다.  
시간복잡도: O({테트로미노 개수} * N^2)

> 모든 테트로미노를 저장하는 건 귀찮다.  
> 여기서 특정 테트로미노만 가능한 것이 아니라  
> 모두 사용할 수 있기 때문에,  
> dfs를 이용해 현재 위치에서 최댓값을 구할 수 있다.

3190  
뱀을 나타내는 각 원소가 방향을 가지고 있다.  
큐를 이용해 구현한다.

16236  
BFS를 이용해 먹을 수 있는 물고기를 찾는데,  
모든 경우의 수를 탐색해야 한다.  
(우선순위를 이용해 찾는데, 모든 경우를 알아야 할 수도 있다)

16234  
BFS를 이용해 인접한 나라들을 탐색하고 인구를 이동시킨다.  
(BFS를 총 2번 사용)

14499  
주사위를 굴려서 이동하는 문제  
주사위를 굴릴 때, 주사위의 값을 바꾼다.  
그리고 윗면과 아랫면을 고정된 위치로 유지한다.  
(주사위의 값을 바꾸는 것은 상대적으로 쉽다)

13460  
최소 횟수를 구하는 문제이기 때문에 BFS를 이용한다.  
이때 구슬이 두가지이기 때문에 visited는 4차원 배열을 이용한다.  

> 이 문제에서 주의할 점  
> 1. 구슬이 연속해서 위치할 때, 뒤의 구슬이 앞 구슬 때문에 이동할 수 없는 경우를 고려해야 한다.  
>    (나는 이 경우를, 앞구슬을 먼저 움직인뒤 (잠깐만) 앞구슬을 벽으로 만들어 해결했다)
> 2. 1번의 경우 때문에, 구슬을 움직이는 순서를 고려해야 한다.  
>    (앞쪽의 구슬이 먼저 움직여야 한다)

14891  
톱니바퀴를 회전시키는 문제  
덱을 이용해 구현 - 회전하는 작업이 편해진다

12100  
블록을 이동시키는 문제  
dfs를 이용해 모든 경우의 수를 탐색한다.  

> 이때, 각 state 별로 보드의 상태가 다르기 때문에  
> 각각의 state 별로 보드를 복사해야 한다.  
> (board를 지역변수 temp에 복사)  
> 
> -> 보드의 크기가 작기 때문에 가능한 방법이다.

2573  
1년이 지나갈 때마다, 빙산을 녹이고 (1), 두 덩어리 이상으로 나눠지는지 (2) 확인한다.  
둘 다 BFS를 이용하는데,  
(1)은 바깥의 바다에서 시작하고,  
(2)는 빙산에서 시작한다.

15683  
경우의 수가 많지만 인풋의 범위가 작아  
브루트포스로 풀 수 있다.  
시간복잡도: O(4^8 * 8^2) = O(2^24) - 약 1600만

17144  
문제에 나온 대로 구현하는 문제  
(공기청정기를 동작시킬 때, 한 칸은 한번만 방문해야 한다 - for문 주의)

2504  
괄호를 이용해 점수를 계산하는 문제  
스택을 이용한다.  
`vector<bool, int>> s` - {괄호의 종류, 괄호의 위치}  
(괄호의 종류는 false, true로 표현)

2636  
BFS로 구현

15684  
사다리를 놓는 문제  
사다리를 놀 때 조합을 이용해야 한다.  
시간복잡도: O(300C3 * 300)

> 여기서 사다리를 놀 때,  
> 조합을 이용해야 시간초과가 발생하지 않는다.
> 
> (r,c)의 범위를 이전에 놓은 사다리의 위치를 이용해  
> 경우의 수를 줄여야 한다.
> 
> 만약 단순히 완탐으로 사다리를 놓는다면  
> 시간복잡도가 O(300^4)가 되어 시간초과가 발생한다.

17143  
문제에 나온대로 구현하면 되지만,  
상어를 이동하는 로직을 최적화해야 시간초과가 발생하지 않는다.

14719  
인풋의 범위가 작아 브루트 포스로 풀어도 시간초과가 발생하지 않는다.  
(빗물의 높이가 1일 떄부터 탐색)
1. 처음 위치부터, 현재 빗물 i보다 높은 곳 k을 찾는다.  
   (없으면 그대로 break)
2. k번쨰 위치부터 다음을 탐색한다.  
   높이가 i보다 작다, cur++;  
   높이가 i보다 높거나 같다, result += cur; cur=0;

16235  
각 인덱스별 나무 정보를  
덱큐나 우선순위 큐를 이용해 구현한다.

2239

20055  
문제에 나온대로 구현하는 문제  
(이 문제를 풀다가 로봇이 움직이고 바로 내리는 경우를 고려하지 않아서 틀렸다)

> 이 문제를 푸는 두가지 방법
> 1. 덱큐 이용(push_front, push_back 이용)
> 2. 시작 위치 인덱스만 이용해 구현  
>    (컨테이너는 변하지 않고, 인덱스만 업데이트)

---

## 다시 한번 볼 문제들

14499 주사위를 이용해 구현하는 문제

15684 조합으로 풀어야 시간초과가 발생하지 않는 문제

17143 상어를 이동하는 로직을 최적화하는 문제