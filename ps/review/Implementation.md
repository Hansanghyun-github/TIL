# 구현

그냥 문제를 잘 읽고, 이것을 코드로 구현하는 것들

> 그냥 많이 풀어보면 된다.  
> (감을 익히는 것이 중요하다)

---

## 인풋들을 저장하는 방식

> 2차원 배열 위에서 동작하는 문제라고 가정

1. 컨테이너에 각 정보를 저장
2. 2차원 배열에 저장

1번의 장점: 다양한 상태를 가지고 있는 인풋을 저장하기 적합  
1번의 단점: 각 인덱스와 2차원 배열의 위치를 매핑할 추가 자료구조 필요

2번의 장점: 각 원소의 위치를 바로바로 2차원 배열 위에서 확인 가능

// todo 문제 리뷰하고, 다시 다듬기

---

## 구현 문제들

14502  
1. 3개의 칸에 벽을 세운다.
2. BFS를 이용해 바이러스를 퍼뜨린다.
3. 안전 구역을 count 한다.
4. 위 과정을 1번의 모든 경우의 수에 대해 반복

1번의 시간복잡도가 높지만,  
인풋이 작아서 가능하다.  
(O(64C3))

15686  
1. 치킨 집들 중 M개만 남기고, 나머진 폐업시킨다.
2. 각 집들의 치킨 거리를 구한다.
3. 위 과정을 1번의 모든 경우의 수에 대해 반복

여기서 인풋은 2차원 배열로 주어지지만,  
집과 치킨집만 고려하면 되기 떄문에,  
각 집, 치킨집 정보를 컨테이너에 저장시키고 이를 이용해 문제를 푸는 것이 좋다.

> 여기서 2번 과정을 DP를 이용해 최적화를 할 수 있다.  
> (집과 치킨집 사이의 거리는 변하지 않기 떄문)

5430  
주어진 명령대로 배열을 뒤집거나 첫번째 원소를 삭제하면 된다.  
하지만 배열을 뒤집는 행위는 시간복잡도가 높다.  
이를 최적화하기 위해, 진짜로 뒤집지 않고 가상으로 뒤집는다.  
뒤집기 명령이 올 때마다 flag bit를 바꾼다.  
(flag=1 순방향, flag=0 역방향, 초깃값 flag=1)  
flag bit를 가지고 연산을 진행하면 최적화 가능하다.

> 맨 앞 원소나, 맨 뒷 원소를 삭제해야 하므로 덱을 이용한다.

14503

14500  
테트로미노의 모든 경우를 2차원 배열을 탐색하면서 풀면 된다.  
시간복잡도: O({테트로미노 개수} * N^2)

> 모든 테트로미노를 저장하는 건 귀찮다.  
> 여기서 특정 테트로미노만 가능한 것이 아니라  
> 모두 사용할 수 있기 때문에,  
> dfs를 이용해 현재 위치에서 최댓값을 구할 수 있다.

3190  
뱀을 나타내는 각 원소가 방향을 가지고 있다.  
큐를 이용해 구현한다.



---

## 다시 한번 볼 문제들