# 그리디 알고리즘

탐욕법은 가장 직관적임 알고리즘 설계 패러다임 중 하나입니다.  
탐욕법을 이용한 알고리즘은 우리가 원하는 답을 재귀 호출과 똑같이 여러 개의 조각으로 쪼개고,  
각 단계마다 답의 한 부분을 만들어 간다는 점에서 완전 탐색이나 동적 계획법 알고리즘과 다를 것이 없습니다.

그러나 모든 선택지를 고려해 보고 그중 전체 답이 가장 좋은 것을 찾는 두 방법과 달리,  
탐욕법은 각 단계마다 지금 당장 좋은 방법만을 선택합니다.

탐욕법은 `지금의 선택이 앞으로 남은 선택들에 대해 어떤 영향을 끼칠지는 고려하지 않습니다`.

---

실제로 최적해를 얻을 수 있는 접근이 직관적이지 않은 경우도 많기 때문에 실수에 더 유의해야 합니다.  
그러니 탐욕적 알고리즘을 연습 문제를 풀때는 알고리즘의 정당성을 증명하는 과정을 빼먹지 않고 연습하는 것이 좋습니다.

> 탐욕적 선택 속성(greedy choice property)  
> 동적 계획법처럼 답의 모든 부분을 고려하지 않고 탐욕적으로만 선택하더라도 최적해를 구할 수 있다는 것
> 
> 최적 부분 구조  
> 항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있음
> 
> 위 두가지를 증명해야 탐욕법을 적용할 수 있다.  
> (최적 부분 구조는 대부분 자명해서 증명할 필요가 없다고 한다)

---

## 그리디 알고리즘 문제들

2839  
봉지의 개수를 줄이려면, 최대한 5킬로 봉지를 많이 사용해야 한다.  
-> 5킬로 봉지 개수를 줄이면서, 가능한 경우를 탐색한다.

11399  
최솟값을 구하려면, 인출 시간이 짧은 사람은 앞에 둬야 한다.

11047  
동전 개수를 줄이려면, 최대한 가치가 높은 동전을 사용해야 한다.  

1931  
회의 개수를 최대로 하기 위해, 끝나는 시간이 빠른 회의를 먼저 담아야 한다.  

1541  
값을 최소로 하기 위해, 마이너스 부호 뒤의 수를 최대한 키워야 한다.  
-> 다음 마이너스 부호가 오기 전까지의 숫자를 모두 괄호로 묶는다.

1026  
S의 최솟값을 구하려면, 가장 큰 수에는 가장 작은 수를 곱해줘야 한다.

5585, 2217

1789  
서로 다른 N개의 자연수의 합이 S일때, N이 최대려면,  
결국 1부터 N까지 더한다고 가정해야 한다.  
(N을 제외한 모든 수는 최소가 되야 하기 때문)  
-> 1 + ... + N 이 S를 넘어설 때의 N(or N-1)이 정답이다.

1715  
최대한 적은 수를 먼저 사용해야 한다. (우선순위 큐 이용)

16953  
A를 B로 바꾸는 문제인데,  
B를 A로 그리디하게 바꾸면 간단하게 풀 수 있다.  
B의 끝이 1 -> 1 뺀다, B의 끝이 짝수 -> 2 나눈다.  
(그 외의 수는 -1 처리)

1439  
그냥 0일 때와 1일 때의 개수를 세서 최소인 값을 반환하면 끝

1946  
면접과 서류 순위에서, 다른 지원자의 성적보다 떨어지지 않는다면 뽑는다.  
-> 한쪽 순위를 정렬해놓고 비교하면 편해진다.  
1. 면접 순위 오름차순으로 정렬
2. i번째 사람은 왼쪽 사람들 보다 서류 순위가 높으면 뽑는다.  
   (오른쪽 사람들보다 면접 순위가 높기 때문에)

1339  
맨 앞자리 알파벳부터 가중치를 부여한다.  
가중치 내림차순으로 9~1 숫자를 부여해서 계산한다.

1202  
기존 배낭 문제에서, 배낭의 개수가 늘어난 케이스  
여기서 가방에 보석은 딱 1개만 넣을 수 있다는게 핵심이다.  
-> 보석과 가방을 최대한 딱 맞게 넣어야 한다.  
(무게가 5인 보석을 중량이 10인 가방 보다는 6인 가방에 넣는 것이 더 이득이다)
1. 보석을 가치 내림차순으로 정렬
2. 가방을 무게 오름차순으로 정렬
3. 가치가 높은 보석순으로 가장 딱 맞는 가방을 탐색한다. (lower_bound)

1744  
수를 두개씩 묶어서 합을 최대화 하려면, 몇가지 규칙이 있다.  
(두 수를 묶다 -> 두 수를 곱한다)
1. 2 이상의 양수는 큰 놈들 끼리 묶는 것
2. 음수가 2개 이상이라면, 최대한 큰 놈끼리 묶는 것
3. 음수가 홀수개 이고 0이 있다면, 절댓값이 가장 작은 음수와 0을 묶어야 한다.
4. 2 이상의 양수 1개와 1이 있다면, 둘은 묶지 않아야 한다. (그냥 더하는게 더 크다)

11000  
적용하는 최적해 - '끝나는 시간과 다음으로 시작하는 시간의 텀이 최대한 짧아야 한다'  

> 나는 map 으로 일일이 업데이트 하려 했지만,  
> 우선순위 큐 쓰는 방법도 있었네  
> (어차피 시간복잡도는 둘 다 같다)

1049  
m개의 가격이 주어지지만, 결국 제일 낮은 가격을 고르면 된다.  
여기서 주의해야 할 것
1. 6개 묶음 가격이 낱개 6개의 가격보다 높을 수 있다.
2. 5개 이하가 필요해도, 낱개로 사는 것보다 6개 묶음으로 사는게 더 저렴할 수 있다.

14916  

1213  
문자열이 팰린드롬이 되게 조합하려면,  
홀수개인 문자는 1개 이하여야 한다.  
그리고 사전순으로 가장 앞서는 걸 출력해야 하기 때문에,  
가장 값이 작은 문자 먼저 출력해야 한다.

1449  
숫자들을 정렬해서  
테이프 길이와 위치를 비교하면서 결과를 구할 수 있다. 

12904  
A 문자열에서 B 문자열을 만들지 않고,  
규칙의 반대로 B 문자열에서 A 문자열로 만들면 된다.

2812  
앞자리 부터 K개 중에 가장 큰 수를 찾는다.  
해당 자리 이전의 숫자를 모두 지우고, 지운만큼 K--  
다시 다음 자리부터 K개 중에 가장 큰 수를 찾고, 지운다.

1700  
해당 물건이 이미 플러그에 있거나, 플러그가 빈 곳이 있다면 넣고 continue  
플러그의 물건을 바꿔야 한다면, 물건들 중에서 가장 나중에 나오는 물건과 바꾸면 된다.

3109  
여기서 적용되는 최적해 - '최대한 위에서 위로 이동해야 한다?'

> 경우의 수를 높이려면, 최대한 위로 바짝 붙어서 이동해야 한다.  
> (겹치면 안되기 떄문에)

이때 이전 위치가 이동한 경로에 마킹을 함으로써,  
시간복잡도를 줄일 수 있다.  
(O(RRC) -> O(RC))

> 이동할 때마다, 성공 여부에 관계없이 마킹해도 문제 없는 이유  
> 
> 성공했을 때 마킹 -> 이미 지나간 곳이므로 겹칠 수 없어서 마킹 해야 한다.  
> 실패했을 때 마킹 -> 해당 자리는 실패하는 자리이므로 마킹을 해서 방지한다.

      맨 처음 나는 이 문제를 DP만 이용해서 풀려고 했다.  
      (이전 열에서 현재 열로 이동할 수 있으면 바로 이동하게 함, 위부터 아래로 우선순위)  
      하지만 이 접근은 틀린 접근이다.

      이유: 이전 열과 현재 열의 관계만으로 최적해를 구할 수 없다.
      (최적 부분 구조가 성립되지 않는다)

      DP가 틀리는 케이스
      3 5
      .x.x.
      ..xx.
      .x...

      3번째 열에서 이전 위치의 파이프는 아래로 이동해야 한다.
      하지만 0,3 위치에서 먼저 가져갔기 때문에 
      2,3 위치에서 가져가지 못하게 된다.
      -> 답이 1이 아닌 0이 나온다. (x)

      그렇다고 0,3 2,3 둘다 가져간다? -> 그러면 다른 예시에서 답이 더 크게 나올 수 있다.
      결국 직접 한개씩 이동하면서 답을 구해야 한다. -> DFS

10775  
적용되는 최적해 - '현재 비행기를 최대한 큰 번호의 게이트에 도킹 시켜야 한다'  
(번호가 작은 비행기는 도킹 시킬 수 있는 게이트가 적기 때문이다)  
도킹 할 수 있는 게이트를 찾기 위해 분리 집합을 사용한다.

1417  
적용되는 최적해 - '득표수가 가장 높은 후보의 표를 뺏어와야 한다'  
이때 우선순위 큐를 사용해 편하게 풀 수 있다.

1092  
적용되는 최적해 - '현재 크레인이 들 수 있는 가장 무거운 박스를 선택한다'  
박스들, 크레인들을 무게순으로 정렬한 다음,  
모든 박스가 옮길 수 있는 크레인 들 중 cnt가 가장 작은 크레인을 골라서, cnt + 1 해준다.  
(이때 최대한 작은 크레인을 골라야 함)

1041  
적용되는 최적해 - '최대한 작은 조합의 주사위 면들을 이용한다'  
면이 1개가 쓰이는 주사위 -> 가장 작은 값 이용  
면이 2개가 쓰이는 주사위 -> 가장 작은 2개의 값 조합 이용  
면이 3개가 쓰이는 주사위 -> 가장 작은 3개의 값 조합 이용

-> 결국 입력된 주사위 값을 이용해, 가장 작은 값을 찾아서 구해주면 된다.

13904  
적용되는 최적해 -> '점수가 가장 높은 과제를 최대한 늦게 처리한다'  

> 접근 방법  
> 마감일이 제일 짧은 것 중, 점수가 제일 높은 걸 해야 한다.  
> 하지만 점수가 높은 것들이 전부 마감일이 늦어도 괜찮을 것일 수도 있다.  
> -> 오히려 마감일이 짧은 것들은 전부 할 필요가 없을 수도 있다. (점수가 낮아서)  
> -> 마감일 순으로 정렬한 다음, 앞이 아닌 뒤부터 탐색한다.
> 
> 어차피 마감일이 남은 과제는, 마감일에 하든 마감일 전날에 하든 점수는 같다.  
> -> 최대한 뒤로 미룬다.  
> (전날에는 다른 과제를 해야할 수 있기 때문에)

1. 점수 내림차순으로 정렬
2. 모든 원소를 탐색
3. 현재 과제의 마감일부터 내림차순으로 탐색해서, 비는 날에 해당 과제를 처리한다.

> 이때 과제를 처리할 수 있는 날을 탐색할 때,  
> 분리집합을 이용하면 더 최적화가 될 듯

2109  
위 문제랑 형식이 똑같음  
그런데 input이 크다.

위 두 문제를 두가지 방법으로 풀 수 있다.  
1. 마감일로 정렬 -> 우선순위 큐 이용  
   (cnt = 마감일이 가장 높은 것)  
   (우선순위 큐 pq는 점수의 내림차순 정렬)  
   마감일 내림차순으로 탐색  
   cnt > d[i] && !pq.empty(), 현재 우선순위 큐 pq의 top들을 계속 pop & result에 더해줌 & cnt--;  
   p[i] 를 pq에 push, pq의 top을 result에 더해줌 & cnt--;
2. 점수로 정렬 -> 분리 집합 이용  
   점수가 높은 것부터 탐색  
   해당 원소를 최대한 마감일에 가깝게 처리한다.  
   (이때 마감일 전에 해당하는 날짜를 찾기 위해 분리 집합 적용)

1781  
위 문제랑 형식이 같음  
여기서 데드 라인과 점수의 범위가 크다.

2457  
(3/1 부터 11/30 까지 최소 한개 이상 꽃이 피어 있어야 한다)  
적용되는 최적해 - '오늘 심을 꽃을 고를 때, 최대한 늦게 죽는 꽃을 고른다.'  
0. 꽃들을 피는 날짜의 오름차순으로 정렬
1. 3/1 이전 날짜에 피는 꽃의 원소까지 탐색
2. 현재 심을 수 있는 꽃들 중에 가장 늦게 죽는 꽃을 고른다.
3. 고른 꽃이 죽는 날짜까지 이동
4. 위 과정 반복

여기서 몇가지 예외 사항을 고려해야 한다.
1. 시작날짜, 종료날짜 모두 3/1 보다 작을 때
2. 시작날짜가 3/1보다 작은 꽃이 없을 때
3. 현재 꽃의 죽는 날짜보다, 시작 날짜가 작은 꽃이 없을 때

8980  
적용되는 최적해 - '목적지가 가장 짧은 박스부터 우선적으로 담는다'  
마을에 도착할 때마다, 목적지가 가장 짧은 박스들부터 담는다.  
(이때 이전부터 가지고 있던 박스들도 다시 내렸다가 담는다 - 현재 위치의 박스들의 목적지가 더 가까울 수 있으므로)

19598  
적용되는 최적해 - '시작시간, 끝나는시간 오름차순으로 탐색한다'  
끝나는 시간을 담은 우선순위 큐를 이용한다.  
(시작시간, 끝나는시간을 기준으로 정렬)  
pq.top() > t[i], pq.push(t[i])  
(모든 회의실의 끝나는 시간이 현재 회의보다 늦다 -> 새로운 회의실이 필요하다)  
pq.top() <= t[i], pq.pop() & pq.push(t[i])  
(현재 회의보다 빨리 끝나는 회의실이 있다 -> 해당 회의실 이용)  
pq의 size가 정답이 된다.

1826  
적용되는 최적해 - '현재 갈 수 있는 주유소들 중에서 기름을 가장 많이 주는 곳을 우선적으로 간다'  
여기서 핵심은 최대한 기름을 많이 확보해야 한다.  
1. 현재 기름 값보다 거리가 작은 주유소들 중에 가장 기름을 많이 주는 곳을 탐색
2. 해당 주유소에서 주유한 뒤에 1을 다시 실행

위 기능을 구현하기 위해 우선순위 큐를 적용

19539  
(2는 11이 될 수 있지만, 11은 2가 될 수 없다)  
2를 뿌리는 횟수가 N보다 크거나 같으면 OK

1135  
적용되는 최적해 - '최솟값이 큰 노드부터 탐색한다'  
이 문제는 그리디가 있다고 하지만, 트리 & DP가 핵심인 문제  
각 직원이 전화하는 횟수의 최솟값을 부모에게 반환해서 구한다.  
부모는 자식들로 부터 최솟값들을 받아서 현재 노드의 최솟값을 구한다.  
(이때 그리디가 적용된다 -> 모든 사원이 전화를 받아야 하기 떄문이다)

> 현재 노드와 이미 탐색한 자식 노드가 동시에 탐색할 수 있다.  
> -> 최솟값을 만들려면 최솟값이 큰 자식노드부터 탐색해야 한다.

11256

1493  
적용되는 최적해 - '가장 큰 큐브부터 사용한다'  
가장 큰 큐브를 채운다음, 남은 부분은 3부분으로 나눠서 채운다.

> 가장 큰 큐브를 먼저 사용해도 되는 이유는  
> 모든 큐브가 정육면체이기 때문이다.
> 
> 작은 큐브를 먼저 적용해야 최적이 되는 경우는 없다.  
> (만약 직사각형이라면, 작은 큐브를 먼저 적용해야 할 수도 있다)

1422  
적용되는 최적해 - '가장 큰 수를 가장 많이 사용한다'  
이때 각각의 숫자를 배치하는 경우의 수를 고려해야 한다.  
(숫자를 뒤에 붙이는 경우, 앞에 붙이는 경우)  

> K개의 숫자를 배치하는 경우만 생각하면  
> N개의 숫자를 배치하는 것은 문제가 없다.
> 
> 가장 큰 숫자를 같은 위치에 여러번 배치하면 된다.
> 
> A, B, C 중 A가 가장 크고 BAC가 가장 크게 만드는 배치라면,  
> 정답은 BA...AC가 된다.  
> (A를 같은 위치에 N-K+1번 배치)

이때 가장 크게 만드는 배치를 찾기 위해  
모든 숫자를 비교한다.  
(A와 B를 비교할 때, AB BA 중 더 큰 것을 선택)  

> 여기서 AB, BA를 비교할 때 string 타입으로 비교해도 된다.  
> (두 문자열(AB, BA)는 길이가 같기 때문에, 숫자로 비교하는 것과 같은 결과를 낸다)

1727  
적용되는 최적해 - 'i < j 라면, s[i] < s[j] 여야 한다'  
DP 를 이용해 풀 수 있다.  
(그리디를 적용함으로써 DP로 풀 수 있다)

2879  
적용되는 최적해 - 부호가 같은 원소끼리 최대한 묶어서 처리한다.  
따라서 부호가 달라질 때마다 기존 diff를 더해주면 된다.

> 이때 조심해야 할 부분이 있다.
> 
> 부호가 같아도 차이가 다를 때, 안 묶일 수 있다.
> 
> 5 1 5  
> 0 0 0  
> 답은 5가 아니라 9다.  
> (가운데 1로 인해 양쪽 5가 묶일 수 없다)

2513  
여기서 적용되는 최적해:
1. 방향이 반대인 두 곳은 따로 처리한다.
   (같이 태우는 것은 최적의 경우가 아니다)
2. 가장 먼 곳의 사람부터 태운다

> 가까운 사람부터 태우면  
> 경우의 수가 많아, 최적으로 태울 수 없다.

1464  
무조건 1부터 k까지 뒤집는 행위를 k가 1일 때부터 N까지 수행한다.  
k-1까지 사전순으로 정렬된 문자열의 첫번째 문자와 k번째 문자를 비교하여 풀 수 있다.  
(dp - 이전 위치까지 사전순으로 정렬된 문자열, s[k] - k번째 문자)  
1. dp[0] < s[k], dp = dp + s[k]
2. dp[0] > s[k], dp = s[k] + dp

> 위 작업을 덱큐를 이용해 최적화할 수 있다.

---

### 문제를 풀면서 나온 팁들

맨 처음에는 주어진 예시를 한번 풀어보는게 좋다.  
그리고 예시를 풀면서 내가 어떻게 접근했는지를 의식하면서 푼다면,  
최적해를 그나마 쉽게 찾을 수 있다.

경우의 수가 많아 풀기 힘들다면,  
한쪽을 정렬해서 풀면 수월해질 수도 있다.

> 그리고 아직까지 list가 유용하게 쓰이는 문제를 발견하지는 못했다.

그리고 인풋이 항상 정렬된 상태로 주어지는 것이 아니다.

---

## 한번 더 생각해볼 문제들

1946 - 한쪽을 정렬해서 편하게 푸는 케이스

3109 - 그리디와 DFS 같이 쓰는 문제  
(마킹하는 걸 못 떠올렸다)  
(DP만 적용해서는 불가능한 문제)

1041 - 최적해는 간단한데, 주사위 이용하는게 귀찮다

13904, 2109, 1781  
그리디인데, 두가지로 풀 수 있음  
(우선순위 큐, 분리 집합)  
(여기서 1781은 수의 범위가 크다)

1826  
그리디가 정석이지만, DP도 가능한 문제(인풋이 크지 않아서)

1493

1422

1727 - 그리디를 적용해야 DP로 풀 수 있는 문제

1464 - 아이디어가 중요한 문제