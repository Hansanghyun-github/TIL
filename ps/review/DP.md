# DP(Dynamic Programming)

Dynamic Programming의 적절한 번역은 동적 프로그래밍이 아니라 동적 계획법입니다.  
여기서 Programming은 최적의 프로그램을 찾아낸다는 의미로 사용된다고 합니다.

## 동적 계획법

동적 계획법은 큰 문제를 작은 문제로 나누어 푸는 방법이다.  
이때 작은 문제들은 중복되어 여러번 계산되는데, 이를 피하기 위해 메모이제이션을 사용한다.

동적 계획법은 다음과 같은 특징을 가진다.
- 큰 문제를 작은 문제로 나누어 푼다.
- 작은 문제들은 중복되어 여러번 계산된다.
- 이를 피하기 위해 메모이제이션을 사용한다.
- 메모이제이션은 작은 문제들의 답을 저장해두고, 같은 문제가 나오면 저장된 답을 반환한다.

> 결국 DP를 잘하려면 완전 탐색을 잘해야 한다.  
> 완탐 후 이를 겹치는 상태를 메모이제이션을 통해 시간복잡도를 줄이는게 DP의 핵심이다.


---

## 메모이제이션 구현 패턴

동적 계획법은 가장 흔한 문제 유형 중 하나이기 때문에 메모이제이션은 굉장히 자주 구현하게 된다.  
그런 만큼 한가지 패턴을 정해두고 항상 같은 형태로 구현하기로 하면 작성하기도, 버그를 찾기도 쉬워진다.

```cpp
int cache[A][B]; // 원하는 크기로

// 항상 a<A, b<B
// 반환 값은 int형 안에 들어가는 정수, int 범위 밖이라면 long long 활용 시도
int someObscureFunction(int a, int b){
    // 기저 사례를 처음에 처리한다.
    if(...) return ...;

    // a와 b에 대한 답이 있다면 곧장 반환
    int& ret = cache[a][b];
    if(ret != -1) return ret;

    // 여기서 답을 계산한다.
    ...
    return ret;
}
```

`someObscureFunction(a,b)`는 같은 인자로 여러번 호출되더라도 항상 같은 값을 반환한다.

> 위처럼 재귀 호출을 이용해 구현할 수도 있지만,  
> 반복문을 이용해 구현할 수도 있다.
> 
> 이를 Bottom-Up 방식이라고 한다.

---

### 반복적 동적 계획법과 재귀적 동적 계획법의 비교

재귀적 동적 계획법의 장단점

장점 
1. 좀더 직관적인 코드를 짤 수 있다.
2. 부분 문제 간의 의존 관계나 계산 순서에 대해 고민할 필요가 없다.
3. 전체 부분 문제 중 일부의 답만 필요한 경우 더 빠르게 동작한다.

단점
1. 슬라이딩 윈도우 기법을 쓸 수 없다.
2. 스택 오버플로를 조심해야 한다.

반복적 동적 계획법의 장단점

장점
1. 구현이 대개 더 짧다.
2. 재귀 호출에 필요한 부하가 없기 때문에 조금 더 빠르게 동작한다.
3. 슬라이딩 윈도우 기법을 쓸 수 있다.

단점
1. 구현이 좀더 비직관적이다.
2. 부분 문제 간의 의존관계를 고려해 계산되는 순서를 고민해야 한다.

> 취향에 따라 어느 쪽을 선택할지의 여부가 달라질 수 있지만 중요한 것은 `가능한 한 자신이 선택한 방향으로 일관되게 계속 연습하는 것`입니다.

---

## DP 문제 정리

2839  
5kg 봉지를 한개씩 줄이면서 탐색하는 방법(그리디) or  
dp[3]=dp[5]=1을 이용해서, dp[N]까지 구한다.  
(dp[i] = min(dp[i-3] + 1, dp[i-5] + 1))

1463  
BFS or DP 로 가능한 문제  
BFS는 visited 채우면서 1만드는 최소 횟수 찾으면 된다.  
DP는 dp[i] = min(dp[i-1], dp[i/2], dp[i/3])+1 을 이용해 dp[n]을 구한다.  
(이때 2나 3으로 나누어 떨어질 때만 가능한 걸 생각)

9095  
dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

1003  
DP의 대표적인 피보나치 함수 관련 된 문제

11726  
dp[i]=dp[i-1]+dp[i-2]  
2xi 타일은 2x(i-1) 타일 + 2x1 타일 + 2x(i-2) + 1x2 2개 타일로 채운 것과 같다.

2775 

2579  
dp[n][2] 배열 선언  
dp[i][j] = i번째 위치의 계단에서 j+1번 연속으로 계단을 밟았을 때의 점수  
dp[k][0] = max(dp[k-2][0], dp[k-2][1]) + v[i]  
dp[k][1] = dp[k-1][0] + v[i]  
max(dp[n][0], dp[n][1])이 정답이 된다.  

> dp[i] = max(dp[i-2]+v[i], dp[i-3]+v[i-1]+v[i]) 도 되네  
> 한개만 밟았을 때 값, 두개 연속으로 밟았을 때 값 중 최댓값이 현재 위치의 값이 된다.

1149  
이전 집과 색만 다를 때 최댓값을 각 색 별로 구한다.  
-> 마지막 집의 최댓값이 정답

11053  
DP의 대표적인 문제 - LIS
O(n^2)으로 풀 수 있다.

1932  
dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + v[i][j]

1912  
연속합의 최댓값을 찾아야 하는데,  
처음부터 현재까지 다 더했을 때 양수라면 계속 가져간다.  
만약 0보다 작거나 같다면, 지금까지 더했던 것들을 버리고 다음으로 넘어간다.  
dp[i] = max(dp[i-1]+v[i], v[i]);  
(여기서 겹치는 부분 문제: 이전 인덱스까지의 연속합의 최댓값)

1010  
다리를 최대한 많이 지으려면, 겹치지 않게 지으면 된다.  
-> m개 중에 n개 골라서 지을 수 있는 경우의 수  
-> mCn 이 정답

9461  
dp[i] = dp[i-1] + dp[i-5]

11727  
11726의 응용 문제  
dp[i] = dp[i-1]+dp[i-2]*2  
i-1에서 2x1 타일 붙인 경우의 수 + i-2에서 1x2 타일 2개 or 2x2 타일 붙인 경우의 수 가 정답

2748

2156   
연속으로 3잔을 마실 수 없다 == 연속으로 계단을 3칸 밟을 수 없다.  
-> 계단 밟는 문제랑 같아진다.  
dp[i] = max(dp[i-2]+v[i], dp[i-1], dp[i-3]+v[i-1]+v[i])

10844  
마지막 숫자가 i인 숫자를 의미하는 배열 10개를 만들어서 푼다.

14501  

2193  
1로 끝나는 숫자의 개수, 0으로 끝나는 숫자의 개수 를 이용해 푼다.  

12865  
배낭 문제  
최대 무게 x 아이템 개수 크기에 해당하는 배열 dp 선언  
dp[i][j] - 무게가 i일 때 j번 아이템까지 담았을 때 최대 가치  
dp[i][j] = max(v[j] + dp[i-w[j]][j-1], dp[i][j-1])

1904  
dp[i] = dp[i-1] + dp[i-2]

9251  
dp[i][j] = 첫번째 문자열의 i번째 글자와 두번째 문자열의 j번째 글자까지 비교했을 때의 LCS  
if(s1[i] != s2[j]) dp[i][j] = max(dp[i-1][j], dp[i][j-1])  
else dp[i][j] = dp[i-1][j-1]+1

9465  
2xn 크기의 2차원 배열 dp 생성  
dp[i][j] = j번째 스티커 i번째를 골랐을 때의 최댓값  
dp[i][j] = max(dp[!i][j-1], dp[!i][j-2]) + v[i][j]

> dp[i][j-2]가 아니라, dp[!i][j-2] 인 이유  
> dp[i][j-2]를 고르는 것은, dp[!i][j-1]의 경우의 수에 해당한다.

11660, 11052, 2293, 11054, 11057

11055  
가장 큰 증가하는 부분 수열의 개수를 세지않고, 합을 세면 된다.

1699  
dp[i] = min{j=1~i}(dp[i], dp[i-j*j]+1)  
시간복잡도: $O(n^{3/2})$

11051  
nCk = nCk-1 + n-1Ck-1 을 이용하는 문제

11722  
if(v[i] < v[j] && dp[i] < dp[j]+1) dp[i] = dp[j]+1  
O(n^2)

9655  
if(dp[i-1] && dp[i-3]) cout<<"SK";  
else cout<<"CY";

> 위 풀이처럼 DP를 쓰지 않고, 수학적 원리를 이용하면 간단하게 풀 수 있다.
> 
> 홀수 - 홀수 = 짝수, 짝수 - 홀수 = 홀수 를 이용  
> 서로가 홀수개만 가져갈 수 있기 때문에 (1개 or 3개)  
> 돌이 홀수개면 먼저 가져가는 사람(상근)이 이기고, 짝수개면 두번째 가져가는 사람(창영)이 이긴다.

1520  
dfs + dp 문제  
dp[i][j] = i,j에서 시작해서 도착지점까지 갈 수 있는 경로의 수  
이때 접근을 (현재 갈 수 있는 곳들 중에서) 높이가 높은 곳부터 해야 한다.  
(높이가 높은 곳에서 낮은 곳으로만 갈 수 있다는 조건이 있음)  
높이가 높은 곳을 방문한 이후에는, 해당 위치를 방문할 일이 없기 때문이다.  

> 만약 낮은 위치를 먼저 탐색하면,  
> 높은 위치에서 낮은 위치로 가는 경로의 수를 구할 때,  
> 낮은 위치에서 높은 위치로 가는 경로의 수를 더해야 한다.  
> (번거롭다)

2294  
dp[i] = min(dp[i], dp[i-coin[j]]+1)  
(맨 청므 dp[coin[j]] = 1로 초기화, -1 예외 처리 해줘야 한다)

2133  
dp[i] = dp[i-2]*3 + dp[i-4]*2 + dp[i-6]*2 + ... + dp[0]*2

2565  
전깃줄들이 교차하지 않는다 == 전깃줄들이 증가하는 순서로 연결되어 있다.  
(왼쪽 리스트를 오름차순으로 정렬 했을 때, 오른쪽 리스트도 오름차순이 되어야 한다)  
즉 한쪽을 정렬한 다음, 다른 쪽에서 LIS를 구하면 된다.  
답은 N - LIS의 길이가 된다.

1005  
DP + 위상정렬 문제  
(dp[i] = 타겟(자식) 건물부터 i번째 건물을 짓는데 걸리는 시간)  
dp[i] = max(dp[i], dp[j]+v[i])  
(이때 j는 i를 짓기 위해 필요한 건물들 중 가장 오래 걸리는 건물)  
dp[root]가 정답이 된다.

> 위는 첫번째 방법이고 두번째 방법은  
> 타겟이 아닌 루트부터 시작해서 타겟까지 걸리는 시간을 구하는 방법이다.
> 
> 이 방법이 위상 정렬을 이용한 방법이다.

1309  
i번째 위치에, 사자를 배치하지 않는 경우 + 왼쪽에 배치하는 경우 + 오른쪽에 배치하는 경우  
각각을 dp[i][0], dp[i][1], dp[i][2]로 두고 풀면 된다.
정답은 dp[n][0]+dp[n][1]+dp[n][2] 이다.

11048  
(dp[i][j] = i,j 위치까지의 최대 사탕 개수)  
dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + v[i][j]  
(현재 위치부터 목적지 가는 경우와 현재 위치까지 도착할 수 있는 경우의 상태는 겹치지 않는다)

17070  
`int getResult(int x, int y, int state)`  
: x,y 위치에 state 상태로 이동했을 떄, 목적지까지 갈 수 있는 경우의 수  
(state: 0 - 가로, 1 - 세로, 2 - 대각선)  
dp[x][y][state] = getResult(x, y, state)  
(이때, state가 2일 때는 대각선으로 이동할 수 있는지 확인해야 한다)  
각 state마다 if문으로 체크해줘서 dp[x][y][state]를 구한다.  

2096  
dp1[i][j] = i번째 줄에서 j번째 숫자를 선택했을 때의 최댓값  
dp2[i][j] = i번째 줄에서 j번째 숫자를 선택했을 때의 최솟값  
한 줄씩 읽어가면서 dp1, dp2를 갱신해나가면 된다.  
(현재 줄 i에서, 이전까지 이동하는 경우와 다음으로 이동하는 경우가 독립적이기 때문에 DP로 풀 수 있다)

14002  
그냥 LIS를 구하면 되는 문제

9252  
dp[i][j] = i번째 문자열과 j번째 문자열까지의 LCS  
if(s1[i] == s2[j]) dp[i][j] = dp[i-1][j-1]+1  
else dp[i][j] = max(dp[i-1][j], dp[i][j-1])  
(이때, dp[i][j] == dp[i-1][j] 이면, i번째 문자열은 LCS에 포함되지 않은 것이다)  
시간복잡도: $O(n^2)$

1890  
dp[i][j] = i,j 위치에서 목표까지 도달할 수 있는 경우의 수  
dp[i][j] = dp[i+v[i][j]][j] + dp[i][j+v[i][j]]  
(이때, dp[n-1][n-1] = 1로 초기화)  
(i+v[i][j] < n, j+v[i][j] < n)

10942  
팰린드롬을 구하는 문제  
1. dp[i][i] = 1, dp[i][i+1] = (s[i] == s[i+1])
2. 위 정보를 이용해 dp[i][i+k] = (s[i] == s[i+k] && dp[i+1][i+k-1])  
   (2 <= k <= n-1)

> 2번을 수행할 때, k는 오름차순으로 진행해야 한다.  
> (dp[i][i+k]를 구할 때, dp[i+1][i+k-1]이 이미 구해져 있어야 하기 때문)

12852

11066  
dp[i][j] = i번째부터 j번째까지 합하는데 필요한 최소 비용  
dp[i][j] = min(i <= k < j)(getResult(i, k) + getResult(k + 1, j)) + sum(i,j)  
(이때, sum(i,j)는 i부터 j까지의 합)  
(i==j일 때는 0으로 초기화)

> 위 공식은 i부터 j까지의 합을 2개로 나누는 모든 경우의 수를 탐색한다.  
> (이때, getResult(i, j)는 i부터 j까지의 합을 구하는 함수)

> 이 문제는 DP로 풀었지만,  
> 비슷한 문제는(파일을 연속되게 할 필요가 없는 경우)  
> 그리디로 풀 수 있다.
> 
> 이 문제는 그리디로 풀면 안되는 문제이다.  
> (파일을 연속되게 할 필요가 있기 때문)  
> -> 모든 경우의 수를 탐색해야 한다.  
> (이를 최적화하기 위해 DP를 사용한다)

17626  
dp[i] = min(dp[i], dp[i-j*j]+1)  
(1 <= j*j <= i)  
시간복잡도: $O(n\sqrt{n})$

14916

1937  
여기서 겹치는 부분문제 - 어느 쪽에서 접근하든, 현재 위치에서 이동할 수 있는 최댓값은 같다.  
-> 현재 위치에서 나올 수 있는 최댓값을 dp[i][j]에 저장한다.  
나는 이를 dfs로 풀었다.  

> 이 문제를 dp만 이용해서 풀 수도 있다.
> 
> 무조건 값이 작은 곳부터 탐색하면 된다.  
> (작은 곳에서 큰 곳으로만 이동할 수 있기 때문)

15988  
dp[i] = dp[i-1] + dp[i-2] + dp[i-3]  
현재 숫자 x를 만들 수 있는 경우의 수는  
x-1 + 1 & x-2 + 2 & x-3 + 3  
으로 만들 수 있다.

1915  
board[r][c] 위치에서 시작하는 정사각형의 최대 크기 =  
min(board[r+1][c]의 정사각형의 길이, board[r][c+1]의 정사각형의 길이, board[r+1][c+1]의 정사각형의 길이) + 1  
위 방법을 이용해 문제를 푼다.

1965  
LIS의 실생활 문제

1516  
위상정렬 + DP 문제  
현재 건물 i의 최소 시간 = max(미리 지어야 하는 건물들의 최소 시간) + 현재 건물을 짓는데 걸리는 시간

> 미리 지어야 하는 건물들이 있을 때,  
> 이 건물들을 동시에 지을 수 있기 때문에  
> (가장 긴 시간 + 현재 건물 짓는 시간)이 현재 건물 i의 최소 시간이 된다.

2011  
겹치는 부분 문제: 현재 위치 i에서, 뒷부분에서 나올 수 있는 경우의 수는 i와 관련이 없다.  
`dp[i]` - 현재 위치 i부터 뒷부분까지, 나올 수 있는 경우의 수  
1. if str[i] == '0', dp[i] = 0 (0은 불가능한 경우의 수)
2. if str[i] == '1', dp[i] = dp[i+1] + dp[i+2] (1X 같은 수도 가능하기 때문)
3. if str[i] == '2' && str[i+1] == '0' ~ '6', dp[i] = dp[i+1] + dp[i+2]
4. else, dp[i] = dp[i+1] (현재 위치에서는 딱 한가지의 경우의 수만 있다)


---

## 한번 더 생각해볼 문제

1912 바로 생각이 나지 않았다

2156 dp 배열을 3개 쓰는 방법과 한개로 푸는 방법 두가지가 있다.

2133 

1005 위상정렬을 이용한 DP 문제

11066 

1937 

1915 내 입장에선 굉장히 획기적인 방법이였음