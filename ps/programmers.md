### 징검다리 건너기

https://school.programmers.co.kr/learn/courses/30/lessons/64062

> 징검다리를 표현하는 배열이 주어지는데, 징검다리를 밟을때마다 수가 1씩 감소함, 수가 0이 되면 그 돌은 밟지 못함, 징검다리 배열과 한번에 건널 수 있는 최대 칸수 k가 주어졌을때 최대 몇명이 징검다리를 건널수 있는지 구하는 문제

사용한 알고리즘: 슬라이딩 윈도우
> 이분탐색도 있다고 하지만, 생각나지는 않음

시간복잡도: $O(n)$

`처음에 접근한 방법`<br>
k의 범위 내에서 제일 높은 값 -> 그 칸에서 최대로 건널수 있는 사람의 수
0부터 n-1까지 k 범위씩 해당 범위 에서 제일 높은 값을 찾고, 모든 결과중에서 가장 작은 값이 답이 되도록 풀었다.

여기서 최적화를 위해,<br>
다음 돌을 볼때 현재 버려야 하는 돌의 값이 max가 아니라면 -> 다음 범위로 가도 max값은 변하지 않음<br>
바로 다음 인덱스로 이동했고, <br>
새로 추가하는 돌의 값이 max보다 크지 않다면 -> 똑같이 max값 안변함<br>
바로 다음 인덱스로 이동했다.<br>
위에 해당하지 않는다면 다시 해당 인덱스에서 k번 검사하여 최댓값을 찾았다.

답은 맞지만, 시간복잡도가 $O((n-k)k)$라서 효율성 검사 13번에서 시간초과가 났다.

> 이 접근은 대부분의 케이스는 다른 알고리즘보다 시간이 덜 걸렸다.
> 
> 그런데 k=3일때, [20, 19, 18, 17, 16, 15, ...] 이런 배열이 주어지면 최적화의 의미가 없다.
>> 버리는 돌의 값이 max에 해당하고, 추가하는 돌의 값이 max보다 작기 때문에, 항상 k번 연산 진행됨
>
> 이런 케이스에 해당하면 시간초과가 났다. -> 그래서 통과못함

`다음으로 접근한 방법`<br>
이 접근은 다른 사람의 풀이를 보고 이해했다.

```deque<pair<int,int>>``` {돌의 값, 인덱스}를 저장

항상 deque에 k개의 돌을 추가하는데, 여기서 규칙이 있다.
> 항상 내림차순으로 정렬되어있음

인덱스가 k 범위를 벗어 났다면, 첫번째돌을 제거<br>
그리고 새로운 돌을 추가하는데, 마지막돌들이 새로운 돌보다 값이 작다면 마지막 돌들을 제거한다.
> 이렇게 되면 deque가 항상 내림차순으로 저장된다.

원래였다면 deque에 인덱스를 저장할 필요는 없지만, 중간중간 빠진 돌이 있기 때문에, 나중에 버릴수있는 돌이진 체크하기 위해 인덱스가 추가됨

항상 내림차순으로 정렬되어 있기 때문에, 맨 앞의 돌이 최댓값이다.

이 접근 방법은 모든 케이스에 대해 비슷한 시간복잡도가 나온다. - 문제 통과함

> 첫번째 접근은 조건부 케이스를 제외하고는 좋은 결과가 나왔지만, 특정 케이스에 대해 시간초과가 나옴<br>
> 두번째 접근은 항상 시간복잡도가 비슷하게 나왔다.

---

### 다단계 칫솔 판매

https://school.programmers.co.kr/learn/courses/30/lessons/77486

> 다단계 직원들의 구조가 주어졌을떄, 어떤 직원이 물건을 판매하면 해당 직원은 물건 값의 90%의 이익을 얻고, 부모노드는 10%의 이익을 얻는다. 이때 부모노드가 없을때까지 반복된다. 이런 관계에서 직원들의 구조와 판매자의 정보가 주어졌을떄, 전체 직원들의 수익은 얼마인지 구하는 문제

사용한 알고리즘: 트리, 해시

시간복잡도: $O(n * log m)$ - n은 판매자 배열의 길이, m은 직원수

그냥 직원에 해당하는 문자열과 배열에서의 위치 정보를 map(해시테이블)에 넣고<br>
판매자 배열을 for문으로 탐색하면 된다.

처음에는 수익이 최대 루트 노드까지 전달되기 때문에,<br>
시간복잡도가 $O(n*m)$ 이라고 생각했는데,

문제를 다시보니 판매량의 범위가 최대 10000원이라 아무리 부모노드를 많이 거쳐도 최대 5번밖에 탐색하지 않는걸 확인했다.

그냥 트리와 해시의 구현 문제였다.

---

### 파괴되지 않은 건물

https://school.programmers.co.kr/learn/courses/30/lessons/92344

> 2차원 배열 board의 값들이 주어지고, (r1,c1)부터 (r2,c2)까지 d만큼 값을 + or - 하라는 skill 배열이 주어졌을때, skill배열을 board에 모두 적용한후 board에 있는 값들중에 0보다 큰값은 몇개인지 구하는 문제

사용한 알고리즘: 누적합

시간복잡도: $O(n*m + k)$ // n=행, m=열, k = skill 배열 size

이 문제를 구현하는건 어렵지 않지만, 시간복잡도가 문제였다.

그냥 구현하면 시간복잡도는 $O(n*m*k)$가 나와 무조건 시간초과여서 손을 못대고 있어서,<br>
풀이를 봤는데,

누적합을 이용하는 문제였다.

ex) 1차원 배열에서 r1부터 r2까지 5를 더하라는 명령이 주어졌을때,

그냥 하나씩 더해줄수 있지만, 명령이 여러개라면 시간복잡도가 최대 $O(배열의 길이 * 명령의 개수)$가 된다.

여기서 누적합을 이용하면 $O(배열의 길이 + 명령의 개수)$로 줄일 수 있다.

> 예를 들어서 (1,3,4), (1,4,5), (2,5,-1) 배열이 주어지면 (r1,c2,d)<br>
> 처음 배열에 |0|4|0|0|-4|0|0| 이렇게 저장하고 그다음으로<br>
> |0|9|0|0|-4|-5|0| 이렇게 저장함<br>
>> r1에 d를 더해주고, r2+1에 d를 빼준다.
>
> 전체 계산을 다 끝내면, |0|9|-1|0|-4|-5|1| 이렇게 됨
>
> 그리고 왼쪽에서 오른쪽으로 누적합 진행
>
> 결과: |0|9|8|8|4|-1|0|
>
> 이는
>
> |0|4|4|4|0|0|, |0|5|5|5|5|0|, |0|0|-1|-1|-1|-1| 3개의 배열 전체를 더해준 것
>
> 즉 시간복잡도 $O(n*m)$을 누적합을 이용해 $O(n+m)$으로 줄일 수 있다.

위 과정을 2차원 배열에도 적용시킬 수 있다.

> 예를 들어서 (1,1)부터 (3,3)까지 5만큼 더해준다 했을때,
>
> 위 누적합을 이용하려면
>
>|0|0|0|0| -> |0|0|0|0|0|<br>
>|0|5|5|5| -> |0|5|0|0|-5|<br>
>|0|5|5|5| -> |0|5|0|0|-5|<br>
>|0|5|5|5| -> |0|5|0|0|-5|<br>
>
> 이렇게 저장한 뒤에, 왼쪽에서 오른쪽으로 누적합을 해줘야 하는데, <br>
> 여기서 행의 개수만큼 d와 -d를 저장해줘야 하기 때문에
>
> 시간복잡도는 $O((r2-r1) * 명령의 개수 + 열) => O(행 * 명령의 개수 + 행*열)$ (최대) 이렇게 된다.
>
> 이를 간단한 아이디어를 적용하여 $O(명령의 개수 + 행*열)$로 줄일 수 있다.
>>|0|0|0|0|0|<br>
>>|0|5|0|0|-5|<br>
>>|0|0|0|0|0|<br>
>>|0|0|0|0|0|<br> 
>>|0|-5|0|0|5|<br> 
>>
>> 처럼 저장 { (r1,c2)=d, (r1,c2+1)=-d, (r2+1,c1)=-d, (r2+1,c2+1)=d }
>>
>> 그다음으로 위에서 아래로 누적합 해준후, 왼쪽에서 오른쪽으로 누적합 진행하면 원래버전과 값이 같아진다.
>>
>> 위에서 아래로 누적합 진행<br>
>>|0|0|0|0|0|<br>
>>|0|5|0|0|-5|<br>
>>|0|5|0|0|-5|<br>
>>|0|5|0|0|-5|<br> 
>>|0|0|0|0|0|<br> 
>>
>> 왼쪽에서 오른쪽으로 누적합 진행<br>
>>|0|0|0|0|0|<br>
>>|0|5|5|5|0|<br>
>>|0|5|5|5|0|<br>
>>|0|5|5|5|0|<br> 
>>|0|0|0|0|0|<br>
>>
>> 시간복잡도: $O(k + n*m)$ 완벽

위의 누적합 아이디어를 적용시키면 2차원 배열에서의 누적합도

시간복잡도를 많이 줄일 수 있다. $O(k + n*m)$ { k:명령의 개수, n:행의 개수, m:열의 개수 }

---

### 보석 쇼핑

https://school.programmers.co.kr/learn/courses/30/lessons/67258

> 보석들의 이름이 담긴 배열이 주어졌을때, 모든 보석을 포함하는데, 길이가 가장 짧은 두 위치를 찾는 문제

사용한 알고리즘: 투포인터, 해시

시간복잡도: $O(n)$

첫 접근: 그리디 - 시간복잡도가 $O((보석의 개수)^n)$ 너무 높아서 포기

두번째 접근: dp - 시간복잡도가 $O(n^2)$ n이 최대 100000이라 포기

마지막 접근: 투포인터 - 좋은 접근이였지만 두 포인터 사이의 보석의 개수를 세는 부분을 제대로 체크 못해서 풀지 못했다.

나는 각 위치마다 몇개의 보석을 포함하고 있는지를 체크해주는 배열을 만들려고 했다.

필요한 배열 크기: n * 보석의 개수

시간복잡도: $O(n * 보석의개수)$ 너무 높아서 안될것같아서 못했다.

결국 찾은 답은,

처음부터 모든 보석을 세려고 하지 말고, 

해당 위치에 있는 보석만 추가해주면된다.

> 이렇게 할 수 있는 이유는, 배열의 특정 위치에는 `보석 한개`만 있기 때문이다.
>
> 만약 특정 위치에 보석 여러개가 있었다면 내가 생각한 알고리즘을 쓰는게 맞을수도 있다.

이 알고리즘의 시간복잡도: $O(n)$

---

### 불량 사용자

https://school.programmers.co.kr/learn/courses/30/lessons/64064?language=cpp

> string인 유저 아이디들과 제제 아이디가 주어졌을때, 제제 아이디로 가능한 경우의 수를 세는 문제

시간복잡도: 

사용한 알고리즘: dfs, 비트마스킹

1. 제제 아이디마다 제제가 가능한 아이디가 있을꺼임
그 아이들을 세준다.
    > st*가 제제 가능한 아이디들: sta, stb, stc, ...
    > 
    > 여기서 해당하는 유저 아이디들을 세준다.

    여기서 문자열 그대로 저장하지 않고 숫자로 저장한다. - 비트마스킹

2. dfs를 통해 가능한 경우의 수를 세준다.
    > set을 사용 - 중복 제거 위해

    > ex - 제제 가능한 유저아이디가 0,1,2,4 라면
    > 
    > 4210을 set에 저장한다. - 0이 앞에오면 생략됨 - 체크 불가능

3. set에 저장된 자료의 개수가 정답

---

### 블록 이동하기

https://school.programmers.co.kr/learn/courses/30/lessons/60063

> n x m 보드판에서 1,1 에 위치한 2x1 크기의 로봇이 n,m  위치까지 가는데 걸리는 최소시간을 구하는 문제

사용한 알고리즘: bfs

시간복잡도: $O(n * m)$

이 문제는 백준의 통나무 문제랑 비슷한 문제<br>
https://www.acmicpc.net/problem/1938


bfs의 응용 문제였음,

단순히 n*m visited를 체크하는게 아니라 로봇의 방향까지 체크해야했음

그리고 로봇이 움직일때, 회전할때마다 if문을 제대로 구현해야함

미리미리 설계해놓고, 구현은 거의 마지막에 하는게 좋다

그래야 실수를 덜한다.

---

### 단어 변환

https://school.programmers.co.kr/learn/courses/30/lessons/43163?language=java

`사용한 자료구조 & 알고리즘:` BFS

`시간복잡도:` $O(N^2)$

`어떻게 접근했는지, 풀었는지 설명:`

일반적인 BFS 문제  
이미 방문한 곳은 visited로 표시해주고,  
queue를 이용해 최솟값을 탐색하면 끝나는 문제였다.

    문제가 어려웠다기 보단,
    Java로 푸는게 어색해서 시간이 조금 지연됐다.

    String의 길이는 length(), Array의 길이는 length, 컨테이너의 길이는 size() 다 다른게 조금 어색했다.
    String의 특정 문자를 접근할 때는 charAt()
    배열도 힙 영역에 생성되기 떄문에, 일일이 new로 선언해주는게 귀찮았다.

---

### 단속 카메라

https://school.programmers.co.kr/learn/courses/30/lessons/42884

`사용한 자료구조 & 알고리즘:` 그리디

`시간복잡도:` $O(NlogN)$

`어떻게 접근했는지, 풀었는지 설명:`

1. 자동차가 끝나는 지점을 기준으로 정렬
2. 현재 index의 자동차에 대한 감속카메라가 있는지 확인  
   있다 -> continue  
   없다 -> 현재 자동차가 끝나는 지점에 단속 카메라 설치 & answer++

끝나는 부분에 설치하는 이유:  
다음 자동차들을 최대한 수용하기 위하여

    이를 쉽게 풀 수 있었던 이유는  
    자동차들의 끝나는 지점을 기준으로 정렬했기 때문이다.  
    이로 인해, 이전 자동차들과 현재 자동차들의 관계를 생각할 필요가 없어졌다.

    이 문제를 자바로 풀었는데, 정렬할 때의 기준이 c++과 살짝 달라서 헷갈렸다.
    (반환 타입이 c++은 bool, java는 int)
    c++의 정렬 기준 - true(뒤가 뒤로), false(앞이 뒤로)
    java의 정렬 기준 - 0보다 작다(뒤가 뒤로), 0보다 크다(앞이 뒤로)

---

### 표현 가능한 이진트리

https://school.programmers.co.kr/learn/courses/30/lessons/150367#

`사용한 자료구조 & 알고리즘:`

`시간복잡도:` $O(logN)$

`어떻게 접근했는지, 풀었는지 설명:`

1. 해당 숫자를 표현할 수 있는 트리의 높이를 구한다.  
   (이떄 루트 노드는 무조건 존재해야 하므로 딱맞는 높이가 있다)
2. 트리의 높이를 이용해 포화이진트리의 노드의 개수를 구한다.
3. 인풋 숫자를 2진수로 변환한다.
4. 분할 정복 & dfs 방식으로 답을 구한다.  
   만약 자식 노드가 있는데(1), 현재 노드가 없다면(0) false
   아니라면 true
   이때 dfs 방식 대신 누적합을 이용할 수도 있다.

배운것
1. pow의 시간복잡도
2. 10진수를 바로 2진수로 변환할 수 있을까
3. 트리의 높이와 노드 개수와 숫자의 관계
4. floor 메서드
5. log 메서드
6. 인풋 숫자륾 표현할 포화이진트리의 노드의 개수를 구하는 것이 너무 힘들었다.
   (로그 연산이 헷갈렸다)
   그냥 숫자를 2진수로 변환하고 그에 맞는 2승수를 찾으면 편하게 구할 수 있었다.


    바로 통과하진 못했다.
    그 이유는 트리의 높이를 구할 때 오버플로우가 발생해서 
    프로그램이 원하는대로 실행되지 않았다.
    
    트리의 높이 h = 2^{2^n-1}-1
    -> h 오버플로우 발생

    따라서 n에 log를 취해준 뒤, (ln) 
    2^i-1 == ln 인 i를 찾는다.
    (i = 노드의 개수)

    10진수를 2진수로 바꾸는 과정이 귀찮았는데,
    이를 메소드로 제공하고 있었다.
    Long.tobinaryString(x) // Java
    bitset<비트 길이> b(x) // C++
    (아니면 쉬프트(>>) 연산을 통해 편하게 구할 수 있다)
    
    결론: 중간중간 연산의 오버플로우를 신경 쓰자
    그리고 log 함수에서 밑은 e 이다.
    만약 원하는 밑으로 바꾸고 싶다면 log(x)/log(2)를 쓰자 (로그 공식)

---

### 입국심사

https://school.programmers.co.kr/learn/courses/30/lessons/43238#

`사용한 자료구조 & 알고리즘:` 이분 탐색

`시간복잡도:` $O(NlogT)$

`어떻게 접근했는지, 풀었는지 설명:`

먼저 times 배열을 오름차순으로 정렬

s = times[0] // 가장 빨리 끝나는 시간
e = times[times.length - 1] * n // 가장 늦게 끝나는 시간

s와 e를 이용해 이분 탐색 알고리즘으로 최솟값을 구한다.
1. mid = (s+e)/2 // 끝나는 시간
2. mid를 이용해 몇 명을 검사할 수 있는지(sum) 체크
3. 만약 sum이 n보다 크다면 answer 최솟값으로 업데이트 & e = mid-1  
   아니라면 s = mid+1


    이 문제를 이분탐색으로 풀 수 있는 이유
    이분탐색을 이용했을 때 times[0], times[times.length-1]*n 사이에 있는
    모든 값들을 탐색할 수 있기 때문이다.
    
    이떄 탈출 조건을 s > e 로 설정해줘야 한다.
    s == e 일 때 탈출하면, 모든 케이스를 탐색하지 못한다.

    확실히 log 연산은 사기다.
    엄청 큰 숫자에 log를 하면, 값이 말도 안되게 작아진다.

---

### 징검다리

https://school.programmers.co.kr/learn/courses/30/lessons/43236

`사용한 자료구조 & 알고리즘:` 이분탐색

`시간복잡도:` $O(NlogT)$

`어떻게 접근했는지, 풀었는지 설명:`

처음에 접근한 방법:  
돌을 제거한다 -> 바위 사이의 거리를 합친다.

n개의 돌을 제거해서, 바위 사이의 거리를 최대로 만들기 위해서는,  
바위 사이의 거리가 가장 작은 거리 n개를 제거하는 과정과 같다고 생각했다.

그래서 우선순위 큐에 {거리, 인덱스}를 저장해서 풀려고 했는데, 
어려운 점들이 몇가지 있었다.
1. 바위를 제거하면, 거리를 합쳐야 하는데, 이를 표현하기 까다롭다.  
   합친다는 것은 컨테이너의 특정 원소를 제거해야 하는 것  
   (list는 불가능, 배열은 합칠 때 다음 인덱스를 업데이트 해줘야 함)
2. 거리가 같을 때, 어느 쪽을 먼저 제거할지는 양쪽의 거리를 보고 판단해야 하는데,  
   중간에 양쪽의 거리도 업데이트 되서, 최적해를 찾을 수 없다.

결국 검색을 통해 답을 알 수 있었다.

이 문제는 이분탐색을 이용하는 문제

(시작=0, 끝=end, mid가 의미하는 것=거리의 최솟값)  
mid를 통해 제거한 돌의 개수가 n개 이하라면, answer 업데이트 && left = mid + 1  
(찾아야 하는 것은 최댓값이기 때문에 left를 키워서 최댓값을 탐색한다)  
초과라면, right = mid - 1  
(최댓값을 찾아야 하는데, 현재 mid는 불가능하기 때문에, right를 줄여서 다시 탐색한다)

결국 logT 번 만에 최댓값을 찾을 수 있고,  
한번 탐색할 때 N번 탐색하기 떄문에  
O(NlogT)의 시간복잡도로 문제를 풀 수 있다.

    이분탐색을 이용할 수 있는 조건
    시작과 끝이 명확해야 하고, 그 사이가 오름차순/내림차순으로 정렬되어 있어야 한다.
    그리고 left와 right를 업데이트 할 때, 일관성이 있어야 한다.
    (left-mid update or right-mid update 고르는 기준이 명확해야 한다)

    아직 문제에 대한 시야가 넓진 않은 것 같다.
    1. 나는 항상 컨테이너에 대해서만 이분탐색을 할 수 있다고 생각했다.
    내가 찾으려는 값을 이분탐색을 통해 찾는 시야는 아직 부족한 것 같다.
    2. 그리고 나는 시간복잡도가 O(nlogn)이면 n개의 원소에 대해 logn번 만에 탐색을 해서 찾는다고 생각했다.
    (이 문제는 logn번 탐색하는데, 한번 탐색할 때 n번 수행해서 탐색해서 O(nlogn)이 나온 것이다)

---

### 큰 수 만들기

https://school.programmers.co.kr/learn/courses/30/lessons/42883

`사용한 자료구조 & 알고리즘:` 그리디

`시간복잡도:` $O(k^2)$

`어떻게 접근했는지, 풀었는지 설명:`

1. 맨 앞자리부터 k개 이하로 제거했을 때 얻을 수 있는 가장 큰 수
2. 만약 같은 수가 있다면 k를 최대한 적게

위 과정을 k == 0 일 때까지 반복


    k가 최대 백만인데,
    위 시간복잡도로 성공했다.
    c++이라서 그리고 운이 좋아서 성공한듯

> 다른 방법
> 
> (스택을 이용)
> 현재 위치 i에서
> 스택에서 현재 숫자(number[i])보다 작은 숫자들은 모두 pop && k-- (k > 0 일때)
> v.push_back(number[i])
> 
> 만약 모든 숫자 탐색 후 k > 0 이라면,
> k == 0 일때까지 v.pop_back() // 같은 숫자가 있어서 k > 0

---

### 야근 지수

https://school.programmers.co.kr/learn/courses/30/lessons/12927

`사용한 자료구조 & 알고리즘:` 우선순위 큐

`시간복잡도:` $O(nlogm)$

`어떻게 접근했는지, 풀었는지 설명:`

모든 작업량을 최소로 낮춰야 한다.  
이때 작업량이 m개가 있는데, m개를 한개씩 다 볼수는 없기 때문에  
우선순위 큐 pq를 이용해 가장 높은 작업량만 확인한다.

그래서 n번 동안, 가장 높은 작업량을 pop 한 다음,  
1을 빼서 push 해준다.

n번의 순회 이후에는,  
pq에 남은 작업량들을 이용해 결과를 구해준다.

---

### 가장 긴 팰린드롬

https://school.programmers.co.kr/learn/courses/30/lessons/12904

`사용한 자료구조 & 알고리즘:` dp

`시간복잡도:` $O(n^2)$

`어떻게 접근했는지, 풀었는지 설명:`

기본적인 팰린드롬 문제

s[l] == s[r] && dp[l+1][r-1] == true 라면,  
dp[l][r] = true 처리를 해준다.  
=> l부터 r까지가 팰린드롬에 해당한다.

---

### 수식 복원하기

https://school.programmers.co.kr/learn/courses/30/lessons/340210?language=cpp

`사용한 자료구조 & 알고리즘:` 문자열, 구현

`시간복잡도:` $O()$

`어떻게 접근했는지, 풀었는지 설명:`

주어진 인풋 문자열들을 띄어쓰기를 기준으로 나눠서,  
각 수식들을 이용해 가능한 진법들을 찾는 문제  
그리고 마지막에 가능한 수식들로 만들어진 문자열을 출력하는 문제

동작 과정
1. 인풋 문자열들을 완성된 수식 s1과 완성해야 할 수식 s2로 나눈다.
2. s1, s2의 숫자들을 이용해 불가능한 진법들을 제외한다.  
   (7이란 숫자가 있다 -> 7진법 이하의 진법은 불가능)
3. s1 수식들을 이용해 불가능한 진법들을 제외한다.
4. 가능한 진법들을 이용해 s2의 수식을 완성한다.

이 문제의 핵심은
1. 문자열 파싱
2. 10진법을 n진법으로 변환

위 두가지 이다.

        이 문제는 인풋의 범위가 작기 때문에  
        시간복잡도를 신경쓰지 않아도 된다.
        
        하지만 그만큼 구현이 까다로운 문제이다.

---

### 수레 움직이기

https://school.programmers.co.kr/learn/courses/30/lessons/250134#

`사용한 자료구조 & 알고리즘:` 구현, 백트래킹(DFS)

`시간복잡도:` $O((RC)^3)$

`어떻게 접근했는지, 풀었는지 설명:`

처음봤을 때는 일반적인 그래프 탐색 문제인줄 알았지만,  
브루트 포스로 접근해야 하는 문제였다.

브루트 포스로 접근해야 하는 이유
1. 모든 경우의 수를 포함하는 최적해를 찾기 힘든 문제이다.
2. 인풋이 굉장히 작고(<= 4), visited를 이용해 중복을 제거할 수 있다.  
   -> 시간복잡도가 크게 증가하지 않는다.

`void dfs(pair<int,int> red, pair<int,int> blue, int cnt)`  
= red와 blue 위치가 주어졌을 때, cnt 번째 이동을 하는 함수

dfs의 동작 과정
1. 만약 현재 각각의 red & blue가 target 구멍에 있다면,  
   answer = min(answer, cnt)  
   return
2. red와 blue의 다음 위치 탐색
3. recursive call

2번의 규칙
1. 두 구슬이 같은 위치로 움직일 수 없다.
2. 두 구슬이 교차하여 움직일 수 없다.
3. 각각의 구슬이 이전에 방문했던 위치로 움직일 수 없다.


      여기서 오해해서 시간이 늦어진 이유들

      1. 교차하여 움직일 수 없을 뿐, 한 구슬이 다른 구슬의 이전 위치로 이동할 수는 있다.
      r b x x 이면, x r b x 이동 가능 (r이 b의 이전 위치로 이동)

      2. visited를 같이 체크하면 안되고, 따로 적용해야 한다.
      (red에 대한 visited1, blue에 대한 visited2)

---