### 1013 Contact

https://www.acmicpc.net/problem/1013

`사용한 자료구조 & 알고리즘:` 문자열

`시간복잡도:` $O(n)$

`어떻게 접근했는지, 풀었는지 설명:`

(100+1+ | 01)+ 에 해당하는 문자열인지 검증하는 문제

여기서 나는 맨 첫 숫자가 0인지 1인지를 이용해 구분했다.  
첫 숫자 0 -> 01 인지 체크  
첫 숫자 1 -> 100+1+ 인지 체크

첫 숫자가 1 일때 100+1+ 을 체크하는 방법  
1. 앞 두 글자가 10 인지 체크
2. 0이 1개 이상 나오는지 체크
3. 1이 1개 이상 나오는지 체크

        이때 내가 실수 한 점이 있었는데,  
        첫 숫자가 0일 때, 무조건 01만 가능한 것은 아니였다.
        (10011001 은 1001 + 1001 케이스)
        
        이를 구분하기 위해 맨 처음 01을 체크하고,  
        만약 01이 불가능하다면, 이전 두 문자가 1인지 체크한다.
        (10~ 을 체크하려면, 이전 문자는 110 ~ 이여야 한다)
        위 케이스에 해당한다면, 100+1+ 을 체크하면 된다.

> 알고보니 이 문제는 정규표현식을 이용하면 쉽게 풀 수 있는 문제였다.

---

### 1082 방번호

https://www.acmicpc.net/problem/1082

> n개의 숫자에 대한 값이 주어졌을때, m원을 이용해서 최대한 큰 숫자를 만드는 방법을 만들어라
>
> 3<br>
> 6 7 8<br>
> 21<br>
> 답: 210(8/7/6)

사용한 알고리즘: DP, 문자열

시간복잡도: $O(m^2)$

완탐으로 시작

find(num, money) = num번째 위치에서 money원을 이용해서 만들 수 있는 최대의 숫자를 반환

$find(num, money) = max^n_{L=1}(L + find(num+1, money-room[i]))$

뽑은 숫자를 앞에 두는 이유: 만약 1과 2를 살 수 있다면, 위 답은 12와 21중 max값인 21을 고를것이다.<br>
-> 순서가 바껴도 알아서 체크가능

따라서 굳이 순서에 제한을 줘서, 간단하게 정리가능

    여기서 주의할 점
    첫번째 값은 0번 숫자에 대한 값이기 때문에
    처음부터 0을 사면 안됨(숫자가 2개 이상일때) - 021(x), 210(o)
    따라서 처음부터 재귀로  시작하지 않고 for문을 1부터 시작하도록 세팅
    (재귀에서는 0부터 for문 시작함, 자릿수는 0상관없기 때문)
    (만약 0만 살수 있다면 답은 0, 예외 처리 해줘야함)

여기서 dp를 적용

m의 최댓값이 50이기 때문에 50x50 크기의 string type cache 선언하면 됨(최대 50자리라서 행도 50)

(이때 string type이라 초깃값 확인이 어렵기 때문에, 따로 bool type 50x50 크기의 visited 선언)

---

### 1091 카드 섞기

https://www.acmicpc.net/problem/1091

`사용한 자료구조 & 알고리즘:` 구현

`시간복잡도:` $O(n^2)$

`어떻게 접근했는지, 풀었는지 설명:`

사람은 딱 3명(0,1,2)

각 배열들이 나타내는 정보  
`p[i]` - 맨 처음 i번째 위치에 있는 카드가 가야하는 사람의 번호  
`s[i]` - i번째 위치에 있는 카드가 다음으로 움직이는 위치  
`cur[i]` - i번째 위치에 있는 카드가 맨 처음에 있을 때의 위치

> 여기서 p의 모든 원소는 0,1,2 중 하나이다.  
> 그리고 cur[i]은 처음에 i로 초기화된다.

(cur을 이용해서 결과를 구한다)  
매 단계마다 p 배열을 이용해 조건을 체크한다.  
그리고 조건에 해당하지 않다면, 카드를 s 배열을 이용해 섞는다.

> 이때 무한루프가 생길 수 있다.
> 
> 이를 막는 방법
> 1. cur 배열에 대한 set을 생성해서, 모든 경우의 수를 체크한다.  
>    (시간 & 공간 복잡도 높음, 하지만 인풋이 작아 가능)
> 2. 맨 처음 배열에 해당하는지 체크한다.  
>    (cur 배열은 사이클이 무조건 발생한다는 것을 이용)
> 3. 사이클의 주기를 파악해서, 그 주기들의 최소공배수만큼 반복하면 된다.  
>    (이 역시 사이클이 무조건 발생한다는 것을 이용)

        나는 p 배열의 정의를 계속 헷갈려 했다.
        그리고 초기 cur 배열은 `cur[i] = i` 인데, 나는 실수로 i%3을 넣었다.
        (cur은 카드의 번호를 나타내기 때문에 그냥 i를 넣어야 한다)

        p[i] - 맨 처음 i번째 위치에 있는 카드가 가야하는 사람의 번호
        p[cur[i]] - 현재 i번째 카드가 가야하는 사람의 번호
        p[cur[i]] == i%3 - 현재 i번째 카드가 가야하는 사람의 번호가 맞는 케이스

        조건을 체크할 때는
        p[cur[i]] == i%3 에 해당하면 탈출한다.
        (이때 p[cur[i]]를 i 오름차순으로 출력하면 0 1 2 0 ... 이런식으로 나온다)

---

### 1102 발전소

https://www.acmicpc.net/problem/1102

`사용한 자료구조 & 알고리즘:` DP, 비트마스킹

`시간복잡도:` $O(n^3)$

어떻게 접근했는지, 풀었는지 설명:

```getMin(int n)``` - 발전소가 n개 켜져 있을 떄 P개 키기 위해 필요한 최솟값을 반환하는 함수

이때 겹치는 부분을 메모이제이션을 처리해줘야 하는데,  

이를 비트마스킹으로 처리해주면 깔끔하게 해결 가능하다.

```getMin(int n, int index)``` - 발전소가 n개 켜져 있을 떄 P개 키기 위해 필요한 최솟값을 반환하는 함수  
index: 현재 발전소의 상태  
(0x01 - 1번 발전소만 켜져 있음, 0x110 - 2,3번 발전소만 켜져 있음)

index를 이용해 메모이제이션을 해주면 풀 수 있다.
(최대 1000000 (N <= 16))

    비트마스킹을 적용할 수 있는 문제는 매우 제한적이다.
    -> N이 20 내외일때
    (N이 30만 되도 메모리 초과가 발생할 것이다. - 10억)

    이를 잘 기억해놓자

---

### 1113 수영장 만들기

https://www.acmicpc.net/problem/1113

사용한 자료구조 & 알고리즘: 구현, BFS

시간복잡도: $O(h*n^2)$

방법 (높이 h - 1부터 9까지)  
1. 높이가 h인 블럭들이 채울 수 있는 최댓값을 찾는다. - BFS(n^2)  
    > 외곽에 도달하면, 해당 블럭은 물을 채울 수 없다 - 바로 break;  
    본인보다 높이가 낮은 블럭을 만냐면 물을 채울 수 없다 - 바로 break;
2. 최댓값으로 블럭을 업데이트 한다. - BFS(n^2)

1시간반 걸렸다. - 좀 해멧다.

헤맨 이유
1. BFS를 너무 오랜만에 풀었다 -> 중간중간 실수 발생(push 안넣고, nr & nc 안쓰고)
2. 중간에 설계가 바꼈다. (이건 그냥 많이 풀어봐야 함)

> 다른 방법도 있었네
> 
> 내 방법 - 높이 1부터 물을 채우는 것  
> 다른 방법 - 물을 전부 채우고, 높이 9부터 물을 빼는 것(외곽이랑 붙어 있으면 빼야 함) - 이게 좀 더 간단한 듯

---

### 1135 뉴스 전하기

https://www.acmicpc.net/problem/1135

`사용한 자료구조 & 알고리즘:` DFS, 그리디

`시간복잡도:` $O(NlogN)$

`어떻게 접근했는지, 풀었는지 설명:`

맨처음 인풋을 받을 때 부모 노드의 번호를 받는데,  
이때 부모 노드를 저장하는 것이 아니라,  
자식 노드를 저장하는 것이 편하다.  
-> 루트부터 top-down으로 DFS 방식으로 탐색하면 된다.

`int getMin(int index)` - index 노드의 최솟값을 반환

이때 적용되는 최적해가 있다.  
`가장 시간이 오래걸리는 자식부터 처리한다`  

getMin 메서드의 처리 순서
1. 자식 노드들의 최솟값을 구한다.
2. 자식 노드들의 최솟값을 정렬한다.
3. 자식 노드들의 최솟값을 바탕으로 현재 노드의 최솟값을 구한다.

> 그리디하게 풀어서 따로 값을 저장할 필요가 없다.  
> (자식 노드를 딱 한번만 탐색하기 때문)

---

### 1162 도로포장

https://www.acmicpc.net/problem/1162

`사용한 자료구조 & 알고리즘:` 다익스트라 & DP

`시간복잡도:` $O(M*K*logN)$

어떻게 접근했는지, 풀었는지 설명:

1번에서 N번까지의 최단거리를 구할 떄,  
다익스트라를 이용하는데

특정 노드로 이동할 때,  
해당 도로를 포장할 수도 있고, 안 할 수도 있다.  
두가지 케이스를 모두 체크한다.

따라서 필요한 배열의 크기는 (포장 가능한 개수) x (노드의 개수) 이다.

기존 다익스트라는  
```if(1-i 거리 + i-k 거리 < 1-k 거리)```만 체크하면 됐는데,

```
if(1-i 거리 + i-k 거리 < 포장 개수가 M개 일 때 1-k 거리)
if(M > 0 && 1-i 거리 < 포장 개수가 M-1개 일 대 1-k 거리)
```  
둘 다 처리해 줘야 한다.

따라서 전체 시간복잡도는 O(포장 가능한 개수 x 도로 개수 x log(노드 개수)) 이다.

---

### 1213 펠린드롬 만들기

https://www.acmicpc.net/problem/1213

사용한 알고리즘: 덱, 문자열

시간복잡도: $O()$

1. 문자열을 탐색하여, 각 문자들의 빈도를 저장
2. 특정 문자의 빈도 수가 홀수인지 체크  
    2-1 홀수라면 프로그램 종료
3. 각 문자들의 빈도를 정렬(0이 아닌 문자들이 앞으로, 아스키코드가 큰 순으로)
4. 빈도 수가 홀수인 문자를 덱에 저장
5. 정렬한 문자들을 바탕으로 덱 완성  
    5-1 (문자는 짝수개로 있음) 덱의 front와 back에 현재 문자 push  
    5-2 현재 문자의 count 2 빼줌

> 정렬할 때 bool 함수 구현이 헷갈렸음
> 
> return a < b - 내림차순
> return a > b - 오름차순(default)

---

### 1309 동물원


💡 2*n 우리가 있을때 넣을수있는 사자의 경우의수를 구하는 문제



dp[0][n] = dp[0][n-1]+dp[1][n-1]+dp[2][n-1]

dp[1][n] = dp[0][n-1]+dp[2][n-1]

dp[2][n] = dp[0][n-1]+dp[1][n-1]

답: dp[0][n]+dp[1][n]+dp[2][n]

풀이

n번째 우리에서의 경우의 수는

n-1 우리에서 바로전 우리(n-1번째 울타리)에 사자가 있을때, 왼쪽에 있을떄, 오른쪽에 있을때

가 0,1,2 면

0에서 n번째 울타리에 사자를 안 넣거나, 왼쪽에 넣거나, 오른쪽에 넣거나

1에서 n번째 울타리에 사자를 안 넣거나, 오른쪽에 넣거나

2에서 n번째 울타리에 사자를 안 넣거나, 왼쪽에 넣거나

즉 n번째 울타리에 사자를 안넣은 경우의 수 - 0+1+2 (n-1 기준)

즉 n번째 울타리에 사자를 왼쪽에 넣은 경우의 수 - 0+2 (n-1 기준)

즉 n번째 울타리에 사자를 오른쪽에 넣은 경우의 수 - 0+1 (n-1 기준)

식을 정리하면

dp[0][n]+dp[1][n]+dp[2][n] = (dp[0][n-1]+dp[1][n-1]+dp[2][n-1])*2 + dp[0][n-1]

= dp[n-1]*2+dp[n-2] (깔끔)

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 1339 단어 수학

https://www.acmicpc.net/problem/1339

사용한 알고리즘: 그리디

시간복잡도: $O(nk)$ - n=단어개수, k=단어길이

과정
1. 단어들 길이로 내림차순 정렬
2. 단어 앞자리부터 가중치를 부여
3. 가중치순으로 알파벳에 숫자 입력
4. 알파벳에 입력된 숫자들을 바탕으로 문자를 숫자로 바꿔서 결과 출력

>
    2번 과정 설명
    
    ABCDA  
     DBCA  
      BAA
     
    위 단어들이 입력으로 주어졌을 때 2번 과정  
    
    1247(10)  
     358(11)   
      69(12)
    

> 이때 유의할 점   
> 가중치 부여할 때 유의해야 한다.
>
> ex)  
> BA 1개와 A 11개가 있으면  
> A가 B보다 가중치가 높아야 한다.
>
> => 자리수 올라갈 때, 가중치 * 10




---

### 1347 미로 만들기

https://www.acmicpc.net/problem/1347

> 주인공이 이동한 경로가 주어졌을 때, 해당 미로의 지도를 출력하라<br>
> (주인공은 이동할 수 있는 모든 곳을 다녔고, 미로의 모든 행과 열은 벽이 아닌 칸이 최소 한개는 존재한다)

사용한 알고리즘: 구현

시간복잡도: $O(n^2)$

주인공이 이동한 경로로 미로의 지도를 출력하는건 쉽지만,

처음 주인공의 위치가 주어지지 않아서 당황했다.

여기서 `모든 행과 열에는 적어도 하나의 이동할 수 있는 칸이 있다`이 말을 보고 문제를 풀 수 있었다.

경로의 최대 길이가 50이라서, 150x150정도의 크기인 2차원 배열에서, 주인공은 가운데서 시작한다.

경로대로 움직이면서, 주인공이 방문한 곳을 모두 표시하고, 주인공이 움직인 위치에서 행의 최댓값&최솟값, 열의 최댓값&최솟값을 모두 기록했다.

그 값들이 결과를 출력할 때의 범위가 된다. (모든 행과 열에는 적어도 하나의 이동할 수 있는 칸이 있기 때문)

    역시 문제를 제대로 봐야 한다.

---

### 1400 화물차

https://www.acmicpc.net/problem/1400

`사용한 자료구조 & 알고리즘:` BFS, 우선순위 큐

`시간복잡도:` $O(n^2*logn)$

`어떻게 접근했는지, 풀었는지 설명:`

최단거리를 구하는 문제이기 떄문에, 일반적인 BFS이지만,  
살짝 응용이 필요하다.

여기서는 교차로가 문제다.

교차로에 대해서는 따로 visited를 처리해줬다.

> 교차로를 상하좌우에서 접근할 때의 경우가 모두 다르기 때문이다.

그리고 교차로에 진입할 수 있는 시간이 그때그때 다르기 떄문에,  
교차로에 진입할 수 있는 시간을 메서드화 해서 구했다.

그리고 일반적인 bfs는 큐를 사용하는데,  
이 문제는 우선순위 큐를 사용했다.

> 일반적인 bfs는 무조건 먼저 이동하는 원소를 push 해줬다.  
> (먼저 이동하는 놈의 cnt가 나중에 이동하는 놈의 cnt보다 작기 때문에)
> 
> 하지만 교차로는 먼저 push 했을 때,  
> 이 원소의 cnt가 뒤에 추가되는 원소의 cnt보다 클 수 있다.  
> -> 자동으로 정렬해주기 위해 우선순위 큐를 사용했다.

일반적인 bfs 메서드에서  
visited 처리하는 메서드 (1)  
교차로에 진입할 수 있는 시간을 구해주는 메서드 (2)  
위 두가지를 처리해줌으로써 깔끔하게 풀 수 있었다.

> 이 문제를 그나마 깔끔하게 풀 수 있었던 이유는  
> bfs의 visited에 대한 이해가 되어있기 때문이다.  
> (bfs의 visited도 DP를 이용한 알고리즘)
>
> 최단 거리를 구할떄, 현재 위치 i에 지금 도착했을 때 visited를 처리해주는 이유:  
> 나중에 i에 도착하는 놈은 무조건 지금 도착한 나보다 늦게 도착한다. -> 최단거리에 해당하지 않는다.  
> -> visited를 통해 나중에 오는 놈은 무시한다.
>
> 위의 visited 예시와, 이 문제는 살짝 다르다. (교차로에 대해서)  
> 지금 (r,c) 위치에 왼쪽에서 접근하는 경우와, 나중에 위에서 접근하는 경우는 다르다.  
> (나중에 위에서 접근했을 때가 최단거리일 수 있다)  
> 그래서 교차로에 대해서는 접근 방향에 대해서도 visited를 처리해준 것이다.

    문제를 풀고 나서 생각해보니,  
    교차로의 visited를 조금 더 최적화 할 수 있을 것 같다.

    나는 교차로에 대해 상하좌우 4가지 모두 visited 검사를 했는데,
    결구 상하와 좌우는 세트이기 때문에, (위에서 접근하든 아래에서 접근하든 먼저 오는 놈이 먼자 출발할 것이다)
    교차로의 visited는 두가지로도 충분할 것 같다.

    그리고 교차로의 visited와, board의 visited는 다르기 떄문에  
    visited 관련 처리를 메서드화해서 더 편하게 처리할 수 있었다.

> 추가 접근 방법:  
> (다른 사람의 풀이를 보고 정리)
> 
> 나는 교차로에 접근할 때, 다음 cnt를 계산해서 직접 우선순위 큐에 push 해줬는데,
> 
> 다른 사람은, cnt가 변할 때마다 교차로의 신호를 직접 변경하고,  
> 현재 교차로에 접근하지 못한다면, 현재 위치를 그대로 큐에 push 해줬다. (cnt+1 저장)
> 
> 이 방법도 되게 좋은 것 같다.  
> (멈춰있는 건 visited와 관련없기 떄문에 가능하다)
> 
> 그런데 멈춰있는 시간이 너무 길어지면,  
> 교차로로 이동할 때까지, 계속 같은 위치를 push 하기 떄문에 살짝? 비효율적일 수도 있겠다는 생각이 든다.  
> 
> 대신 교차로의 visited, 우선순위 큐를 사용하지 않아도 되기 떄문에,  
> 코드는 깔끔해진다는 생각이 든다.

---

### 1422 숫자의 신

https://www.acmicpc.net/problem/1422

`사용한 자료구조 & 알고리즘:` 그리디

`시간복잡도:` $O(nlogn)$

`어떻게 접근했는지, 풀었는지 설명:`

두가지의 최적해를 적용했다.

최적해1:  
맨처음에는 k개의 수 중에서 n개만큼 골라야 하는데,  
여기서 k개는 전부다 1개씩 뽑고,  
n-k개는 k중에서 가장 큰 수를 뽑아야 한다.  
(9 와 8 중에는 9가 더 크다.)  
(12와 9 중에는 12가 더 크다. (일단 자릿수가 더 많은 수가 더 큰 수이기 때문))

최적해2:  
위에서 뽑은 n개의 수를 가지고 정렬을 해야 한다.  
직접 문자열을 가지고 비교하면 된다.  
```return a+b > b+a;```

    나는 맨 처음 두번째 최적해를 구하기 위해  
    직접 수학적으로 접근했다.
    
    그런데 그럴 필요가 없었다.
    직접 문자열을 더해서 문자열을 가지고 비교하면 되기 떄문이다.

---

### 1460 진욱이의 농장

https://www.acmicpc.net/problem/1460

`사용한 자료구조 & 알고리즘:` 누적합, DP, 이분 탐색

`시간복잡도:` $O(F^2 * N^2)$

`어떻게 접근했는지, 풀었는지 설명:`

1. 입력 받은 대로, 농장에 씨앗들의 정보를 저장한다. - O(M*N^2)
2. 과일 두가지를 선택한다. - 중복조합 O(F^2)
3. 2에서 고른 과일들에 해당하는 정사각형을 찾는다. - 누적합 O(N^2)
4. 2 & 3 반복


      나는 이분 탐색을 이용한 방법을 사용했다.
      1번까지 수행한 뒤,
      각 과일의 정보를 담은 누적합 배열을 만들었다. (NxNxF) // F: 과일의 개수
      그리고 이분 탐색을 이용해 정사각형의 길이가 mid일 때 가능한지 체크했다. - O(N^2 * F)
      (이때, 누적합 배열을 이용해 O(1)에 가능한지 체크)

      전체 시간복잡도: O(F * N^2 * logN)

> 이분 탐색을 이용한 접근 방법은 좋았지만,  
> 맨처음 1번을 수행할 때 실수가 있엇다.
> 
> 업데이트해야 할 과일, 영역 정보를 입력받았을 때  
> 이를 일일이 업데이트 해줘도 문제가 없었다. - O(N^2 * M)
> 
> 나는 이를 조금더 빠르게 처리하기 위해  
> 누적합을 이용해 처리했는데,  
> 이 부분에서 실수가 있었다.  
> (이 문제는 특정 영역을 더해주는 것이 아니라, 덮어씌우는 것이기 때문에)  
> (-> 이 부분은 따로 알아봐야 겠다)

---

### 1461 도서관

https://www.acmicpc.net/problem/1461

`사용한 자료구조 & 알고리즘:` 그리디, 정렬

`시간복잡도:` $O(NlogN)$

`어떻게 접근했는지, 풀었는지 설명:`

어제 풀었던 2513 문제와 형식이 거의 같은 문제  
(오히려 조금 더 쉬워진 문제)

여기서 적용되는 최적해:
1. 방향이 반대인 두 곳은 따로 처리한다.
   (같이 태우는 것은 최적의 경우가 아니다)
2. 가장 먼 곳의 사람부터 태운다

2513 문제와 다른 점은  
2513은 한 위치에 여러 원소가 있을 수 있는데,  
이 문제는 한 위치에는 무조건 한 원소만 있다는 것이다.  
-> 매 위치마다 개수를 세줄 필요가 없다.

그냥 1씩 빼주면서 count 해주면 쉽게 풀린다.

1. 부호를 기준으로 인풋을 두 컨테이너에 저장한다.
2. 두 컨테이너를 절댓값의 오름차순으로 정렬한다.  
   (음수 컨테이너는 greater<int>() 적용)
3. 둘 다 역방향으로 탐색한다.  
   (원점이 기준이기 때문)  
   현재 위치 i의 원소가 v[i] & 현재 가지고 있는 책의 개수 cnt (초깃값 0),  
   if cnt == 0, then result += v[i] * 2; temp = max(temp, v[i]); cnt = M;  
   (최대 M개의 책을 옮길 수 있으므로, 현재 옮길 수 있는 책들 중 가장 먼거리의 위치를 result에 더해주는 과정)  
   (매 탐색마다 cnt--; 를 수행)
4. result -= temp;  
   (가장 먼 거리의 책을 두번 옮겼으므로, 한번은 빼준다)

> 4번 로직은 최적해를 구하기 위한 로직이다.  
> (최대한 짧게 이동해야 하는데, 마지막 책을 옮길때는 원점에 올 필요가 없다 -> 한 번만 간다)

---

### 1464 뒤집기 3

https://www.acmicpc.net/problem/1464

`사용한 자료구조 & 알고리즘:` 그리디, 덱

`시간복잡도:` $O(N)$

`어떻게 접근했는지, 풀었는지 설명:`

0~1, 0~2, ..., 0~N-1 이렇게 뒤집을 수 있을 때  
사전순으로 가장 앞서는 문자열을 만드는 문제

이 문제를 풀 때 아이디어는 다음과 같다.  
k번쨰까지의 문자열이 사전순으로 가장 앞선 상태에서  
(덱큐 dq에 저장)  
k+1번째까지의 문자열이 사전순으로 가장 앞서려면,  
dq[0]과 str[k+1]을 비교해서,  
if dq[0] >= str[k+1], push_front  
(0~k 까지의 문자열을 뒤집지 않고 k+1 문자를 추가)  
else, push_back  
(0~k까지의 문자열을 뒤집고 k+1 문자를 추가)

> 여기서 뒤집는 행위를 일일이 하는 것이 아니라,  
> 덱을 이용해 구현하면 시간복잡도를 줄일 수 있다.
> 
> 뒤집는다 -> push_front  
> 안 뒤집는다 -> push_back

위 아이디어는 0-1, 0-2, ... 0-n-1 순으로 뒤집기 때문에  
적용할 수 있는 아이디어 이다.

(dq[0] ~ dp[k-1] 문자열과 관계없이 k번째 문자는 dq[0]만 비교하면 되는 문제)

        나는 처음 이문제를 다른 방식으로 풀었다가 헤맸다.

        내가 적용한 규칙  

        사전순으로 가장 앞선 문자 str[k]를 찾는다.
        0~k 문자열을 뒤집는다.
        이때 k+1 ~ N-1 위치들은 뒤집으면 안된다.

        그리고 0~k 문자열을 뒤집었을 때 사전순으로 가장 앞서려면,
        0~k-1 문자열이 `뒤집었을 때` 사전순으로 가장 앞서야 한다.

        여기서 나는 약간 틀리게 생각했다.  
        (0~k-1 문자열이 사전순으로 가장 늦어야 한다)

        그리고 위 아이디어를 직접 코드로 구현하긴 힘들 것 같다.

---

### 1493 박스 채우기

https://www.acmicpc.net/problem/1493

`사용한 자료구조 & 알고리즘:` 그리디, 구현

`시간복잡도:` $O()$

`어떻게 접근했는지, 풀었는지 설명:`

최대한 큰 박스로 input 박스를 채워야 한다.  
1. 현재 input 박스로부터 채울 수 있는 박스의 가장 긴 변을 찾는다.
2. 해당 변에 해당하는 박스로 input 박스를 채운다.  
   (안된다면 작은 박스로 채운다)
3. 남은 부분을 queue에 넣어줘서 1,2을 반복한다.

> 남은 부분을 계산하는 방법  
> 
> 남은 부분은 3부분으로 나눌 수 있다.  
> 이때 처리하는 방법에서 경우의 수가 생기는데,  
> 박스는 3차원이기 때문에 우선순위를 적용해주면 간단하게 처리할 수 있다.
> 
> 남은 변의 길이 tl, tw, th가 있을 것이다.  
> (input 박스 길이 l, w, h)  
> 
> 처음에는 (tl,w,h)를 queue에 push 해준다.  
> 그 다음은 (tw,l-tl,h)를 push 해준다.  
> 마지막으로 (th,l-tl,w-tw)를 push 해준다.
>
> (단순하게 만드는 규칙 잊지 말자 - 정렬 or 순서를 정해줌으로써 경우의 수를 줄인다)

> 이 문제에서는,  
> 큰 박스 대신 작은 박스를 쓴다고 결과가 더 작아지지 않는다.  
> (박스들이 정확히 배수 관계에 있기 때문) <- 핵심  
> -> 최대한 큰 박스를 사용해야 한다.
> 
> 만약 3x3x3, 4x4x4 이렇게 있었다면 예외가 있었을 것이다.  
> 하지만 이 문제의 박스들은 모두 2의 지수 길이를 가지고 있기 때문에 이런 예외가 없다.

이 문제에서 실수한 것들
1. iterator 관리  
   begin인데 --하려는 것
2. 타입 관리  
   int 형 범위를 넘는데, long long을 쓰지 않은 것  
   long long 이여도, 중간 중간 연산이 int형이면, 결과도 int형이 된다는 것


      다른 사람의 풀이를 보니
      pow 메서드를 이용해 2의 지수인 길이를 구한 것이 아니라, 
      shift 연산을 이용해 2의 지수인 길이를 구한 것이 있었다.
      1 << idx == pow(2, idx) 이다.

      그리고 현재 상태의 인풋에 박스를 넣을 수 있을 때
      한번에 박스를 최대로 넣어주는 것이 아니라,
      한개 넣고, 3개로 나눠서 다시 구하는 방법도 있었다.
      -> 굳이 계산하지 않고 진행하기 때문에 더 간단해 보인다.

      마지막으로 나는 iterator를 사용하는 것이 되게 번거로웠는데,
      그 이유는 iterator를 가지고 역순으로 접근했기 때문이다. 
      (begin, end)
      이때는 reverse_iterator를 사용하면 더 간단하게 접근할 수 있다.
      (rbegin, rend)

---

### 1509 팰린드롬 분할

https://www.acmicpc.net/problem/1509

`사용한 자료구조 & 알고리즘:` DP

`시간복잡도:` $O(N^2)$

`어떻게 접근했는지, 풀었는지 설명:`

팰린드롬을 구할 떄도 DP를 사용하고,  
팰린드롬 집합을 구할 떄도 DP를 사용한다.

(i,j < N 일 때)  
pal[i+1][j-1]이 true이고 input[i]와 input[j]가 같다면,  
pal[i][j]도 true 이다.

이를 이용해 전체 문자열에서 팰린드롬들을 구할 수 있다.  
($O(N^2)$)

그리고 이를 이용해 팰린드롬 집합을 구해야 하는데,  
```int getMax(int index)``` - index번부터 팰린드롬 집합의 최솟값을 구한다.

위에서 구한 팰린드롬 배열을 이용해 O(N^2)으로 구할 수 있다.

    처음엔 팰랜드롬 구하는 법을 까먹어서  
    예전에 풀었던 내용을 다시 볼 수 밖에 없었다.
    문제 푼 것들을 내 머리속에 쌓기 위해서는 복습이 필수인 것 같다.

---

### 1520 내리막길 & 1937 욕심쟁이 판다


💡 그래프와 dp가 섞인 문제

1520은 경우의수, 1937은 경우의수중 최댓값 구하는 문제



2차원 배열이 주어지는데, 각 위치마다 값이 있고

상하좌우의 값을 비교해서 값보다 작다면(크다면) 이동할수 있음

그상황에서 가장 많은 경우의 수 or 최대 이동값을 찾는 문제

⇒ 우선순위 큐를 이용, 내림차순(오름차순)으로 정렬후 한개씩 받아서 현재위치 dp값+1이

다음위치 dp값보다 크다면 저장함.

이게 성립하는 이유는 (내림차순 기준),  
무조건 값이 작을때만 이동할수 있기때문에,  
가장 큰값을 쓰면 그 위치는 다시 갈수없다. 따라서 dp가 적용됨

---

### 1600 말이 되고픈 원숭이

https://www.acmicpc.net/problem/1600

`사용한 자료구조 & 알고리즘:` bfs

`시간복잡도:` $O(NMK)$

`어떻게 접근했는지, 풀었는지 설명:`

전형적인 BFS 문제

대신 K번 점프할 수 있기 떄문에,  
이를 따로 visited 체크 해줘야 한다.

> 기존 bfs는 visited의 크기를 R*C 만큼 생성하면 됐는데,  
> 이 문제는, K번 점프할 수 있기때문에,  
> i번 점프할 수 있을 때의 [r][c]와 i-1번 점프할 수 있을 때의 [r][c]가  
> 다른 케이스로 취급된다.
> 
> 따라서 visited의 크기를 R*C*K 만큼 생성해줘야 한다.  
> visited를 체크해줄 때도, [r][c][k] 로 생각해야 한다.



---

### 1701 cubeditor

https://www.acmicpc.net/problem/1701

`사용한 자료구조 & 알고리즘:` 문자열

`시간복잡도:` $O(N^2)$

`어떻게 접근했는지, 풀었는지 설명:`

문자열 str이 입력됐을 때,  
부분 문자열이 두번 이상 나타나는 것들 중에 가장 긴 것의 길이를 구하는 문제

부분 문자열이 두번 이상 나와야 하기 때문에,  
모든 문자를 체크했다.

1. 문자열의 각 문자를 알파벳으로 정리 - {문자, 위치 리스트, 길이} Infor라는 커스텀 객체로 저장
2. 정리한 객체들을 queue에 넣는다.
3. queue의 원소들을 한번씩 탐색한다.
4. 각 문자의 위치를 기준으로, 길이를 늘려가며 탐색한다.
   이때 각 문자는 같은 문자지만, 다음 문자가 다른 문자일 수 있으므로  
   map<char, Infor> 를 이용해 // {다음 문자, 다음 문자에 대한 정보}
   따로 관리해줬다.
5. map에 있는 원소들을 탐색한다.
   1 - 현재 Infor의 위치 리스트의 길이가 1이하면 그대로 종료  
   (이때 길이-1 이 최대 길이인지도 체크해준다)
   2 - queue에 push // 다음 문자에 대한 정보를 넣어준다.

위 과정을 반복하면서 결과를 구했다.

    이 문제는 문자열의 길이가 5000 이하라서, O(N^2)으로 풀 수 있었다.

---

### 1715 카드 정렬하기

https://www.acmicpc.net/problem/1715

사용한 자료구조 & 알고리즘: 그리디, 우선순위 큐

시간복잡도: $O(nlogn)$

어떻게 접근했는지, 풀었는지 설명:

적용한 아이디어:  
개수가 적은 카드를 우선적으로 정렬한다.

입력된 카드들을 우선순위 큐에 삽입 (오름차순으로 정렬되어 있다)  
두개씩 꺼내서 더한 것을 result에 더함 & 우선순위 큐에 삽입  
(만약 1개 남았다면 result와 남은 1개를 더해준다)

---

### 1722 순열의 순서

https://www.acmicpc.net/problem/1722

사용한 자료구조 & 알고리즘: 구현, 조합

시간복잡도: $O(n^2)$

(숫자 하나 받고 그 숫자에 해당하는 순열 출력하는 문제 가정)

N = 4인 순열은

(1,2,3,4), (1,2,4,3), (1,3,2,4), (1,3,4,2), (1,4,2,3), (1,4,3,2), (2,1,3,4), ...

여기서, 전체 24개 중에, 6(=24/4)개씩 앞자리 숫자가 같다. (1, ...) 6개, (2, ...) 6개, (3, ...) 6개, (4, ...) 6개  
그 다음으로 (1, ...)에서, 전체 6개 중에, 2(24/(4*3))개씩 순서가 같다. (1,2, ...) 2개, (1,3, ...) 2개, (1,4, ...) 2개

따라서 인풋 K가 몇보다 크고 몇보다 작냐에 따라서 순열을 예측할 수 있다.

> N = 4, K = 3
> 
> 0 < K <= 6 -> 첫번째 숫자 1  
> 2 < K <= 4 -> 두번째 숫자 3, (K -= 2)  
> 0 < K <= 1 -> 세번째 숫자 2  
> 마지막 숫자 4

1. K가 몇보다 크고 몇보다 작은지 구한다.
2. 순서를 찾아서, 순서에 해당하는 숫자를 찾는다.
3. 위의 과정을 반복

> 순열의 특징을 이용한 문제  
> 특징을 잡는건 빨랐는데, 이를 코드로 구현하는데 시간이 지연됐다.  
> 역시 제대로 설계를 해놓고 코드 구현을 해야 한다.

---

### 1725 히스토그램

https://www.acmicpc.net/problem/1725

> 막대그래프가 주어졌을때 막대그래프에 대해, 가장 큰 직사각형의 넓이를 구하는 문제

사용한 알고리즘: 분할 정복

시간복잡도: $O(nlgn)$

종만북을 보면서 이 문제를 풀 수 있었다.

브루트포스는 $O(n^2)$이 걸리지만, 분할정복을 사용해서 시간복잡도를 더 줄일 수 있었다.

    가운데 좌표를 기준으로
    1. 왼쪽 블럭만으로 구하는 최대 넓이
    2. 오른쪽 블럭만으로 구하는 최대 넓이
    3. 가운데 좌표를 포함했을때 구하는 최대 넓이

    위 세가지중 최대 넓이가 정답이다.

가운데 좌표를 포함하는 직사각형의 최대넓이를 구하는 방법은,<br>
가운데에서 시작해서, 왼쪽 높이와 오른쪽 높이를 비교해서 더 높은쪽으로 좌표를 옮긴다.(투포인터)

위 방법을 계속하면 최대 넓이를 구할 수 있다.

    왼쪽 오른쪽 좌표를 옮길때 좌표가 범위를 벗어나는 걸 생각해야하는데
    처음부터 이를 포함해서 if문을 짜지 말고,
    한개씩 전부다 if문으로 일일이 짜주자
    그래야 빠르다

---

### 1727 커플 만들기

https://www.acmicpc.net/problem/1727

`사용한 자료구조 & 알고리즘:` 그리디, DP

`시간복잡도:` $O(N^2)$

`어떻게 접근했는지, 풀었는지 설명:`

내 생각에 이 문제는
1. 그리디만 가지고 풀 수 없는 문제
2. 그리디를 적용한 DP를 이용하는 문제

`그리디만 적용하면 틀리는 이유`

일단 바로 반례를 보면,

4 6  
30 40 80 90  
1 39 50 70 89 200

위 예시의 정답은 30이다.  
(30-39 / 40-50 / 80-70 / 90-89)


여기서 그리디 알고리즘만 적용한다면 오답이 나온다.  
(최적해: i번째 남자는 가장 성격 차이가 적은 사람을 선택한다)  
오름차순으로 선택하면  
30-39 / 40-50 / 80-89 (x) / 90-70 (x) = 48  
내림차순으로 선택하면  
90-89 / 80-70 / 40-39 (x) / 30-50 (x) = 32  
최적해만 가지고는 최솟값이 나올 수 없다.  

결국 모든 케이스를 탐색 해봐야 한다.


`그리디를 적용한 DP`

결국 최적화를 위해 DP를 사용하는데 여기서도 규칙이 존재한다.  
(두 배열이 정렬되었다 가정 && 여자의 수가 남자의 수보다 많다 가정)  
(k = 남자 번호, s[k] = 남자가 선택한 여자 번호)  
' i < j 라면, s[i] < s[j] 여야 한다 '

최솟값이 나오도록 고르려면, 매칭 됐을 때 남자들의 선택이 교차되면 안된다.  
(위의 그리디의 반례 케이스에서 그리디만 적용하면 교차되게 선택을 해서 오답이 나온다)

이 규칙을 가지고 DP를 이용해 문제를 풀어야 한다.

이 규칙을 적용했을 떄의 문제는  
https://www.acmicpc.net/problem/1010  
위 사이트의 문제와 거의 똑같아 진다.  
(위 사이트의 문제도 DP를 이용해 푸는 문제)

결국 이 문제는 그리디를 적용한 DP를 이용해야 풀 수 있는 문제

    그리디를 적용함으로써, DP를 적용할 수 있었떤 문제
    항상 앞사람보다 번호가 큰걸 골라야 하므로 겹치지 않는다.
    -> 메모이제이션 가능

    그리디와 DP 실력이 부족하다.

---

### 1732 레이저

https://www.acmicpc.net/problem/1732

`사용한 자료구조 & 알고리즘:` 자료 구조, 기하학

`시간복잡도:` $O(nlogn)$

`어떻게 접근했는지, 풀었는지 설명:`

n의 최댓값이 10만이기 때문에, O(n), O(nlogn)으로 풀어야 한다.
(따라서 하나의 기둥과 다른 모든 기둥을 비교하는 연산을 불가능하다)

이때 원점에서 가까운 기둥을 먼저 탐색하면서,  
기울기가 같은 기둥을 비교하면 O(n)으로 풀 수 있다.

이떄 기울기가 같은 걸 표현하는 방법이 까다로웠다.  
(기울기는 소수가 나올 수 있기 떄문에)

따라서 x, y의 gcd를 구해서, 기울기를 표현했다.

> {x,y}의 기울기 = {x/gcd, y/gcd}의 기울기  
> (gcd는 numeric 라이브러리의 메서드 활용)

따라서 {x,y}를 key로 하고,  
vector<Infor>를 value로 하는 map을 만들어서,  
같은 기울기를 가진 기둥들을 모아놓았다.  
(Infor: 기둥의 x,y좌표, 기둥의 높이)

이때 원점에서 가까운 기둥을 먼저 탐색해야 한다.  
-> x좌표의 부호를 기준으로 정렬한다. (x < 0, x의 내림차순 정렬 / x > 0, x의 오름차순 정렬)

그리고 x축이나 y축에도 기둥이 있을 수 있다.  
이때는 map이 아닌 별도의 vector로 관리해줬다.

    x축, y축에 있는 기둥을 관리할 때도,  
    부호를 기준으로 정렬해줘야 한다.
    -> 4개의 벡터가 추가로 필요하다.

---

### 1744 수 묶기

https://www.acmicpc.net/problem/1744

사용한 자료구조 & 알고리즘: 그리디

시간복잡도: $O(n)$

어떻게 접근했는지, 풀었는지 설명: 

양수, 음수, 0을 나눠서 처리하면 편해진다.

양수, 양수 조합 - 큰 수기리 곱한다.  
(이때 1은 그냥 더한다(곱하면 사라짐))

음수, 음수 조합 - 작은 수끼리 곱한다(절댓값이 큰 수끼리 곱한다)

만약 음수가 홀수 개라면 0과 곱해야 한다.  
(0이 없다면 어쩔 수 없이 더해야 함)

0 - 음수를 곱해서 없애는 역할, 2개 이상은 필요 없다.

---

### 1756 피자 굽기

https://www.acmicpc.net/problem/1756

사용한 자료구조 & 알고리즘: 구현

시간복잡도: $O(n)$

피자마다 들어갈 수 있는 위치를 찾는 건 너무 비효율적 - $O(n^2)$ (n <= 300000)

-> 오븐의 각 위치에서 받을 수 있는 피자의 최대 크기를 저장 해놓는다. & 맨 뒤부터 피자가 들어갈 수 있는 곳을 찾는다.  
-> O(n)에 가능

> 모든 테스트 케이스를 완벽하게 생각하지 못햇지만, 아다리로 맞췄다.  
> 항상 히든 케이스를 생각해야 한다.

---

### 1761 정점들의 거리

https://www.acmicpc.net/problem/1761

`사용한 자료구조 & 알고리즘:` 최소 공통 조상

`시간복잡도:` $O(MlogN)$

`어떻게 접근했는지, 풀었는지 설명:`

두 노드 사이의 거리를 구하는 문제라서  
처음에는 플로이드-와샬 알고리즘을 사용하려고 했지만,  
정점, 간선의 개수가 너무 많아서 TLE가 난다.

여기서 이 그래프가 트리라는 것을 이용해야 한다.  
-> 트리에서 두 노드 사이의 거리를 구하는 방법은 LCA(최소 공통 조상)을 이용하면 된다.

1. 간선 정보를 가지고 트리를 만든다.
2. 각 노드의 깊이(높이)를 저장한다.
3. 원하는 두 노드의 번호가 주어지면,  
   1 - 두 노드의 깊이를 맞춰준다. (맞춰주면서 거리 계산)  
   2 - 두 노드가 같아질 때까지 올라간다. (또한 거리 계산)  
   3 - 두 노드가 같아지면, 거리를 출력한다.

트리에서, 루트부터 특정 노드까지 탐색하는 시간복잡도는 $O(logN)$이다.  
이를 M번 반복하므로 $O(MlogN)$이 된다.

---

### 1781 컵라면

https://www.acmicpc.net/problem/1781

`사용한 자료구조 & 알고리즘:` 그리디, 우선순위 큐

`시간복잡도:` $O(nlogn)$

`어떻게 접근했는지, 풀었는지 설명:`

그냥 오름차순으로 탐색하면, 경우의 수가 너무 많다.

> 1,5 1,2 2,3 2,7 이면
> 1-1,5 2-2,7 이 맞지만
>
> 1,2 1,3 2,5 2,6 이면
> 1-2,6 2-2,5 가 맞다.
> 
> 경우의 수가 너무 많아진다.

그래서 내림차순으로 탐색한다.
1. 가장 데드라인이 맞은 컵라면을 마지막 날로 선택
2. 현재 day(curD) 보다 높은 데드라인을 가지고 있는 문제들을 우선순위 큐에 저장
3. curD -= 1 && 우선순위 큐에서 가장 높은 값을 result에 더함
4. 2,3을 반복  
   만약 curD가 현재 데드라인보다 높지만, 우선순위 큐가 비었다면
   curD = 현재 데드라인
   > ex) 2,3 2,4 12,5 12,6 이라면,  
   > 12-6 11-5 를 고르는데, 2일까지 풀 문제가 없다.  
   > (우선순위 큐가 비었지만, curD가 현재 데드라인(2)보다 높은 상황)
   > -> curD = 2 로 세팅


    그리디 알고리즘 문제들은 
    내가 직접 테스트 케이스를 풀면서 
    어떤 방식을 적용하는지 의식하면서 푸는게 중요한 것 같다.
    이를 통해 최적해를 구할 수 있었다.

---

### 1789 수들의 합

https://www.acmicpc.net/problem/1789

`사용한 자료구조 & 알고리즘:` 그리디

`시간복잡도:` $O(N)$

`어떻게 접근했는지, 풀었는지 설명:`

N개의 서로 다른 자연수를 더했을 때 합이 S가 된다고 할 떄,  
N이 최대가 되려면 결국 1부터 더해줘야 한다.

> 개수를 최대한 많이 늘리기 위해 작은 수부터 더하는 것

이때 1부터 N까지 더한 것이 S보다 커질 때가 있는데  
이때는 N-1이 정답이 된다.

> 4는 1+2+3 보다 작다.
> 여기서 N을 최대로 하려면  
> N=2가 된다.
> (3은 불가능)
> 
> 5도 마찬가지
> 
> 6 = 1+2+3
> 따라서 N=3

전체 과정
1. N=1부터 더하면서 S와 비교한다.
2. sum이 S와 같다면 그대로 N 출력
3. sum이 S보다 크다면 N-1 출력

---

### 1806 부분합
> n개의 자연수로 이루어진 수열이 주어졌을때, 
> 이 수열에서 연속된 수들의 부분합 중에 그 합이 s 이상 되는 것중 가장 짧은 것의 길이를 구하는 문제

시간복잡도 $O(n)$
두개의 포인터 l,r (l=0, r=1), result = MAX (MAX > n)

l번째 위치부터 r-1번째 위치까지의 합을 cur이라 하면

cur < s 일때 l++

cur >=s 일때 r++,
현재 r - l 이 result보다 작다면 result = r - l

답은 result

---

### 1826 연료 채우기

https://www.acmicpc.net/problem/1826

사용한 자료구조 & 알고리즘: DP

시간복잡도: $O(n^2)$

어떻게 접근했는지, 풀었는지 설명:

n의 최대 크기가 10000이라 dp도 가능하다고 생각해서 dp를 사용했다. (10000 * 10000 = 1억)

dp 배열에는 (도착 횟수, 남은 연료) 를 저장한다. (도착횟수 오름차순)  
처음에는 (0, P)를 저장한다.

모든 마을을 순회하며 dp 배열을 업데이트 한다.
1. 0번째 원소의 연료가 이전 마을과의 거리보다 크다면, dp[0].p -= distance // 이전 마을과의 거리
2. i번쨰 원소와 i-1번째 원소를 비교 (0 < i <= N)
3. N번째 원소의 연료가 이전 마을과의 거리보다 크다면, dp.push_back(dp[N].l+1, dp[N].p-distance+현재 주유소의 연료)

> 나는 dp로 풀었는데, 이 문제는 그리디 & 우선순위 큐로 푸는게 정석이었다고 한다.
> 
> 현재 연료로 갈 수 있는 주유소 중에 가장 연료를 많이 주는 곳을 간다.  
> (만약 갈 수 있는 곳이 없다면 그대로 -1 출력 & 종료)  
> (만약 목표 지점에 갈 수 있다면 바로 종료)
> 
> 그리디를 적용할 수 있는 최적의 선택은 '갈 수 있는 주유소 중에 가장 연료를 많이 주는 곳을 가는 것이 최적이다' 이다.  
> (주유소를 가는 순서는 상관이 없음 - 처음에 먼 곳을 간 다음, 나중에 가까운 곳을 가도, 결국 순서대로 가는 것과 같기 떄문)

> 처음에는 마을마다 나올 수 있는 (도착 횟수, 남은 연료) 을 전부 저장해서 메모리 초과가 났다.  
> 
> -> 예상 메모리 범위도 생각하자
> 
> 그리고 입력으로 주어지는 것은 무조건 정렬되어 주어지는 것이 아니니 주의하자

---

### 1915 가장 큰 정사각형


💡 2차원 배열이 주어졌을때, 해당 배열중 가장 큰 정사각형의 넓이를 찾는 문제



나는 누적합을 이용해서 겨우 풀었지만

dp를 이용한 방법은 몰랐다.

if (board[i][j] == '1') dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;

dp는 해당 위치에서의 정사각형의 최대 길이

풀이

1 1

1 1

이 정사각형이 있다면, min(1,min(1,1))+1 = 2

1 1

0 1

이라면, min(1, min(0,1)) + 1 = 1

결국 모두 1로 채워져야 최대값이 갱신된다.

dp는 많이 풀어봐야 한다.

---

### 1939 중량제한

https://www.acmicpc.net/problem/1939

`사용한 자료구조 & 알고리즘:` 다익스트라

`시간복잡도:` $O(NlogN)$

`어떻게 접근했는지, 풀었는지 설명:`

다익스트라의 응용 버전

다익스트라는 최단 거리를 구하는 알고리즘

이 문제에선, 최대 중량을 구한다.

기본적인 다익스트라 과정(최단 거리)
1. 시작점을 우선순위 큐에 넣는다. {0,시작점} (가중치 오름차순으로 정렬)
2. 우선순위 큐에서 하나씩 꺼내면서, 연결된 노드들을 탐색한다.
3. 규칙에 따라 가중치를 갱신한다.  
   if(dp[cur] + weight < dp[next]) dp[next] = dp[cur] + weight
   
이 문제에선, 최대 중량을 구해야 하므로,
1, 3번이 다르다.

1. 시작점을 우선순위 큐에 넣는다. {INF,시작점} (가중치 내림차순으로 정렬)
2. 우선순위 큐에서 하나씩 꺼내면서, 연결된 노드들을 탐색한다.
3. 규칙에 따라 가중치를 갱신한다.  
   if(min(dp[cur], weight) > dp[next]) dp[next] = min(dp[cur], weight)

> 이 문제를 다익스트라의 응용으로 풀 수 있었던 이유  
> -> 다익스트라가 dp를 이용해 최단거리를 구하는 알고리즘이기 때문
> 
> DP가 적용될 수 있는 하나의 규칙(최단 거리 기준)  
> `우선순위 큐에서 가중치가 가장 작은 것부터 꺼낸다`  
> 
> 현재 위치에서 거리가 가장 짧은 곳을 한번 방문하면,  
> 다른 노드를 거쳐도 거리가 더 짧아지지 않는다.
> 
> 위 원리가 최대 중량을 구할 때도 똑같이 적용된다.

---

### 1946 신입 사원

https://www.acmicpc.net/problem/1946

`사용한 자료구조 & 알고리즘:` 그리디

`시간복잡도:` $O(NlogN)$

`어떻게 접근했는지, 풀었는지 설명:`

인풋들을 시험 순위 오름차순, 면접 순위 오름차순으로 정렬하면  
맨 앞에 있는 사람은 무조건 통과한다. (시험 순위가 가장 좋기 때문)  
뒤에 있는 사람들은 앞사람들보다 시험 순위가 낮으므로  
면접 순위가 앞사람들보다 높다는 걸 증명해야 한다.

전체 과정
1. 인풋들을 정렬 (시험 순위 오름차순, 면접 순위 오름차순)
2. 앞 사람들의 면접 순위 중 가장 낮은 것보다 작다면 통과 (result + 1)

---

### 1949 우수사원

https://www.acmicpc.net/problem/1949

`사용한 자료구조 & 알고리즘:` 트리, DP

`시간복잡도:` $O(N)$

`어떻게 접근했는지, 풀었는지 설명:`

사회망 서비스 문제(2533)과 비슷한 문제.

해당 문제는 선택하는 노드의 개수를 최소로 하는게 핵심  
이 문제는 노드의 value의 합을 최대로 하는게 핵심이다.

`dp[flag][index]` 부모 노드가 우수 마을일 때, index와 그 하위 트리에서 나올 수 있는 최댓값을 저장  
(flag = 0,1, index <= N)

`int getMax(int index, int flag)` dp 배열과 같다

이때 부모 노드는 탐색하지 않기 위해 visited를 사용했다.

그리고 한번도 자식 노드를 탐색하지 못한 노드는  
리프 노드 이기 때문에,  
별도로 처리 해줬다.
별도로 처리 해줬다.

---

### 1976 여행 가자

https://www.acmicpc.net/problem/1976

사용한 자료구조 & 알고리즘: 분리 집합

시간복잡도: $O(mlogn)$

어떻게 접근했는지, 풀었는지 설명:

확인해야 할 것은  
m개의 input이 연결되어 있는지 않되어 있는지  
-> 분리 집합의 대표적인 유형

이 문제는 연결되어 있는지만 물어보기 때문에  
분리 집합 알고리즘을 사용할 수 있었다.

만약 최단거리에 대해 물어본다면  
다익스트라, 플로이드-와샬 알고리즘을 썼을 듯  
(시간복잡도가 올라가지만)

---

### 1981 배열에서 이동

https://www.acmicpc.net/problem/1981

`사용한 자료구조 & 알고리즘:` 이분탐색, BFS

`시간복잡도:` $O(N^2TlogT)$

`어떻게 접근했는지, 풀었는지 설명:`

1. 이분탐색으로 최솟값 탐색
2. BFS로 성공한다면 right=mid-1 을 통해 최솟값 탐색
   실패한다면 left=mid+1 을 통해 더 큰 값으로 탐색

이분탐색을 이용한 접근은 옳은 접근이지만,  
BFS를 적용할 때 실수가 있었다.
(최대-최소)의 최솟값을 찾는 것이기 떄문에,  
현재 board의 값이 포함될지 안될지 확인할 수가 없었다.

> ex)  
> 1 2  
> 0 2  
> 라면
> 
> 1-2-2 -> 1 이 정답인데,  
> 탐색 순서에 의해
> 1-0-2을 먼저 탐색해서 (visited 처리에 의해)  
> 원하는 답을 몾 찾을 수 있다.

그래서 그냥 BFS를 하기 전  
먼저 (최대-최소)를 찾기 위해 visited를 전처리 해주는 과정이 필요하다.

현재 mid가 k라면,  
board의 minValue ~ maxValue까지 for문을 통해 모든 경우의 수를 탐색해야 한다.  
if(i <= board[r][c] && board[r][c] <= i + mid) {visited 가능}
else {visited 불가능}

위 과정을 통해 visited를 전처리 해주고, BFS를 이용하면 원하는 답을 찾을 수 있다.

    이분탐색은 올바른 접근이였지만, BFS 전 visited 전처리를 생각하지 못했다.
    그냥 visited 처리하는 것은 DP의 메모이제이션처럼 이전 과정과 이후 과정이 관계가 없을 때만 
    가능하다는 것을 잊고 있었다.

---

### 2064 IP 주소

https://www.acmicpc.net/problem/2064

`사용한 자료구조 & 알고리즘:` 구현, 비트마스킹

`시간복잡도:` $O(N^2)$

`어떻게 접근했는지, 풀었는지 설명:`

1. 인풋으로 주어진 IP 주소들을 '.' 을 기준으로 split 한 다음,  
   각 string 타입을 int로 변환한다.
2. (맨 앞자리부터 시작) 각 위치의 숫자들이 같은지 비교한다.  
   비트 연산자를 이용해 구현했다.


      이 문제를 풀면서 regex의 delimiter의 패턴을 놓쳤다.
      '.' 이 아닌, '\\.' 이다.

      string 타입 변수를 int로 변환할 때, stoi를 사용했다.
      int 타입 변수를 string으로 변환할 때, to_string을 사용했다.

---

### 2109 순회강연

https://www.acmicpc.net/problem/2109

사용한 자료구조 & 알고리즘: 그리디, 우선순위 큐

시간복잡도: $O(nlogn)$

어떻게 접근했는지, 풀었는지 설명:

핵심은 강연 비용이 높은 강연을 최대한 늦게 하는 것  
A: 3,10 / B: 1,50 / C: 10, 15  
-> 1일에 B, 3일에 A, 10일에 C를 한다.

ex)   
1,10 / 2,50 / 2,50 강연 3개가 있다면  
1,10을 뺀 나머지 두개의 강의를 선택해야 한다.

강연을 날짜의 오름차순으로 탐색하면 위 케이스를 체크할 수 없다.  
-> 강연을 날짜의 내림차순으로 탐색한다.

(현재 강연 날짜 = cnt라고 가정)  
내림차순으로 탐색하면서 현재 날짜일 때(cnt),  
강연할 수 있는 강연들 중에 비용이 가장 높은 것을 선택  
& cnt -= 1

전체 순서
0. input으로 받은 강연들을 날짜 내림차순으로 정렬, 현재 날짜인 cnt를 최댓값으로 세팅, 우선순위 큐(pq)를 비용의 내림차순으로 세팅
1. input 배열을 한개씩 순회(iterator)  
1-1 cnt가 현재 위치의 강연 날짜보다 작거나 같아질때까지 && pq가 빌때까지, pq에 있는 강연들을 일정에 넣는다.  
1-2 cnt > (*iter).d cnt = (*iter).d  
(pq에 있는 강연들을 다 담았음에도 현재 위치의 강연 날짜보다 cnt가 크다 == (*iter).d까지 강연을 할수 없다 -> cnt를 (*iter).d까지 떙김)  
1-3 현재 위치의 강연 날짜가 cnt보다 커질 때까지, pq에 input 배열의 강연들을 넣는다.
2. pq가 빌 때까지 || cnt가 0이 될 때까지 pq에 있는 강연들을 일정에 넣는다


    핵심은 마감일이 많이 남은 것, 점수가 높은 것 부터 탐색하면서,  
    할일들을 세팅하는 것이다.

---

### 2110 공유기 설치

https://www.acmicpc.net/problem/2110

`사용한 자료구조 & 알고리즘:` 이분 탐색

`시간복잡도:` $O(nlogt)$

`어떻게 접근했는지, 풀었는지 설명:`

공유기 사이 최대 거리를 이분 탐색을 이용해 찾는다.

그리고 이분 탐색을 이용할 떄마다, n개의 집을 탐색하면서  
해당 거리를 유지하면서 설치할 수 있는지 체크한다.

가능하면, 더 큰값을 찾기 위해 left = mid + 1  
불가능하면, 더 작은값을 찾기 위해 right = mid - 1

좌표의 최댓값이 10억이라서  
시간복잡도는 O(NlogT) = 20만 * log(10억) 이라 통과한다.

---

### 2170 선 긋기

https://www.acmicpc.net/problem/2170

`사용한 자료구조 & 알고리즘:` 정렬

`시간복잡도:` $O(nlogn)$

어떻게 접근했는지, 풀었는지 설명:

시작점, 종료점 을 입력 받으면

{점의 위치(int), 종료점 인가?(bool)} 를 벡터에 push 해준다.

그리고 벡터를 정렬한다.
(그럼 점의 위치 오름차순, 종료점 오름차순 으로 정렬 되어 있다)

첫번째 인덱스부터 마지막까지 순회를 도는데,  
현재 점이 시작점이면 cur += 1,  
종료점이면 cur -= 1 해준다.

이때 +1 해줬을 때 cur이 1이라면  
(선분의 시작을 의미한다)  
현재 위치를 s에 저장 해놓는다.

-1 해줬을 때 cur이 0이라면  
(선분의 끝을 의미한다)  
현재 위치 - s를 result에 더해준다.

    이 문제는 ios:sync_with_stdio(0); cin.tie(0)을 했을 때와 안 했을 때 제일 차이가 심한 문제였다.
    문제를 풀 때 항상 위 두 코드를 써놔야겠다.

---

### 2174 로봇 시뮬레이션

https://www.acmicpc.net/problem/2174

`사용한 자료구조 & 알고리즘:`

`시간복잡도:` $O(N^2)$

`어떻게 접근했는지, 풀었는지 설명:`

문제 자체가 어려운 것은 아니였음

하지만 테스트 케이스가 1개밖에 없고
실수하기 좋은 포인트가 꽤 있기 때문에 정답률이 낮은 것 같다.

방향을 회전할 때 4번 돈다면 이건 가만히 있는 것과 같다.  
따라서, `dir %= 4`를 통해 최적화할 수 있다.

로봇이 움직일 때의 메소드,  
로봇이 회전할 떄의 메소드,  
명령에 따라서 동작을 지정하는 메소드,  
결과를 출력하는 메소드

이렇게 기능을 구분함으로써 편하게 구현할 수 있었다.

    예전에 이 문제를 풀었을 때는  
    결과를 출력할 때, 문자열을 덧셈을 이용해 출력하려고 했는데
    이떄 정수에 '0'을 더하면, 한자리수는 원하는대로 나오지만,
    두자리수부터는 다른 문자가 나와서 틀렸다.
    출력하는건 문자열 덧셈을 이용하지 말고, 직접 cout를 쓰자

---

### 2239 스도쿠

https://www.acmicpc.net/problem/2239

> 9x9 스도쿠 판 주어졌을 때, 스도쿠를 채워서 출력하는 문제  
> 경우의 수가 여러 개라면, 값이 가장 작은 걸 출력

사용한 알고리즘: 구현 & 백트래킹

시간복잡도: 모르겠음... (재귀라서...)  
worst case는 9^81 예상이지만 실제로는 매우 작음

값이 가장 스도쿠 출력하려면, 앞 칸부터 작은 숫자를 넣어봐서 체크하면 된다.

스도쿠 법칙은 알고있어서 설계하는 건 어렵지 않았다.

문제는
1. 재귀라서 시간복잡도 예측이 제대로 안됐음  
-> 그냥 구현했는데 통과...
2. 재귀함수는 항상 예외(탈출 case)를 생각해야 하는데 놓쳤다...  
그래서 segfault로 2번 틀림

> 재귀함수를 사용한다면 항상 탈출 case를 생각하자.  
> 복붙 하고나서 눈을 부릅뜨고 체크해야 한다.

---

### 2293 동전 1


💡 n가지 종류의 동전이 주어졌을때, 이 동전을 이용해서 합이 k원이 되는 경우의 수를 구하는 문제

(동전은 무제한 이용 가능)



시간복잡도: $O(n)$

dp[0]=1 (0원일때의 경우의 수)

i - 0 ~ n-1 (모든 동전들 탐색)

j - 0 ~ k (0원부터 k원까지 탐색)

if(j ≥ coin[i])

dp[j] += dp[j - coin[i]];

dp[k]가 정답

풀이

1,2,5원을 이용해서 k원까지의 경우의수를 구하는 과정

1 - 1

2 - 11, 2

3 - 111, 12

4 - 1111, 112, 22

5 - 11111, 11122, 122, 5

…

여기서 4원을 보면 1원만 쓴 경우의 수와(1111),

2원에서 2를 더한 경우의 수(112, 22)

5원은 1원만 쓴 경우의 수(11111),

3원에서 2를 더한 경우의 수(11122, 122)에 5를 새로 추가

이를 점화식으로 표현하면

dp[i] = dp[i - coin[1]] + dp[i - coin[2]] + … + dp[i - coin[n]]

결국 dp[0]부터 … dp[k]까지 구하면 정답나옴

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 2294 동전 2


💡 n가지 종류의 동전이 주어졌을때, 이 동전을 이용해서 합이 k원이 될때 사용한 동전의 개수가 최소일때의 동전의 개수를 구하는 문제

(동전은 무제한 이용 가능)



시간복잡도: $O(n^2)$

dp[0]=MAX (못구함)

i - 0 ~ k (0원부터 k원까지 탐색)

j - 0 ~ n-1 (모든 동전들 탐색)

if (coin[j] ≤ i)

dp[i] = min(dp[j], dp[i - coin[j]] + 1);

풀이

1,2,5원이 있을때

3원은 1원3개 or 1원,2원으로 구할수있음

5원은 1원5개,1원1개,2원2개, 1원3개,2원1개, 5원1개로 구할수있음

여기서 5원은 3원+2원 or 4원+1원임

따라서 점화식은

dp[i] = min(dp[i-coin[1]], dp[i-coin[2]], … , dp[i-coin[n]]) + 1이다.

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 2424 부산의 해적

https://www.acmicpc.net/problem/2424

사용한 자료구조 & 알고리즘: 구현, BFS

시간복잡도: $O(n^3)$

어떻게 접근했는지, 풀었는지 설명:

해적이 수아가 이동한 다음에 이동할지 말지를 결정하는데,  
결국 해적이 움직이는 모든 경우의 수를 생각해야 하기 떄문에,  
가만히 있는 경우 + 움직이는 모든 경우를 모두 생각해야 한다.  
-> 그냥 BFS로 한칸씩 모두 움직인다고 생각

아래 과정을  
수아가 보물에 있는 칸에 갈 때까지 or  
수아가 전부 없어질 때까지 반복한다.
1. 수아가 움직인다
2. 해적이 움직인다
3. 해적이 움직인 곳과 같은 행/열에 모두 마킹한다
4. 마크 위에 or 해적 위에 있는 수아들을 모두 없앤다
5. 남은 수아들 중에, 수아가 보물 위에 있는지 확인한다

수아와 해적을 표현하기 위해  
2차원 배열위에도 표시해주고,  
컨테이너로 각 위치를 저장해줬다.

마크/해적 위에 있는 수아들을 없애줄 때,  
컨테이너 중간에 있는 수아를 없앨 수도 있다.  
시간복잡도를 줄이기 위해 리스트 컨테이너를 사용했다. - O(1)

해적과 같은 행/열에 있는 수아를 없애기 위해,  
해적이 있는 행/열에 마킹을 해줘야 했는데,  
이때 다음 칸에 이미 마킹이 되어 있어도 마킹을 진행했다.  
(마킹이 되어 있어도 다음 칸에는 마킹이 안됐을 수 있기 때문에)

---

### 2449 전구

https://www.acmicpc.net/problem/2449

`사용한 자료구조 & 알고리즘:` DP

`시간복잡도:` $O(N^2)$

`어떻게 접근했는지, 풀었는지 설명:`

11066번과 유사한 문제

```int getMin(int st, int ed);``` - st부터 ed까지의 전구의 색을 맞추는데 필요한 최솟값

getMin(0, N-1) = $min_{0<=k<N}(getMin(0,k) + getMin(k+1, N-1) + temp)$
input[0] == input[k+1] 이라면 temp=0;
아니라면 temp=1;

    DP를 이용하기 위한 
    겹치는 부분 문제를 파악하는 것은 쉬웠지만,
    2차원 배열을 이용해 메모이제이션을 진행하는 것이 어려웠던 문제

---

### 2457 공주님의 정원

https://www.acmicpc.net/problem/2457

`사용한 자료구조 & 알고리즘:` 그리디

`시간복잡도:` $O(nlogn)$

`어떻게 접근했는지, 풀었는지 설명:`

먼저 입력 배열을 날짜순으로 정렬한다.

그 다음 시작 날짜가 3/1보다 작고, 종료 날짜가 그보다 높은 꽃을 고른다.

그리고 반복문을 돌리는데,  
여기서, 현재 위치 i에서 항상 최적해를 골라야 한다.

최적해를 고르는 기준:  
현재 꽃의 시작 날짜보다 높은 꽃 중에, 종료 날짜가 가장 큰 꽃을 고른다.

여기서 구현해야 할 예외 사항들이 많이 있다.
1. 시작 날짜가 가장 낮은 꽃의 날짜가 3/1 보다 클 때
2. 종료 날짜가 3/1 보다 큰 꽃이 없을 때
3. 현재 꽃의 종료 날짜와 비교했을 떄, 시작 날짜가 작은 꽃이 없을 떄


    여기서 하나 놓친 반례가 있었다.  
    시작 날짜가 가장 낮은 꽃의 날짜가 3/1 보다 클 때
    를 생각하지 못했다.

    항상 반례를 생각하자

---

### 2493 탑

https://www.acmicpc.net/problem/2493

`사용한 자료구조 & 알고리즘:` 스택

`시간복잡도:` $O(N)$

`어떻게 접근했는지, 풀었는지 설명:`

전형적인 스택을 이용하는 문제

모든 원소를 한번만 탐색한다.

이때 이전 정보를 저장할 스택 s를 이용한다.

1. s가 not empty, s.back() < cur -> 이 조건을 만족하지 않을 때까지 pop 해준다.
2. if s is empty, cout << "0 "; 
   s is not empty, cout << s.back() 의 위치
3. s.push(cur)

위 과정은 아래의 원리를 이용했다.  
`스택에 있는 탑들 중에, 현재 탑보다 낮은 탑들은 이후에 쓰이지 않는다`

> 위 방식으로 풀면, 매 원소를 탐색할 때마다  
> 스택은 항상 내림차순으로 정렬되어 있다.

---

### 2504 괄호의 값

https://www.acmicpc.net/problem/2504

> (, ), [, ] 로만 이루어진 문자열이 주어졌을 때, 해당 문자열의 점수를 구하는 문제  
() = 2, [] = 3, (x) = 2x, \[y] = 3y  
> 올바르지 않은 괄호는 0 - ([)], ()( 등

사용한 알고리즘: 문자열, 재귀

시간복잡도: 거의 $O(n^2)$ 이지만, 구현 문제라 인풋이 작음

올바르지 않은 괄호를 찾아내는 것이 귀찮은 문제였다.  

올바르지 않은 괄호의 특징 
- (, [의 개수와 ), ]의 개수가 다르다 - 짝이 안맞는다
- 순서가 겹친다 - [ ( ] ), ) (

그리고 점수를 계산할 때 재귀 함수를 이용했다.  

```cpp
int countResult(int s,int e) {...} // [s, e) 에 해당하는 점수를 반환하는 함수
// 1. 첫번째 괄호를 찾는다
// 2. 첫번째 괄호와 맞는 괄호를 찾는다.
// 3. 점수 계산
// 3-1. 두번째 괄호가 끝에 있다면,  그 안의 재귀를 호출하면서 반환
// 3-2. 끝이 아니라면, 찾은 괄호의 점수(재귀 호출)와 그 다음 위치의 점수(재귀 호출)를 더해서 반환
```

문제를 풀면서, 설계와 구현을 같이 하다보니 시간이 지체됐다.  
수도코드로 완전히 설계를 한 뒤, 구현을 하는 것이 훨씬 효율적으로 풀 수 있다 생각했음.

> 추가 설명

이 문제는 괄호의 위치를 활용한 스택을 이용하면 깔끔하게 풀 수 있다.

`vector<pair<bool, int>> s` - {괄호의 종류, 괄호의 위치}  
`vector<pair<int, int>> score` - {점수, 괄호의 첫번째 위치}

1. '(', '[' 일 때는 s에 push  
2. ')', ']' 일 때는 s.back()과 비교  
   s.back()에 있는 괄호의 종류와 다르다면 그대로 종료  
   같다면, s.back()의 괄호의 위치를 이용해 점수를 계산한다.  
   score.back().second < s.back().second 인 것들을 더하여 계산한다.  
   그리고 현재 점수를 다시 score에 push
   

---

### 2513 통학버스

https://www.acmicpc.net/problem/2513

`사용한 자료구조 & 알고리즘:` 그리디, 정렬

`시간복잡도:` $O(N)$

`어떻게 접근했는지, 풀었는지 설명:`

여기서 적용되는 최적해:
1. 방향이 반대인 두 곳은 따로 처리한다.
   (같이 태우는 것은 최적의 경우가 아니다)
2. 가장 먼 곳의 사람부터 태운다

> 최적해를 구하려면,  
> 최대한 적게 통학시키고, 최대한 가깝게 처리해야 한다.
> 
> 그런데 가까운 학생들부터 처리하면, 경우의 수가 많아진다.  
> -> 가까운 학생을 멀게 처리할 수도 있다.
> 
> 먼 곳부터 처리하면 경우의 수가 하나로 줄어든다.  
> -> 모든 학생을 최대한 가깝게 처리할 수 있다.

1. 학교의 위치를 기준으로,  
   왼쪽, 오른쪽 아파트들을 따로 컨테이너에 저장한다.  
   -> 두개의 벡터 생성
2. 왼쪽 아파트는 내림차순, 오른쪽 아파트는 오름차순으로 정렬한다.
3. 둘다 먼 곳부터, 즉 역방향으로 탐색한다.  
   현재 위치의 학생 수 s와 버스의 최대 인원 k을 비교한다.  
   s > k, 현재 위치의 모든 학생을 태울 수 없다. -> 일단 버스의 최대 인원만큼 태우고 다시 진행  
   s < k, 현재 위치의 모든 학생을 태울 수 있다. -> 버스에 태우고, 다음 위치로 이동  
   s = k, 현재 위치의 모든 학생을 태울 수 있다. -> 버스에 태우고 다 처리한다.

내가 놓친점
1. 빈 컨테이너를 접근하는 것
2. 컨테이너의 원소에 현재 버스에 탄 사람 수만큼 빼줘야 하는데, 버스의 최대 인원을 빼준 것
3. 마지막으로 남은 인원을 태웠을 때, 인원이 있을 때 추가 로직을 헷갈림  
   (버스에 학생이 남았을 때 거리를 계산해줘야 하는데, 거리가 0일때 계산을 하는 실수를 했다)

---

### 2533 사회망 서비스

https://www.acmicpc.net/problem/2533

`사용한 자료구조 & 알고리즘:` DP, 트리

`시간복잡도:` $O(n)$

`어떻게 접근했는지, 풀었는지 설명:`

처음에는 짝수레벨의 노드 개수, 홀수레벨의 노드 개수 의 최솟값이 정답인 줄 알았다.

그런데 이 문제는 DP로 풀어야 한다.

> DP로 풀어야 하는 이유  
> 자식 노드 i는 부모의 상태와 관계없이,  
> 얼리어답터 일때, 아닐때의 최솟값이 정해져 있기 때문이다.
> 
> -> DP를 적용하지 않으면, 부모 노드의 상태 별로 모든 경우의 수를 탐색해야 한다.
> 
> 겹치는 부분 문제  
> -> 부모 노드의 상태를 정하고 이에 대한 자식 노드의 상태를 정하는 것

일단 현재 노드가 얼리어답터일 때의 최솟값, 아닐 때의 최솟값을 구해야 한다.

`dp[2][100001]`  
0: 현재 노드가 얼리어답터가 아닐 때의 최솟값  
1: 현재 노드가 얼리어답터일 때의 최솟값

`findMin(int cur, int parent, int state)`  
현재 노드가 cur이고, 부모가 parent이고, 상태가 state일 때의 최솟값을 반환하는 함수  
(state - 현재 노드의 상태)

이때 자식 노드가 있는지 없는지 판단하기 위해,  
edge 수를 이용했다.  
(edge == 1 -> 자식 노드가 없음, edge > 1 -> 자식 노드가 있음)  
(edge가 1 이라는 건 부모 노드와의 연결만 있다는 뜻)

그리고 첫 노드(루트)를 정하기 위해  
모든 노드를 탐색해서, edge > 1 인 노드를 찾아서 시작했다.

> 이때 노드 개수가 2라면, 그냥 바로 1을 반환했다.

문제 풀이 순서  
1. dp -1 초기화
2. edge 수를 이용해 루트 노드 찾기
3. 루트 노드를 기준으로 dp를 구하기 시작 - findMin(root, 0, 1)
4. dp[0][root]과 dp[1][root] 중 최솟값을 반환

findMin 처리 과정
1. state가 0일 때는, 현재 노드의 state는 무조건 1이다.  
   -> dp[1][cur] = sum{child}(findMin(child, cur, 1)) + 1;  
   (자식 노드들의 최솟값을 모두 더하고 1을 더해 저장)
2. state가 1일 때는, 현재 노드의 state가 0일 수도, 1일 수도 있다.  
   -> 각 dp를 구한뒤에, return min(dp[0][cur], dp[1][cur]);


    나는 부모 노드를 구분하기 위해 parent를 사용했는데,
    visited를 사용하면 더 편리하게 구현할 수 있었을 것 같다.

    그리고 부모 노드의 상태를 받기 위해 state 파라미터를 활용했는데,  
    이걸 신경쓰지 않고 그냥 dp를 구할 수 있기 때문에,  
    state를 사용하지 않아도 될 것 같다.
    (만약 state를 사용하지 않는다면, child의 결과를 가지고 dp를 구해야 한다)

> 추가 설명  
> 
> 1. 위에서는 자식 노드가 있는지 없는지를 따로 코드로 구현했지만,  
>    이를 따로 구현할 필요는 없다.  
>    부모 노드를 제외한 노드만 탐색하면 되기 때문  
>    (리프 노드는 노드를 아예 탐색하지 않게 된다)
> 2. 꼭 루트 노드를 찾아서 시작할 필요는 없다.  
>    (어차피 모든 노드를 탐색하기 때문에)
> 

---

### 2565 전깃줄


💡 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 구하는 문제



시간복잡도: $O(n^2)$

v[i] - {i번째 전깃줄 번호, 가리키는 전깃줄 번호}

sort(v, v.first순으로)

v.second로 LIS구하면 끝

풀이

v를 정렬후에 각각의 전깃줄이 가리키는 번호가

{8,2,9,1,4,6,7,10}일때 없애야 하는 전깃줄은

1,3,4이다.(1,2,3도 가능) 1,3,4를 없애면

{8,**2**,9,1,**4**,**6**,**7**,**10**} - 2,4,6,7,10이다.

이는 LIS를 구하는 문제랑 같음

그냥 LIS 실생활 응용문제였음

[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 2602 돌다리 건너기

https://www.acmicpc.net/problem/2602

> 두줄의 돌다리가 주어지고, input이 주어졌을떄 돌다리를 input 순서대로 건널수있는 경우의 수를 구하는 문제
>
> 1. 한번 밟고 반대쪽의 돌다리를 밟아야 한다.
> 2. 밟을때마다 무조건 다음칸으로 이동해야 한다.(같은줄밟기 안됨)

사용한 알고리즘: DP

시간복잡도: $O(n)$

// c={0,1}, cnt={0~input길이}, n={0~돌다리길이}
find(c, cnt, n) = 현재 위치에서 돌다리를 건널수 있는 경우의 수를 반환

현재 위치에서 cnt번째 input과 n번째 돌다리의 문자가 같다면<br>
find((c+1)%2, cnt+1, n+1) + find(c, cnt, n+1) 반환

다르다면<br>
find(c, cnt, n+1) 반환

    같을때는 다음 돌다리를 구하는 경우의 수를 구해야하고, 현재 돌다리에서 다음 위치의 돌다리도 체크해야함

    다를때는 다음 위치의 돌다리만 체크하면됨

항상 결과 범위(int, long long), 범위 벗어나는지 체크하자

    이상한 값나오면 그건 잘못된 접근을 한것 - 범위 생각, 알고리즘은 관련없을 확률 높음

---

### 2608 로마 숫자

https://www.acmicpc.net/problem/2608

`사용한 자료구조 & 알고리즘:` 구현

`시간복잡도:` $O()$

`어떻게 접근했는지, 풀었는지 설명:`

두개의 로마 숫자를 입력으로 받아,
두 수를 더한 결과를 숫자와 로마 숫자로 출력하는 문제

일단 로마 숫자들을 하드 코딩으로 구현했다.  
(I, II, ..., X, XX, ..., C, CC, ..., M, MM, MMM)

그리고 로마 숫자를 숫자로 변환하는 함수를 구현했다.  
1. 앞글자부터 1 ~ 4 글자씩 비교해서 숫자로 변환  
   (가능한 숫자들 중에 글자의 길이가 가장 긴 것을 선택)
2. 다음 인덱스로 이동해서 1번을 반복

숫자를 더해준 뒤, 숫자를 로마 숫자로 변환하는 함수를 구현했다.  
천의 자리부터 일의 자리까지 1 ~ 9까지의 숫자를 로마 숫자로 변환  
((target / i) * i) (i = 1000, 100, 10, 1))

      로마 숫자를 직접 구현하는 것이 더 효율적이었다.
      이렇게 경우의 수가 적은 경우에는 하드 코딩을 사용하는 것이 더 효율적이다.


---

### 2610 회의준비 

https://www.acmicpc.net/problem/2610

`사용한 자료구조 & 알고리즘:` 플로이드-워셜, BFS

`시간복잡도:` $O(n^3)$

`어떻게 접근했는지, 풀었는지 설명:` 

맨 처음에는 input을 받으면서, 그래프를 만든다.

그리고 플로이드-워셜을 통해 모든 정점에서 모든 정점으로의 최단거리를 구한다.

그리고 BFS를 통해, 각 정점에서 다른 정점으로의 최단거리를 구한다.

이때, BFS를 통해 구한 최단거리를 통해,  
각 정점에서 다른 정점으로의 최단거리를 구한다.

다른 정점으로의 최단거리 중 가장 큰 값을 구하고,  
해당 값이 가장 작은 값의 인덱스가 정답이 된다.

     나는 맨처음에 최댓값이 최소가 된다는 것을 생각하지 못했다.
     처음에는 그냥 최단거리의 합이 최소가 되는 것을 구하려고 했다.
     

---

### 2613 숫자구슬

https://www.acmicpc.net/problem/2613

`사용한 자료구조 & 알고리즘:` DP

`시간복잡도:` $O(N^2*M)$

`어떻게 접근했는지, 풀었는지 설명:`

처음에는 브루트포스로 접근

```int divide(int m, int loc)```  
: loc와 loc-1 사이에서 m번째로 나눴을 때, 이 상황에서 나올 수 있는 최댓값의 최솟값

시간복잡도는 O(n!) - 시간 초과  
메모이제이션을 통한 최적화를 해야 한다.

dp[m][loc]로 최적화하려면 앞부분과 관계없는 값을 저장할 수 있어야 한다.

따라서 메서드를 살짝 변형한다.

```int divide(int m, int loc)```  
: loc와 loc-1 사이에서 m번째로 나눴을 때, **loc 뒷부분의** 최댓값의 최솟값

시간복잡도 - O(NM * N)

---

### 2616 소형기관차

https://www.acmicpc.net/problem/2616

> n개의 승객 정보와 소형기관차의 길이 m이 주어졌을때, 3개의 소형기관차에 승객을 연속해서 나눠 실을때 최대로 실을 수 있는 경우의 수를 구하는 문제

사용한 알고리즘: DP

시간복잡도: $O(n)$

처음에는 완탐으로 접근

그냥 3중for문으로 모든 조합에서 가장 최대값을 반환하도록 세팅<br>
시간복잡도 $O(_nC_3) => O(n^3)$이라 안됨

이를 dp로 변환하려 했지만, 못했음, 어디서 상태가 겹치는지 체크가 안됐음

그래서 정답을 봤다

find(x,cnt) = max(현재 기관차에 승객을 안 실었을때, 현재 기관차에 승객을 실었을때)<br>
find(x,cnt) = max(find(x+1,cnt), find(x+c, cnt+1)+ 승객 총합)

이 점화식은 해당 기관차를 쓰냐 안쓰냐, 둘 중하나에서 max 값을 찾는 식

사실 내식도 이 점화식과 비슷하다.

> 내식<br>
> find(x,cnt) = $max^n_{L=1}(find(x+c,cnt+1)+승객 총합)$
>
> 찾아본 점화식<br>
> find(x,cnt) = max(find(x+1,cnt), find(x+c, cnt+1)+ 승객 총합)

> 여기서 dp[cnt][x]가 의미하는 것
>
> cnt번 이후의 기관차부터 x번호 이상의 승객을 담을 수 있는 경우의 수 중 최댓값<br>
>> (여기서 이전 기관차와 지금 기관차는 관련이 없다)<br>
>> 1번 기관차가 1,2번 승객을 실든, 2,3번 승객을 실든<br>
>> 2번 기관차가 4번 위치에서 구할 수 있는 최댓값은 1번과 관련이 없다.<br>
>> (대신 1번보다 빠른 번호의 승객을 담을 순 없다)<br>
>> (기관차끼리는 순서가 의미가 없기 때문에 문제는 안됨)
>
>
> dp를 적용해서 $n^3$을 $3n$으로 줄임

> 그럼 원래 내가 썼던 식에서 dp를 적용할 수 있을까?
>
> for문 안에서 일일이 int& ret으로 dp를 설정가능하다.
> 근데 이건 좀 귀찮음..

---

### 2629 양팔저울

https://www.acmicpc.net/problem/2629

> n개의 추의 무게가 주어지고, m개의 구슬의 무게가 주어졌을때, 양팔저울과 n개의 추를 이용해 구슬들의 무게를 감별할 수 있는지 출력하는 프로그램을 작성하라

사용한 알고리즘: DP

시간복잡도: $O(n * sum)$ // 추들의 무게의 합 => 최대 30 * 15000

완탐으로 접근 시작

find(int cur, int num, int l, int r) = cur번째 구슬을 num번째 추까지 이용했을때 감별할 수 있는지 체크하는 함수

이때의 시간복잡도 = $O(3^n)$
> num번째 추를 왼쪽에 놓을지, 오른쪽에 놓을지, 안놓을지 3가지의 선택지가 생김

이제 cache를 이용해서 dp를 적용해야 하는데, 제대로 접근 못함 그래서 답 확인했음

cache[num][w] = num번째 추까지 이용했을때 w 무게의 구슬을 구별할 수 있는지 체크하는 변수

    일단 처음에는 cur번째 구슬을 이용해서 cache를 만들었는데 이럴 필요가 없음
    결국 추를 이용했을때 잴 수 있는 무게들은 정해져 있음 -> 구슬과는 관련이 없다.
    find(cur, num, l, r) -> find(num, l, r)
>
    find에서는 l과 r을 사용해서, 
    find(num+1, l+구슬무게, r)
    find(num+1, l, r+구슬무게)
    find(num+1, l, r)
    양쪽을 체크했지만, 이럴 필요가 없다.    

    find(num+1, w+구슬무게)
    find(num+1, abs(w-구슬무게))
    find(num+1, w)
    왼쪽에 놓으면 +, 오른쪽에 놓으면 -> 왼쪽에 - 해주면됨 & 절댓값, 그리고 안놓았을때
    이렇게 하면 간단해짐

---

### 2579 계단 오르기


💡 계단에 해당하는 점수가 주어졌을때 3번연속 밟지않고, 마지막 계단을 밟았을때의 최댓값 구하는 문제



시간복잡도: O(n)

방법1

1번 연속으로 밟았을때의

dp[i] = max(dp[1][i-2],dp[2][i-2])+x[i];

2번 연속으로 밟았을때의

dp[i] = dp[i-1]+x[i];

답: max(dp[1][n],dp[2][n])

방법2

dp - 현재 위치에서 계단 밟았을때의 최댓값

dp[i] = max(dp[i-2]+x[i], dp[i-3]+x[i-1]+x[i]);

답: dp[n]


💡 dp[i-1]을 사용하지 않고 x[i-1]을 사용하니까 3번연속금지에 위배되지않음



[](https://www.notion.so/c6a513154d0b4066bdee4bf721bb2a80?pvs=21)

---

### 2618 경찰차

https://www.acmicpc.net/problem/2618

`사용한 자료구조 & 알고리즘:` DP

`시간복잡도:` $O(W^2)$

어떻게 접근했는지, 풀었는지 설명:

처음에는 (좌표를 받았으니) 2차원 배열로 풀려고 했다.  
하지만 경우의 수가 너무 많아 이를 일반화할 공식이 없다 판단해서 포기

결국 경찰차 2대 중에 어떤 경찰차가 맞냐를 고르는 문제  
브루트포스 접근(사건 W개마다 경찰차 1 또는 2 가 맞는다) - O(2^1000)  
이런 문제는 전형적인 DP 문제인 것 같다.

`int dp(int n, pair<int,int> n1, pair<int,int> n2)`  
n번째 사건을 맡을 때, 1번 경찰차 위치가 n1이고, 2번 경찰차 위치가 n2일 떄  
그 이후의 사건들에 대한 최솟값을 반환하는 함수

여기서 좌표는 결국 사건들의 번호에 종속되기 떄문에 pair 대신 그냥 int를 써도 된다.  
(몇번째 사건을 맡았는지)

`int dp(int n, int n1, int n2)`  
n번쨰 사건을 맡을 때, 1번 경찰차가 최근에 n1번 사건을 맡았었고, 2번 경찰차가 최근에 n2번 사건을 맡았을 때,  
그 이후의 사건들에 대한 최솟값을 반환하는 함수

여기서 나올 수 있는 경우의 수 = n * W * W  
-> 너무 크다.

여기서 한번 더 최적화 할 수 있는데,  
그건 바로 **'n1 또는 n2 중 큰 값 + 1 이 이번에 맡을 사건'**이다.  
(n1 = 1, n2 = 2 이면 지금 맡을 사건의 번호는 3)

`int dp(int n1, int n2)`  
1번 경찰차가 최근에 n1번 사건을 맡았었고, 2번 경찰차가 최근에 n2번 사건을 맡았을 때,  
그 이후의 사건들에 대한 최솟값을 반환하는 함수
(여기서 (n1 > n2)?n1:n2 + 1 이 현재 맡아야 할 사건이다)

여기서 나올 수 있는 경우의 수 = W * W
-> 가능하다.

    처음 2차원 배열로 접근하려다가 시간을 30분 까먹었다.  
    그리고 (n1 > n2)?n1:n2 + 1 이 현재 맡는 사건이라는 아이디어를 떠올리지 못했다.

---

### 2636 치즈

https://www.acmicpc.net/problem/2636

> 문제 설명

사용한 알고리즘: bfs

시간복잡도: $O(n^3)$

이전에 이런 문제를 푼적이 있었다.<br>
https://www.acmicpc.net/problem/2638<br>
똑같은 문제였네

그냥 bfs를 이용하는 구현 문제,

여기서 치즈 안에 있는 구멍이랑, 치즈 밖에 있는 구멍을 구분해야 함

여기서 치즈를 보지말고, 가장자리에 붙어 있는 구멍을 보면됨

가장자리에 붙어 있는 치즈는 녹을 치즈

0,0에서 bfs돌리면 끝

그리고 치즈가 남았는지 체크할때 일일이 탐색하지 말고, 이전 bfs 과정중에 치즈 개수를 세주면됨

이전 치즈 개수 - 현재 제거되는 치즈 개수 => 이 값이 0이되면 break

---

### 2812 크게 만들기

https://www.acmicpc.net/problem/2812

사용한 자료구조 & 알고리즘: 그리디

시간복잡도: $O(N + K)$

어떻게 접근했는지, 풀었는지 설명:

큰 숫자를 만드는 방법  
-> 가능하면 항상 앞자리가 제일 큰 수여야 한다.  
-> K개 이하의 앞자리 숫자들을 비교해서 가장 큰 숫자가 맨 앞자리 숫자가 된다.  
-> 그 다음 자리수를 K-i개(삭제할 숫자개수 i개)를 이용해 가장 큰 숫자를 탐색  
(K == 0 이 될때까지 반복)

처음엔 이 아이디어를 브루트포스로 접근했다. - $O(N^K)$  
N,K <= 500000 이라 무조건 시간 초과  
숫자는 정렬이 안되어 있으므로 이분탐색도 불가능  
결국 현재 숫자 한개씩 탐색하면서 O(1) 안에 큰 숫자를 탐색해야 한다.

여기서 떠올린 아이디어  
어차피 현재 위치의 숫자가 이전 위치 숫자보다 크다면 & K > 0  
-> 무조건 이전 위치 숫자를 지워야 한다.  
(여기서 이전 숫자가 현재 숫자보다 클 때까지 계속 비교해야 한다)  
그리고 결국 지울 숫자는 K개  
-> N번의 탐색 & K번만 추가로 삭제하면 큰 숫자를 구할 수 있다.  
-> O(n+k)

이 아이디어를 list를 이용해 접근했다.  
(중간 위치의 데이터를 삭제하는 시간복잡도가 O(1)이라 이용)  
1 - 이전 위치의 숫자와 현재 위치의 숫자를 비교  
1-1 - 이전 숫자가 크다면 다음 위치 탐색  
1-2 - 현재 숫자가 크다면 for문으로 계속 이전 숫자가 현재 숫자보다 커질 때까지 이전숫자를 지우면서 탐색  
2 - 만약 전체 탐색 이후에 K > 0 이라면, 맨끝의 숫자를 K개 삭제한다.  
(1번을 이용해 전체 탐색을 했는데 K > 0 == 모든 숫자가 내림차순으로 정렬되어 있다)

-> 통과

하지만 이 코드의 총 메모리 사용량은 18MB나 나왔다.  
그 이유는 list는 하나의 노드에  
현재 위치의 데이터 & 다음 위치 포인터 & 이전 위치 포인터를 모두 저장하기 떄문에  
메모리 사용량이 높게 나온 것 같다.

이 코드는 처음에 모든 숫자를 list에 넣고, 하나씩 비교해서 삭제하는 방식이다.

여기서 간단한 아이디어를 추가로 접목  
-> 항상 이전 숫자가 현재 숫자보다 클 때, 현재 위치에 대한 탐색이 종료되므로  
0 - size가 1인 vector로 시작(첫번째 숫자 저장)  
1 - 현재 숫자와 vector의 마지막 숫자를 비교  
1-1 - 현재 숫자가 크다면, 이전 숫자가 현재보다 커질때까지 계속 pop_back & K--
그리고 현재 숫자 push_back
1-2 - 현재 숫자가 작다면, 현재 숫자 push_back  
2 - 모든 탐색을 마쳤는데, K > 0 -> K개만큼 끝의 숫자들을 제거

위 아이디어를 적용함으로써, 메모리사용량이 1/6로 줄었다.

> 시간이 지체된 이유
> 
> 1. list, 특히 iterator를 이용한 컨테이너 탐색이 많이 어색했음  
>   (이건 연습으로 극복해야 할듯)
> 2. 전체 탐색을 마쳤는데 K > 0 인 케이스를 생각 못했다.

---

### 2879 코딩은 예쁘게

https://www.acmicpc.net/problem/2879

`사용한 자료구조 & 알고리즘:` 그리디

`시간복잡도:` $O(N)$

`어떻게 접근했는지, 풀었는지 설명:`

여기서 적용되는 최적해:  
'부호가 같으면 최대한 많이 묶어서 처리하는 것'

여기서 헷갈릴 만한 점  
ex)  
5 1 5  
0 0 0  
이런 형식으로 있으면  
이떄는 답이 5가 아니라, 4 + 4 + 1 = 9가 된다.  
-> 부호가 같아도 따로 처리되는 부분이 있다.  
(1만 3개 전부 처리되고, 양쪽으로 4씩 따로 처리된다)

위 케이스를 처리하는 방법  
현재 원소 v[i]와 이전 원소 v[i-1]을 비교
1. 부호가 같은데 v[i-1] < v[i], continue  
   (v[i-1]와 v[i]를 같이 처리할 수 있다고 생각)
2. 부호가 같은데 v[i-1] > v[i], result += v[i-1] - v[i]  
   (v[i-1]와 v[i]의 일부만 같이 처리할 수 있다)
3. 부호가 다르다면, result += v[i-1]  
   (v[i-1]와 v[i]를 따로 처리해 줘야 한다)

> 1번에서 그냥 continue 하는 이유는  
> v[i-1]만큼 같이 처리하고 남은 부분 v[i] - v[i-1]을 처리하는데  
> 이는 v[i] 하나를 처리하는 것과 같다.  
> 따라서 아무것도 할 필요가 없다.

        나는 처음에 어떻게든 같이 처리하려고 했다.
        (부호가 달라도)

        그런데 같이 처리해도, 따로 처리한 것과 같은 결과가 나와서
        굳이 같이 처리하도록 만들 필요가 없었다.

        5 1 5
        3 3 3
        에서 1->5, 5->3 을 하면 4+2=6
        3개다 따로 처리하면 2+2+2=6
        (같은 결과)

        결국 이 문제의 핵심은
        같이 처리할 때, 부분적으로 따로 처리해주는 것을 생각하는 것이다.

---

### 2887 행성 터널

https://www.acmicpc.net/problem/2887

`사용한 자료구조 & 알고리즘:` MST, 정렬

`시간복잡도:` $O(ElogV)$

`어떻게 접근했는지, 풀었는지 설명:`

간선 N-1개를 이용해 모든 정점을 연결해야 한다.  
-> MST 문제

프림 알고리즘의 시간복잡도는 $O(ElogV)$  
크루스칼 알고리즘의 시간복잡도는 $O(ElogE)$  

여기서 문제는 모든 정점들이 연결되어 있기 때문에  
(모든 정점을 연결한 걸 가정하고 풀면) TLE가 발생할 수 밖에 없다.  
(이 케이스에서 간선의 개수 = N(N-1)/2)

여기서 이 문제만의 특징이 있다.  
두 정점을 연결하는 간선의 비용은 min(|x1-x2|, |y1-y2|, |z1-z2|) 이다.

정점은 3개의 좌표를 이용해 표현되지만,  
간선은 1개의 좌표만을 이용한다.

> 1차원 좌표 위에 있는 정점들의 MST를 구하는 방법은  
> 1. 정점을 정렬한다.
> 2. 인접한 정점들을 연결한다.
> 
> -> 그냥 좌표 오름차순 순서대로 연결하면 MST가 구해진다.

이를 이용해 간선의 개수를 줄일 수 있다.  

1. 각 좌표들을 정렬한다.
2. 각 좌표들을 이용해 간선을 만든다.  
   (1차원이기 때문에 이전 원소와 다음 원소만을 이용한다)
3. 만든 간선들을 이용해 MST를 구한다.

간선들의 최대 개수는 3*N 이다.  
이를 이용해 프림 or 크루스칼 알고리즘을 이용하면 된다.

      이걸 프림 알고리즘으로 풀었지만,
      크루스칼 알고리즘이 더 최적인 것 같다.

      정렬한 배열을 이용해서 간선들을 구한 다음,
      그 간선들을 바로 우선순위 큐에 넣어서 풀면 더 효율적일 것 같다.

> 여기서 얻은 팁들
> 
> 컨테이너를 탐색할 때  
> `for(auto e : container)` 로 하면 비효율적이다.  
> (복사 생성자를 호출하기 때문)  
> -> `for(const auto& e : container)` 로 하면 더 효율적이다.
> 
> 그리고 간선을 생성할 때,  
> 두 정점을 키(pair<int,int>)로 하는 map을 이용했는데,  
> 이때 두 정점을 정렬해서 넣어야 더 효율적이다.  
> (굳이 양쪽 모두 체크할 필요 없어짐)  
> (한쪽을 제한하면 경우의 수가 줄어든다)

---

### 2983 개구리 공주

https://www.acmicpc.net/problem/2983

사용한 자료구조 & 알고리즘: 트리

시간복잡도: $O(n*logn)$

어떻게 접근했는지, 풀었는지 설명:

처음에는 브루트포스로 접근
1. 2차원 배열에 식물을 표시해서, 일일이 찾는다 - 좌표 범위가 10억이라 무조건 시간 초과
2. 식물 N개를 일일이 탐색 - n^2 - n이 10만이라 시간 초과

-> 트리/해시 를 이용해서 시간복잡도를 줄여야 한다.

AD를 적용할 수 있는 기준 - y-x 값이 같아야 한다.  
BC를 적용할 수 있는 기준 - y+x 값이 같아야 한다.

{x-y, x, y}, {x+y, x, y} 에 대한 set을 생성 = AD, BC set

inst가 A or D - AD.find(현재 위치)  
inst가 B or C - BC.find(현재 위치)

이때 inst가 A or B라면 현재 위치보다 x 값이 커야 한다.  
그리고 inst가 C or D라면 현재 위치보다 x 값이 작아야 한다.

->  
A or B - set에서 현재 위치의 다음 위치를 찾는다.  
C or D - set에서 현재 위치의 이전 위치를 찾는다.  
(없다면 그냥 다음 inst로)

> set에 {y-x, x, y} 를 넣는건 생각했는데  
> BC는 {x+y, x, y}를 넣어야 한다는 것을 생각 못했다.
> 
> 그냥 {y-x,x,y}로 4개 다 해결하려고 했다.  
> (BC는 이 set으로 풀 수 없다)

---

### 3015 오아시스 재결합

https://www.acmicpc.net/problem/3015

`사용한 자료구조 & 알고리즘: 스택`

`시간복잡도:` $O(n)$

어떻게 접근했는지, 풀었는지 설명:

이 문제의 핵심  
`i번째 사람은 앞 사람들이 내림차순으로 보인다.`  
(i의 키 = 2, 앞 사람들 키 - 4 2 1 2 -> i번째 사람은 4 2 2 로 보인다)

벡터에 앞 사람들을 키 내림차순으로 저장한다.  
(벡터에 {키, 앞 사람들 중 키가 같은 사람들 수 + 바로 앞의 큰 사람 1명} 을 저장)  
(4 2 2 이면 {4,0} {2,1} {2,2}로 저장)

i번째 사람 키가 m이면,  
앞 사람들 배열에 뒷부분부터, 자신보다 키가 작은 사람들을 모두 제거한다.  
그리고 {자기 자신의 키, 앞 사람들 중 키가 같은 사람들 수 + 바로 앞의 큰 사람 1명}를 추가한다.  
이때 앞 사람들 배열에 있는 사람들 중,키가 자기 자신보다 큰 사람 이후의 사람들의 수를 result에 더한다  
(4 3 3 1 인데 m=2 ->  result += 2(3 1))  
(4 3 3 1 인데 m=3 -> result += 4(4 3 3 1))

> 벡터에 굳이 d = {앞 사람들 중 키가 같은 사람들 수 + 바로 앞의 큰 사람 1명}를 저장한 이유
> 
> (키가 같은 사람들 + 바로 앞의 큰 사람)을 한번에 더하기 위해  
> 
> 키가 같으면 벡터에서 뺄 수 없다.  
> 하지만 키가 같은 사람들 + 바로 앞의 큰 사람을 모두 count 해줘야 한다.  
> -> v.back()이 키가 같은 사람이 이라면 result += d;
> 
> 만약 키가 같은 사람들을 직접 count 해준다면 시간초과가 날 수 있다.  
> (n = 50만, 모든 사람들의 키가 같다 - O(n^2))

{앞 사람들 중 키가 같은 사람들 수 + 바로 앞의 큰 사람 1명}을 저장할 때  
바로 앞의 큰사람이 없다면, 당연히 키가 같은 사람들의 수만 저장해야 한다.

시간복잡도는 O(n)이 나왔다.
(앞 사람들의 정보를 담은 벡터에 erase 작업은 평균 O(1)이 걸린다)  
(n번의 탐색 동안 결국 최대 n명 제거할 수 있기 때문)

    위와 같은 접근을 할 수 있었던 이유
    
    문제의 규칙을 가지고 예제들을 풀면서  
    내가 어떻게 접근하고 있는지 계속 의식을 했다.  
    (그래서 앞 사람들이 내림차순으로 보인다는 아이디어를 얻었음)

---

### 3025 돌 던지기

https://www.acmicpc.net/problem/3025

`사용한 자료구조 & 알고리즘:` 구현, 트리, DP

`시간복잡도:` $O(NClogR)$

`어떻게 접근했는지, 풀었는지 설명:`

문제 자체는 간단하다.  
하지만 인풋의 범위가 너무 커서  
브루트포스로 풀면 시간복잡도가 O(NR)이라 시간초과가 발생한다.  
(N = 100000, R = 30000)

그래서 현재 돌을 던질 수 있는 위치를 찾을 떄 트리를 이용한다.  
(c++에서는 set을 이용)

트리를 이용했을 때 시간복잡도는 O(NClogR) 인 줄 알았으나,  
(모든 열을 탐색했을 때의 worst case)
반례가 있었다.

..
..
X.
..
..
.X
..
..
X.
(생략)

여기서 1열에 계속 돌을 던지면  
돌은 1열과 2열을 왔다갔다 한다.
이렇게 되면 열에서 다음 위치를 구할 때 logR이 소요되는데,  
3칸씩 진행되기 때문에  
시간복잡도는 logR * R/3 = O(RlogR)이 된다.

위 접근의 전체 시간복잡도는 O(NRlogR)로 오히려 더 늘어났다.  
그래서 TLE가 났다.  
(Time Limit Exceeded: 시간 초과)

따라서 아이디어를 하나 적용해야 한다.  
돌을 던지기 전, 이미 이전 단계에서 똑같은 위치에 돌을 던졌다면  
이전의 값을 저장하고, 다음 단계에서는 저장된 값을 이용하면  
시간복잡도를 줄일 수 있다.

여기서 또 체크해줘야 하는 것이 있는데,  
만약 이전에 저장한 체크포인트에 돌이 있다면,  
체크포인트를 지워줘야 하는데,  
이 단계는 돌을 던지기 전에 체크해줘야 한다.

> 나는 돌을 놓을 때 체크포인트를 지워줘 WA가 났다.  
> (Wrong Answer: 틀렸습니다)  
> (다른 열에서 돌을 던져서, 나중에 2개 이상의 체크포인트를 지워야 할 수도 있다)

    이 문제에서 두 가지 반례를 놓쳤다.
    돌이 열을 왔다갔다 해 시간초과가 날 수 있다는 점(1)
    다른 열에서 돌을 던져서, 2개 이상의 체크포인트를 지워야 할 수도 있다는 점(2)

    항상 반례를 생각하자
    (근데 이런 반례를 나중에 생각할 수 있을까?)

---

### 3101 토끼의 이동

https://www.acmicpc.net/problem/3101

`사용한 자료구조 & 알고리즘:` 수학, 구현

`시간복잡도:` $O(N)$

`어떻게 접근했는지, 풀었는지 설명:`

토끼가 이동할 때마다 해당 위치의 값들 더해줘서 결과를 구하는 문제

문제는 인풋 N이 너무 커서  
모든 위치의 값을 미리 구할 수 없다는 것이다. (N <= 100000)  
-> 현재 위치가 주어졌을 때, O(1)로 값을 구해야 한다.

이를 위해 수학적으로 접근했다.  
1. 원점으로부터 떨어진 거리 v(= r+c)를 이용해 현재 라인의 base 값을 구한다.
2. v의 홀수/짝수 여부를 이용해 현재 라인의 방향을 구한뒤, 라인의 시작점부터 떨어진 거리만큼 더해준다.
3. v >= N 일때는, 마이너스 해줘야 하는 값 m을 구해서 빼준다.
   (m = (v-N)*(v-N+1) + v-N+1)


        접근은 매우 좋았지만, 하나 간과한 것이 있었다.
        현재 위치의 값, 결과를 long long으로 선언해주지 않은 것
        항상 숫자의 범위를 주의하자
        (중간 연산이 int로 변환되는 것도 주의하자)

---

### 3111 검열

https://www.acmicpc.net/problem/3111

`사용한 자료구조 & 알고리즘:` 덱, 분리 집합

`시간복잡도:` $O(AT)$

`어떻게 접근했는지, 풀었는지 설명:`

먼저 A에 해당하는 문자열들의 [시작 위치, 끝나는 위치]를 덱 dq에 넣어준다.  
그리고 front를 삭제하고, 삭제한 위치에는 false 표시를 해준다.  
```isValid[index] = false;```

그 다음, dq에서 현재 삭제한 문자열에 포함되는 front 들을 모두 삭제해준다.  
(삭제한 문자열의 위치가 [0,2] 인데 [1,3], [2,4]는 겹치기 떄문에 삭제해 줘야 한다)

그 다음, 삭제한 위치 주변에, 해당하는 문자열이 있는지 체크한다.  
(있다면 push_front)
(이때 내림차순으로 탐색해야 한다 -> dq의 순서 유지하기 위해)

그리고 back 을 삭제해준 다음 위와 같은 과정을 반복하면 된다.

> 여기서 아이디어를 적용한 것이 있는데,  
> 바로 현재 위치의 다음 위치를 가리키는 배열을 따로 선언해 O(1)에 바로 다음 위치를 탐색하도록 만든다.  
> (분리 집합을 이용한 인덱싱 - 10775번 문제(공항)을 보고 떠올렸다)
> 
> 만약 [1,3] 을 삭제한다면  
> isValid[1] = false;  
> isValid[2] = false;  
> isValid[3] = false;  
> 이 될 것이다.
> 
> 그렇다면 nextI[0] = 4 가 되야 한다.  
> 그리고 prevI[4] = 0 이 되야 한다.
> 
> 이 방법은 dq에 있는 노드를 삭제할 때마다 업데이트 해줘야 한다.

    다 풀고 보니까,
    그냥 투 포인터 활용해서 현재 위치만 저장해서 문자열 제거해도 가능 했을 것 같다.

---

### 3197 백조의 호수

https://www.acmicpc.net/problem/3197

사용한 자료구조 & 알고리즘: BFS, Union-Find

시간복잡도: $O(n^2 * logn)$ - 거의

어떻게 접근했는지, 풀었는지 설명:

일반적인 bfs 적용하면 O(n^3) - 시간초과

아이디어 1 - 빙판 가장자리의 물만 탐색하자

그리고 백조가 만날 수 있는 지 bfs로 확인하면 시간초과 난다.

아이디어 2 - 분리집합으로 체크하자 (O(logn) ~ O(1))


> 처음 접근은 완벽했는데,  
> 실수를 해서 3시간 까먹었다.  
> (Union 함수에서 루트의 parent를 다른 루트로 해야하는데, 나는 자식 노드의 parent를 다른 루트로 설정했다)  
> (이것도 반례를 봐서 알 수 있었다)

---

### 4195 친구 네트워크

https://www.acmicpc.net/problem/4195

`사용한 자료구조 & 알고리즘:` 해시맵, 분리집합

`시간복잡도:` $O(NlogN)$

`어떻게 접근했는지, 풀었는지 설명:`

N번 동안 친구 네트워크를 만들어 가는데,  
이를 연결해주고 전체의 개수를 세주는 것이 문제다.

> 이를 브루트포스로 풀면,  
> 매번 친구의 수를 세야 하므로 시간 초과가 발생한다.

이를 해결하기 위해 분리 집합을 이용한다.

이전 분리 집합 문제들은 인덱스만 관리했지만,  
이 문제는 인덱스 & 친구의 수 를 같이 관리한다.

1. 두명의 이름 s1, s2를 인덱스 i1, i2 로 변환 (해시맵 이용)
2. i1과 i2의 루트 인덱스가 같다면, 해당 루트의 친구의 수를 출력
3. (루트 인덱스가 다르다) i2의 루트 인덱스를 i1의 루트 인덱스로 업데이트  
   & i1의 루트의 친구 수 += i2의 루트의 친구 수  
   & i1의 루트의 친구 수를 출력

> 1번에서 해시맵을 이용할 때,  
> s가 해시맵에 저장이 되어 있지 않다면,  
> 해당 s와 cnt를 해시맵에 저장한 후,  
> cnt += 1 해준다.  
> (여기서 cnt는 새로운 친구의 인덱스 번호를 저장하는 변수 - 새로운 친구가 올때마다 1씩 더해진다)

---

### 4256 트리

https://www.acmicpc.net/problem/4256

사용한 자료구조 & 알고리즘: 구현, 분할 정복

시간복잡도: $O(n)$

어떻게 접근했는지, 풀었는지 설명:

전위 순회와 중위 순회가 주어졌을 때 후위 순회를 출력하는 문제

전위 순회의 특징 - 맨 처음에 중간노드가 나온다.  
중위 순회의 특징 - 중간노드를 기준으로 왼쪽은 왼쪽서브트리, 오른쪽은 오른쪽서브트리이다.

전체 순서
1. 전위 순회의 맨앞노드를 중위 순회에서 찾는다.
2. 왼쪽 서브 트리의 길이 = 중위 순회의 중간 노드 위치 - 중위 순회의 맨 처음 위치
3. 왼쪽 서브트리를 재귀적으로 호출
4. 오른쪽 서브트리를 재귀적으로 호출
5. 중간 노드 출력

위 과정을 반복

