# 무중단 배포 

스프링 서버의 다운 타임을 없애기 위해  
무중단 배포를 구현해보자.

1. 새로운 버전 서버 실행(8082)
2. 8082 포트로 헬스 체크
3. nginx reload(기존 8081 -> 8082)
4. 80 포트로 헬스 체크
5. 기존 서버 종료(8081)

---

## 문제 - 헬스 체크 기능

현재 nginx가 리버스 프록시 기능을 하고 있어서  
스프링 서버로 직접 요청하지 않고  
80번 포트로 요청하면 nginx가 알아서 요청을 전달해주는데,  

새로운 버전의 서버를 올리면  
이 서버의 상태가 어떤지를 확인할 수 있는 헬스 체크 기능이 필요하다.

### 기존 헬스 체크 기능

Thread.sleep(1000)을 넣어서 1초마다 응답을 보내는 헬스 체크 기능을 구현했다.

---

### 이벤트 기반 헬스 체크 기능 

깃허브 웹훅과 @EventListener(ApplicationReadyEvent.class) 어노테이션을 사용해서  
이벤트 기반의 헬스 체크 기능을 구현하려 했다.

> 깃허브 웹훅이란,  
> 깃허브에서 이벤트가 발생하면,  
> 이벤트를 받을 수 있는 URL로 POST 요청을 보내는 기능이다.
> 
> 이 URL에 요청을 보냄으로써, 별도의 workflow를 실행할 수 있다.

> @EventListener(ApplicationReadyEvent.class) 어노테이션은  
> 스프링 애플리케이션이 실행되면 발생하는 이벤트를 받을 수 있다.  
> (포트까지 완전히 올라왔을 때 발생하는 이벤트)
> 
> -> 이 어노테이션이 붙은 메서드가 실행된다는 것은, 스프링 서버가 정상적으로 올라왔다는 것을 의미한다.

---

### 기존 방식보다 개선된 점

기존 방식은 폴링 방식으로,  
주기적으로 계속 요청을 보내기 때문에  
서버에 부하를 줄 수 있다.

새로운 방식은 이벤트 기반으로,  
스프링 서버가 정상적으로 올라왔을 때만 요청을 보내기 때문에  
서버에 부하를 줄이고,  
실시간으로 서버의 상태를 확인할 수 있다.

### 새로운 방식의 문제점

현재 무중단 배포는  
1. 새로운 버전 빌드 & 실행
2. 헬스 체크 & 이후 작업

으로 나뉘는데,  
여기서 1번은 레포지토리에 푸쉬 이벤트가 발생할 때 실행되고,  
2번은 스프링 서버가 올라왔을 때 웹훅을 받아 실행된다.

이로 인해 workflow가 두 개로 나뉜다는 문제가 있다.

-> 두 workflow가 제대로 실행되지 않을 수 있는데, 이를 탐지하는 것이 어렵다.

---

### 결과

1. 기존 방식의 문제점은 그렇게 크지 않다고 생각한다.
2. 그리고 새로운 방식의 문제점이  
   (workflow가 나뉘어저 문제를 탐지하기 어렵다)  
   더 크다고 생각한다.

따라서 기존 방식을 유지하기로 결정했다.

---