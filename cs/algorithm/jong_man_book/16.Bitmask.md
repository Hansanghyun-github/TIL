# 16 비트마스크

현대의 모든 CPU는 이진수를 이용해 모든 자료를 표현합니다. 내부적으로 이진수를 사용하는 컴퓨터들은 이진법 관련 연산들을 아주 빨리 할 수 있기 때문입니다. 이와 같은 특성을 이용해 정수의 이진수 표현을 자료 구조로 쓰는 기법인 `비트마스크`라고 부릅니다.

비트마스크를 사용하는 코드는 다음과 같은 장점을 갖습니다.

1. 더빠른 수행시간: 비트마스크 연산은 O(1)에 구현되는 것이 많기 때문에, 적절히 사용할 경우 다른 자료구조를 사용하것보다 훨씬 빨리 동작합니다.

    물론 비트마스크를 사용할 수 있다는 말은 원소의 수가 많지 않다는 뜻입니다.

2. 더 간결한 코드: 다양한 집합 연산들을 반복문 없이 한줄에 쓸수 있기 때문에 비트마스크를 적절히 사용하면 굉장히 짧은 코드를 작성할 수 있습니다.

3. 더 작은 메모리 사용량: 비트마스크를 이용하는 코드들은 같은 데이터를 더 작은 메모리를 사용해 표현할 수 있습니다.

4. 연관 배열을 배열로 대체

이 장에서는 비트마스크를 자료 구조로 이용하는 방법과 각종 트릭들을 소개합니다.

---

`유의할 점들`

다음은 비트마스크를 이용하는 프로그램을 짤때 하기 쉬운 실수들입니다.

비트마스크를 할때 가장 많이 하는 실수는 연산자 간 우선순위를 혼동하는 것입니다.<br>
-> 이런 실수를 하지 않기 위해 비트마스크를 사용하는 식에는 가능한 한 괄호를 자세하게 추가하는 습관을 들이는 것이 좋습니다.

두번째로 많이 하는 실수는 64비트 정수를 비트마스크로 사용할 때 발생하는 오버플로입니다.<br>
-> 웬만하면 32개 이하로 하자 (중간중간 연산할때 32비트로 연산되서 실수할 수 있다)

    지금은 원소의 개수가 30개 이하라면 비트마스크 도입을 고민해보자.(간단하게)

---

## 16.2 비트마스크를 이용한 집합의 구현

비트마스크의 가장 중요한 사용 사례는 집합을 구현하는 것입니다.

`피자집 예제`

20개 이하의 토핑이 있을때 어떤 토핑을 넣었는지 확인하고 싶다.

`공집합과 꽉 찬 집합 구하기`

공집합 = 0, 꽉 찬 집합 = (1 << 20) - 1

`원소 추가` |= (1<<p)

`원소의 포함 여부 확인`

if(toppings & (1 << p)) /*토핑 추가된 것 확인*/

    이때 1로 체크하는 실수하지 말자
    if((toppings & (1 << p)) == 1) // 제대로 동작하지 않음

`원소의 삭제` &= ~(1<<p);

    -= (1<<p) 는 해당 토핑이 있을때만 가능하다.(빼는거라서 없을때 빼면 원하는대로 동작안됨)

`원소의 토글`(있으면 빼고 없으면 넣고) ^= (1<<p) // XOR 활용

`집합의 크기 구하기`

비트마스크를 이용할 때 집합에 포함된 원소의 수를 구하는 쉬운 방법은 딱히 없습니다.

그냥 각 비트를 순회하면서 체크하는 수밖에 없습니다.

---

### 어떻게 활용할까

실제 코테에서 이를 활용할 일은 거의 없을것같다.

    난이도가 이걸 활용할 정도로 나올것 같지도 않고, 활용한다고 해도 바로바로 응용이 안될것 같다

지금은 일단 완탐, DP, 그리디, 그래프, 백트래킹 이런 기본적인걸 연습하자 & 나중에 비트마스크도 연습하자

만약 도입한다면 원소의 개수가 30개 이하일때만 고민해보자(이래야 간단하게 적용할 수 있다)
