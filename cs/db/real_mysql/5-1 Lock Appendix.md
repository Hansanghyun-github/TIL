# 잠금(Lock)

Lock은  
접근 권한을 제어하는 방식에 따라 공유 락, 배타 락  
제어하는 범위에 따라 글로벌 락, 테이블 락, 레코드 락, 갭 락  
으로 나뉜다.

---

### 공유 락(Shared Lock)

(읽기 잠금이라고도 표현한다)

해당 레코드에 대해 읽기 권한을 얻는 락  
A 트랜잭션이 특정 레코드에 대한 공유 락을 가지고 있다면,  
B 트랜잭션은 해당 레코드를 읽기 작업(select)은 할 수 있지만,  
쓰기 작업(update, delete, insert)는 할 수 없다.

```select ... for share``` 쿼리를 보내면 공유 락을 요청할 수 있다.

> 만약 격리 수준이 `SERIALIZABLE`이라면  
> 오토커밋이 OFF인 상태에서 `SELECT` 쿼리도  
> (`SELECT ... FOR SHARE` 처럼 처리되서) 공유 락을 얻어야  
> 레코드를 조회할 수 있다.

### 배타 락(Exclusive Lock)

(쓰기 잠금이라고도 표현한다)

해당 레코드에 대해 쓰기 권한을 얻는 락  
A 트랜잭션이 특정 레코드에 대한 베타 락을 가지고 있다면,  
B 트랜잭션은 해당 레코드에 대한 모든 작업(select, update, delete, insert)을 할 수 없다.

```select ... for update```, `insert`, `update`, `delete` 쿼리를 보내면  
배타 락을 요청할 수 있다.

---

(글로벌 락, 테이블 락은 제외)

아래 락들은 MySQL InnoDB에서 제공하는 기능이다.

---

### 레코드 락(Record Lock)

특정 레코드에 대해 잠금을 거는 것

이때 레코드 자체에 잠금을 거는 것이 아니라,  
인덱스에 잠금을 건다.

> InnoDB는 모든 테이블이 클러스터링 인덱스를 가지고 있기 때문

---

### 갭 락(Gap Lock)

인덱스에서 레코드의 범위에 대해 락을 거는 것

잠금을 거는 쿼리가 인덱스를 범위 조건으로 탐색한다면  
해당 범위에 대해 insert 작업이 들어오는 것을 막는다.

### 쿼리 케이스별 갭 락 적용 예시

만약 쿼리의 조건이 1건의 결과를 보장하는 경우(PK or Unique Index)  
Gap Lock은 사용되지 않고, Record Lock 만 사용된다.

이외는(아예 없거나, 2개 이상)  
Record Lock + Gap Lock 이 사용된다.

### 갭 락 주의할 점

조건에 맞지 않는 레코드라도  
인덱스로 스캔되면 해당 레코드는 갭 락이 걸린다.  
(not 레코드 락)

> 만약 잠금을 거는 쿼리가 인덱스를 이용하지 못한다면  
> (풀 테이블 스캔을 해야한다면)  
> 모든 레코드에 대해 잠금을 건다.  
> (이는 테이블 락보다 비효율적이다)


### 갭 락의 범위

(범위 조건에서)  
만약 경계선에 해당하는 레코드가 있다면  
해당 레코드까지의 범위만 락을 건다.

> 만약 경계선에 해당하는 레코드가  
> 테이블의 마지막 레코드라면,  
> InnoDB 엔진은 테이블의 끝까지 갭 락을 건다고 한다.  
> (해당 값을 넘는 값을 가진 레코드를 insert하는 쿼리는 대기하게 된다)
> 
> 이는 인덱스의 리프 페이지마다 infimum(하한)과 supremum(상한)이 있는데  
> InnoDB 엔진은 경계선에 해당하는 레코드의 다음 레코드까지 스캔한다고 한다.  
> 여기서 조건에 해당하지 않으므로 조회되지는 않는다.  
> 하지만 InnoDB는 스캔하는 모든 레코드는 잠금을 걸기 때문에  
> 
> 범위 조건의 경계선에 있는 레코드가 테이블의 마지막 레코드라면  
> (InnoDB는 상한까지 스캔을 해서) 끝부분까지 갭 락이 걸린다고 한다.  
> (출처 [MySQL Gap Lock](https://medium.com/daangn/mysql-gap-lock-%EB%91%90%EB%B2%88%EC%A7%B8-%EC%9D%B4%EC%95%BC%EA%B8%B0-49727c005084))

그리고 경계선에 해당하는 레코드가 없다면  
해당 범위의 이전(다음)에 해당하는 레코드까지 갭 락을 건다.  
(페이지의 끝이라면 상한 레코드(가상 레코드))

> 이는 그때 그때의 리프 페이지의 상황에 따라서 다를 것 같다.  
> 만약 경계선에 해당하는 레코드(B 레코드)의 다음 레코드가 상한 레코드(가상 레코드)라고 가정,  
> (A 페이지라고 가정)  
> 위 페이지에 갭 락을 걸었다.
> 
> insert 하는 레코드가 B 레코드보다 값이 큰데,  
> (경계선에 해당하는 레코드의 페이지)A 페이지에 접근한다면,  
> (잠금이 걸린 상태)  
> 이는 갭 락에 의해 대기 될 것 같고,  
> 
> insert 하는 레코드가 B 레코드보다 값이 큰데,  
> A 페이지가 아닌, 그 다음 페이지에 접근한다면,  
> insert가 성공할 것 같다.

### 갭 락 사용 조건

쿼리가 갭 락을 사용하려면,  
binary log format이 STATEMENT or Mixed 여야 한다.  
그리고 트랜잭션 격리 수준이 REPEATABLE-READ or SERIALIZABLE 여야 한다.
(READ-COMMITTED도 쓸 수 있다고 함)

---

### 갭 락의 특징

Shared Gap Lock == Exclusive Gap Lock

Gap Lock은 MySQL 서버 내부적으로 Shared Lock 형태만 존재(Exclusive Gap Lock은 없음)한다.

> 순수하게 다른 트랜잭션이 대상 범위(Gap)에 새로운 레코드가 삽입되는 것을 막는 것이 목적이기 때문에

그래서 배타 락에 의한 Gap Lock이 충돌하더라도,  
여러 트랜잭션의 Gap Lock은 호환된다고 한다.

이로 인해 데드락이 발생할 수 있다고 한다.  
(근데 이는 너무 제한적인 케이스 같음(테이블에 데이터가 아예 없을 때), 일단 알아만 두자)