### 동시성(Concurrency) vs 병렬성(parallelism)

|        | 동시성(Concurrency)                 |병렬성(Parallelism)|
|--------|----------------------------------|--|
| 정의     | 서로 다른 작업들이 동시에 처리하는 것처럼 `보이는 것`    |여러 작업을 실제로 동시에 처리하는 것|
|        | 실제로는 번갈아가며 실행됨                   | 작업들이 각각 독립적으로 실행되며 서로 영향을 주지 않음  |
| 동작 방식  | 	싱글 코어에서 멀티 스레드를 동작(다중 코어에서도 가능) |멀티 코어에서 멀티 스레드를 동작|
| 개념적 차이 | 	논리적 개념                          |	물리적 개념|


---
여러 스레드가 동시에 한 대상에 접근을 하면 race condition이 발생할 수 있다.

### 경쟁 조건(race condition)
여러 프로세스/스레드가 동시에 같은 데이터를 조작할 때,  
접근 순서에 따라 결과가 달라질 수 있는 상황

> 한 구문의 코드가 CPU에서 명령 여러개 일 수 있다.
> ```
> state++
> 
> // 위는 일반 코드, 아래는 어셈블리 코드
> 
> ldr state, r1
> add r1, r1, #1
> str state, r1
> ```

### 동기화(synchronization)
프로세스/스레드 간 실행 순서를 정해주는 것

여러 프로세스/스레드를 동시에 실행해도  
공유 데이터를 일관성있게 유지하는 것

공유 자원 - 메모리, 파일

### 임계 영역(critical section)
공유 자원에 액세스하는 코드 부분

임계구간은 최소화해야 한다.  
그래야 데드락이 발생하지 않는다.

아예 없애면 lock-free

### mutual exclusion(상호 배제)
한번에 하나의 프로세스/스레드만 critical section에서 실행하는 것

---

> 네트워크 I/O는 기본적으로 `비동기` + 불안정하다
> 
> 삭제 작업은 추가 작업에 비해 3배 복잡하다

---

어떻게 mutual exclusion을 보장할 수 있을까?  
-> lock을 사용

---

## 락(lock)

정의: 공유 자원에 대한 접근을 제어하는 기법

임계구간에 들어가기 전에 락을 획득하고,  
임계구간을 빠져나오면 락을 반환

위 방법을 사용하면,  
임계구간에 들어가는 프로세스/스레드는 한번에 하나씩만 가능  
(상호 배제 보장)

> 프로세스 동기화 오브젝트 - 스핀락, 세마포어, 뮤텍스

### 스핀락(Spin Lock)
락을 가질 수 있을 때까지 반복해서 시도,  
but 기다리는 동안 CPU를 낭비

---

### 뮤텍스(mutex)

> 스핀락의 단점을 보완  
> -> 락을 얻기 전까지는 휴식을 취하자(wait)

락을 가질 수 있을 때까지 휴식

> 뮤텍스가 스핀락보다 항상 좋을까?
> 
> 멀티코어 환경이고, critical section의 작업이 컨텍스트 스위칭보다 빨리 끝난다면,  
> 스핀락이 더 좋을 수 있다.  
> -> 프로세스/스레드가 잠들고 깨울 때 컨텍스트 스위칭이 발생하기 때문  
> (인터럽트와 폴링 같은 느낌이네)


> 멀티코어 환경에서만 스핀락이 좋을 수 있다?  
> 
> 싱글코어라면 스핀락에서 다른 프로세스의 락을 받을려고 루프돌아도,  
> 이미 누군가가 쥐고 있는 락을 풀어야 한다. -> 컨텍스트 스위칭 필요  
> 
> -> 싱글코어는 스핀락의 이점이 없다

---

### 세마포어(semaphore)

signal mechanism을 가진,  
하나 이상의 프로세스/스레드가  
critical section에 접근 가능하도록 하는 장치

> 세마포어 vs 뮤텍스
> 
> 세마포어는 작업의 순서를 정해줄 때 사용 가능하다.  
> (뮤텍스는 순서를 제어할 수 없다)

```
// task1
semaphore -> signal()
```
```
// task2
semaphore -> wait()
// task3 
```

task3는 task1이 끝나야 실행 가능하다.

> 뮤텍스와 이진 세마포어는 같다?
> 
> 뮤텍스는 락을 가진 자만 해제할 수 있지만,  
> 세마포어는 그렇지 않다.
> 
> 뮤텍스는 priority inheritance 속성을 가진다.
> 세마포어는 x  
> (누가 락을 해제할지(signal) 알 수 없기 때문)

> priority inheritance  
> 락을 가진 프로세스의 우선순위를 높여주는 것  
> (락을 요청한 다른 프로세스의 우선순위 만큼)
> 
> 우선순위가 낮은 프로세스가 락을 가진 상태  
> 이때 우선순위가 높은 프로세스가 해당 데이터에 대해 락을 요청  
> (락을 가지고 있는 프로세스는 우선순위가 낮기 때문에 락을 늦게 해제할 수 있다 - starvation)  
> -> 락을 가지고 있는 프로세스의 우선순위를, 락을 요청하는 프로세스의 우선순위 만큼 높인다.

상호 배제만 필요 -> 뮤텍스  
작업 간의 실행 순서 동기화가 필요 -> 세마포어

---

## 모니터(Monitor)

mutual exclusion을 보장,  
& 조건에 따라 스레드가 대기(waiting) 상태로 전환 기능 제공

### 모니터 사용 시기

한번에 하나의 스레드만 사용해야 할 때  
여러 스레드와 협업(cooperation)이 필요할 때

### 모니터의 구성 요소

1. mutex
2. condition variables

mutex lock을 획득하지 못한 스레드는  
큐에 들어간 후 대기 상태로 전환

mutex lock을 쥔 스레드가 lock을 반환하면  
락을 기다리며 큐에 대기 상태로 있던 스레드 중 하나가 실행 됨

mutex와 관련한 큐를 entry queue라 함  
(뮤텍스 락을 획득하지 못한 스레드들이 들어가서 대기)

### condition variable

waiting queue를 가지고 있음  
조건이 충족되길 기다리고 있는 스레드들이 대기 상태로 머무는 곳

### condition variable의 주요 동작

`wait`  
스레드가 자기 자신을 condition variable의 waiting queue에 넣고 대기 상태로 전환

`signal`  
waiting queue에서 대기 중인 스레드 중 하나를 깨움

`broadcast`  
waiting queue에서 대기 중인 스레드 '전부'를 깨움

### 모니터의 실행 동작 코드

```
acquire(m);             // 락 획득
while(!p){              // 조건 확인
    wait(m, cv);        // 조건 충족안디면 wait
}

// critical section(while부터 signal까지)

signal(cv2); // or broadcase(cv2);  // cv도 가능
release(m);             // 락 반납
```

### 두개의 큐

entry queue: critical section에 진입을 기다리는 스레드가 있는 큐  
waiting queue: 조건이 충족되길 기다리는 스레드가 있는 큐

### 자바에서의 모니터 - synchronized

자바에서 모든 객체는 내부적으로 모니터를 가진다.  
모니터의 mutual exclusion 기능은 `synchronized` 키워드로 사용한다.  
(자바의 모니터는 condition variable를 하나만 가진다)

`synchronized`를 사용하는 방법
1. 메서드 앞에 선언  
   ```public synchronized void method1()```
2. 메서드 안에서 블록({})으로 선언    
   파라미터를 전달해줘야 함
   ```
   synchronized (this) {
    ...
   }
   ```

> 위에서 모니터는 `condition variable`를 이용해 스레드를 대기시키는데,  
> 현재 자바의 `syncronized` 키워드만 이용하는 것은 `mutex`와 같다.  
> (`condition variable`이 없다)
> 
> `syncronized`는 `mutex`와 `condition variable`를 모두 제공하는 것이 아니다.  
> (자바에서는 `wait`, `notify`, `notifyAll`을 이용해 `condition variable`을 구현해야 한다)

---

## 데드락(dead lock)

<img src="../../../img/OS_41" width="500">

두개 이상의 프로세스/스레드가 서로가 가진 리소스를 기다리는 상태

여기서 리소스는 단순히 메모리, 파일 뿐만 아니라, I/O device도 의미한다.

### 데드락을 만드는 4가지 조건

1. mutual exclusion  
   리소스 공유 금지
2. hold and wait  
   프로세스가 이미 하나 이상의 리소스를 취득한(hold) 상태에서  
   다른 프로세스가 사용하고 있는 리소스를 추가로 기다리는(wait) 것
3. no preemtion  
   리소스 반환은 오직 그 리소스를 취득한 프로세스만 가능
4. circular wait
   프로세스들이 순환하는 형태로 서로의 리소스를 기다린다

> 임계구간에 영향을 주는 요소가 2개 이상일 때

---

## OS의 데드락 해결 방법

1. 데드락 방지
2. 데드락 회피
3. 데드락 감지와 복구
4. 데드락 무시

### 1. 데드락 방지

4가지 조건 중 하나가 충족되지 않게 시스템을 디자인

1. 리소스 공유 가능
2. 사용할 리소스들을 모두 획득하고 시작  
& 리소스를 전혀 가지지 않은 상태에서만 리소스 요청
3. 추가적인 리소스를 기다려야 한다면 이미 획득한 리소스를 다른 프로세스가 선점가능하도록 함
4. 모든 리소스에 순서 체계를 부여

### 2. 데드락 회피

실행 환경에서 추가적인 정보를 활용해서 데드락이 발생할 것 같은 상황을 회피하는 것

### 3. 데드락 감지와 복구

데드락을 허용하고 데드락이 발생하면 복구하는 전략

1. 프로세스를 종료
2. 리소스의 일시적인 선점을 허용

> 데드락이 일어나면 dump를 분석해야 한다.  
> 그 중에서 Call Stack을 분석해야 한다.