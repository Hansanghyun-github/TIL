# 리눅스의 /proc 디렉토리
 
프로세스, 커널, 등 다양한 정보를 제공하는 디렉토리이다.

- /proc/stat : 시스템 상태에 대한 다양한 정보가 기록된다.

- /proc/meminfo : 메모리 사용량에 대한 정보가 기록된다.

- /proc/{PID} : 프로세스의 정보가 기록된다. (PID는 프로세스의 고유번호)

- /proc/uptime : 시스템 가동시간에 대한 정보가 기록된다.
  
- /proc/version : 커널의 버전을 알 수 있다.(uname -a)

- /proc/net : 네트워크 정보가 기록된다.

---

## /proc/stat 디렉토리

시스템 상태에 대한 다양한 정보가 기록되어 있는 파일

시스템 부팅 시간, 전체 CPU 정보, 개별 CPU 코어별 정보, 컨텍스트 스위칭 발생 횟수 등이 기록되어 있다.

### 파일 예시

```shell
ubuntu@ip-170-31-7-193:~$ cat /proc/stat
cpu  924119 20461 277428 335669037 78575 0 16838 44227 0 0
cpu0 924119 20461 277428 335669037 78575 0 16838 44227 0 0
intr 529992498 261 9 0 0 1374 0 3 0 2 0 0 0 144 0 0 0 0 0 0 0 0 0 0 0 # ...
ctxt 455566350
btime 1718148862
processes 277579
procs_running 2
procs_blocked 0
softirq 94223367 0 44695013 13018455 13573301 5161675 0 581828 0 1357 17191738
```

cpu, cpuX: User 모드, nice 값이 있는 사용자 모드, System 모드, idle 상태, I/O wait 상태, 인터럽트 발생 횟수, 소프트 인터럽트 발생 횟수 등이 기록되어 있다.
(위 순서대로 숫자가 기록되어 있다)

cpu는 모든 코어를 합한 정보가 기록되어 있고,  
cpuX는 각 코어별 정보가 기록되어 있다.

> 현재 내가 캡처한 파일은 1개의 코어만 있다.  
> 그래서 cpu0만 기록되어 있고, cpu 정보와 cpu0 정보가 동일하다.

ctxt: 컨텍스트 스위칭 발생 횟수가 기록되어 있다.

btime: 부팅 시간이 기록되어 있다. (1970년 1월 1일 00:00:00 UTC부터의 초)

processes: 프로세스 생성 횟수가 기록되어 있다.

---

## /proc/{PID} 디렉토리

- /proc/{PID}/cmdline : 프로세스의 실행 명령어가 기록됩니다.
- /proc/{PID}/cwd : 프로세스의 현재 작업 디렉토리가 기록됩니다.
- /proc/{PID}/environ : 프로세스의 환경 변수가 기록됩니다.
- /proc/{PID}/exe : 프로세스의 실행 파일이 심볼릭 링크로 연결되어 있습니다.
- /proc/{PID}/fd : 프로세스의 파일 디스크립터가 심볼릭 링크로 연결되어 있습니다.
- /proc/{PID}/maps : 프로세스의 메모리 맵 정보가 기록됩니다.
- /proc/{PID}/status : 프로세스의 상태 정보가 기록됩니다.
- /proc/{PID}/stat : 프로세스의 상태 정보가 기록됩니다.
- /proc/{PID}/task : 프로세스의 스레드 정보가 기록됩니다.
- /proc/{PID}/limits : 프로세스의 리소스 제한 정보가 기록됩니다.
- /proc/{PID}/mounts : 프로세스의 마운트 정보가 기록됩니다.
- /proc/{PID}/net : 프로세스의 네트워크 정보가 기록됩니다.
- /proc/{PID}/sched : 프로세스의 스케줄링 정보가 기록됩니다.
- /proc/{PID}/statm : 프로세스의 메모리 사용량 정보가 기록됩니다.

### /proc/{PID}/environ 파일

프로세스의 환경 변수를 확인할 수 있는 파일

하지만 해당 파일을 그대로 확인하면,  
변수 간 구분이 없고, 한 줄로 나열되어 있어서 보기가 어렵다.

> 변수 간 구분을 '\0'으로 분리시켜 놓았기 때문이다.

따라서 해당 파일을 읽어서 출력할 때는,  
'\0'을 기준으로 문자열을 나누어 출력해야 한다.

```shell
$ cat /proc/{PID}/environ | tr '\0' '\n'
```

> tr [option] set1 set2
> 
> 텍스트 스트림에서 문자 변환을 수행하는 명령어
> 
> - option: 변환 방법을 지정
> - set1: 변환할 문자 집합
> - set2: 변환될 문자 집합

---

## /proc/net 디렉토리

네트워크 정보가 기록되어 있는 디렉토리

### /proc/net/socket 파일

현재 시스템에서 소켓 관련 정보를 확인할 수 있는 파일

`파일 예시`

```shell
TCP: inuse 3 orphan 0 tw 0 alloc 22 mem 71
UDP: inuse 4 mem 0
UDPLITE: inuse 0
RAW: inuse 0
FRAG: inuse 0 memory 0
```

TCP: inuse - 현재 사용 중인 TCP 소켓 개수  
TCP: orphan - 소켓이 연결되지 않은 상태의 TCP 소켓 개수  
(어플에서 close를 했지만, 아직 커널에 의해 소켓이 제거되지 않은 상태)  
TCP: tw - TIME_WAIT 상태의 TCP 소켓 개수  
(소켓이 close된 후, TIME_WAIT 상태로 대기하는 소켓 개수)  
TCP: alloc - 할당된 TCP 소켓 개수  
(열려 있거나, 준비 상태에 있는 경우를 포함한다)  
TCP: mem - TCP 소켓에 할당된 메모리 크기

> 여기서 alloc 값은 inuse 값을 포함한다.  
> (tw는 포함하지 않는다)

> TCP의 TIME_WAIT 상태는  
> 4-way handshaking 과정에서,  
> 상대방 호스트에게 먼저 FIN을 보내고, FIN/ACK을 받은 후,  
> 마지막으로 ACK를 보낸 후에 발생한다.  
> (마지막으로 보낸 ACK 패킷이 잘못 처리되어, 다시 보내는 경우가 있기 때문에 대기하는 상태)