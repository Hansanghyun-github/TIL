# 7 더 나은 테스트를 위한 구체적인 조언들

`한 문단에 한 주제`

테스트 코드라는 것을 글쓰기의 관점으로 봤을 때, 각각 하나하나의 테스트가 한 문단이라고 생각을 해보면<br>
이 하나의 테스트는 하나의 주제만을 가져야 된다.

    테스트 코드에서 if가 있다는 것은, 분리를 가른다.
    -> 두가지 케이스를 테스트 하겠다. -> 두가지 이상의 내용이 있다.

    for문도 마찬가지이다.

    이런 것은 지양하는 것이 좋다.

-> 한가지 테스트에서는 한가지 목적의 검증만 수행하자

> 디스플레이 네임을 한문장으로 구성할 수 있는가? 라고도 생각할 수 있다.

---

`완벽하게 제어하기`

저번 시간에 LocalDateTime.now()를 이용해서 테스트를 실패한 적이 있었다.

이처럼 모든 상황을 제어할 수 있는가를 고민해봐야 한다.

어떤 테스트 코드는 LocalDateTime.now()를 써도 문제없는 코드일 수도 있다.

하지만 나중에 이 코드가 문제가 될 수도 있다.

그냥 LocalDateTime.now()는 쓰지 말자! -> 고정된 날짜, 시간, 값을 사용하자

    외부 시스템을 활용할 때도, 외부 시스템이 정상작동 할때와 에러가 났을때 두가지를 모두 제어하자

---

`테스트 환경의 독립성을 생각하자`

given절에서 환경을 조성하고, when/then절에서 테스트를 진행하는데, given절에서 오류가 나서 테스트가 진행이 안될 수 있다.

ex) 주문할 아이템을 추가해서, 재고를 차감시키려 하는데, 잘못입력해서 재고 차감 부분 코드에서 오류가 났다.

아이템을 추가 & 재고를 차감 -> 두가지 일이 생긴것(논리구조가 들어감) -> 독립적인 테스트가 아니다.

`테스트 환경을 조성할 때는 생성자, Builder 기반으로 조성하는 것이 좋다.`

팩토리 메서드도 테스트할때는 지양하자

---

`테스트 간 독립성을 보장하자`

테스트 메서드끼리 변수 공유 금지

하나의 메서드가 변수의 내부 상태를 바꾸면 다른 메서드에서 오류가 날 수 있다.

공유 자원을 사용하면 테스트 간 순서가 생길 수 있다.

    그런데 하나의 인스턴스가 변화하는 모습을 차례대로 테스트 하고싶을 수도 있다.
    이게 또 하나의 테스트에서 다 작성하기에는 너무 많을 수도 있다.

    Dynamic Test 사용 // 뒤에서

---

`한눈에 들어오는 Test Fixture 구성하기`

>Fixture: 고정물, 고정되어 있는 물체
>
>테스트를 위해 원하는 상태로 고정시킨 일련의 객체

하나의 테스트에서 given 데이터가 겹치는 경우가 굉장히 많다.

이를 해결하기 위해 @BeforeEach를 사용할 수 있지만, 이는 공유 변수를 사용하는 것과 비슷하다.<br>
-> 특정 테스트만 다른 변수를 사용하고 싶다고 @BeforeEach의 코드를 바꾸면, 다른 테스트에 영향을 끼친다.<br>
-> 그리고 @BeforeEach의 코드를 보려고 계속 위아래로 봐야한다.(정보가 파편화 되어있음)<br>
-> @BeforeEach 지양하자

@BeforeEach를 쓰는 경우 -> 이 코드를 아예 몰라도 테스트 내용을 이해하는데 문제가 없을 때 & 수정해도 모든 테스트에 영향을 주지 않을 때

항상 Fixture들은 given절에 - 문서로서의 테스트를 생각

    또 Build하는 코드가 너무 길어서 메소드로 변환했는데, 이때 필요한 파라미터만 넘겨주자
    ex) 이름이 상관없다면, 이름을 제외한 다른 필드만 넘겨주면 깔끔해진다.

그리고 객체 생성용 메서드는 그냥 따로따로 만들어두자, 합치면 나중에 고치기 힘들어 진다.

---

`Text Fixture 클렌징`

(deleteAll vs deleteAllInBatch)

deleteAllInBatch는 깔끔하게 테이블 전체를 벌크성으로 delete 해준다. - 순서를 고려해야 한다.

    그냥 쓰면 FK 제약 조건에 의해 오류가 날 수 있다.

deleteAll은 FK 설정 되어있는 튜플을 같이 지워준다. - 대신 중간중간 select절로 FK 되어있는 튜플을 찾기 때문에, 느리다.

그런데 deleteAll도 순서를 생각해야 한다. - 연관관계를 안지어주면, 다른곳에서 참조(FK)하고 있어도 이걸 몰라서 오류가 난다.

'테스트도 비용이다' - deleteAllInBatch가 낫다.

    그냥 @Transactional을 통해 롤백을 할수도 있지만, 
    통합 테스트에는 여러 트랜잭션이 참여하고 있기 때문에, 테스트에 트랜잭션을 붙히기 어려울 수 있음
    -> 그냥 @AfterEach, deleteAllInBatch 통해 데이터를 일일이 지워준다함

---

`@ParameterizedTest`

테스트 코드 내에 if-else, for문들이 들어있으면, 읽는 사람의 생각을 요하기 때문에 지양해야 한다고 했음

이때 값을 여러개 바꿔 보면서 테스트 하고 싶을 때가 있다.

이때 사용하는게 @ParameterizedTest 이다.
```java
@CsvSource("x1,y1, ...", "x2,y2, ...", ...) 
@ParameterizedTest
void test1(변수1 x, 변수2 y)
```

이렇게 붙여서 따로따로 검증 가능하다.

    @MethodSource 와 메서드를 통해 파라미터를 메서드에서 정의할 수 있다.

---

`@DynamicTest`

어떤 환경을 설정해놓고, 환경에 변화를 주면서, 결과를 지켜보고 싶을 때가 있다.

그냥 같은 환경에서 시작해서, 다른 변화를 주고 각각의 결과를 지켜보는 테스트

    그냥 별도의 메서드로 구분해도 될것같음. // 아직은

---

`테스트 환경도 비용이다. 환경 통합하기`

    테스트를 작성하는 이유는, 사람이 수동으로 검증하는 비용보다 기계의 도움을 받아서 수시로 검증하는 것이 비용관리면에서 좋다.

전체 테스트를 자주 할 수 있어야 함. 그런데 서버가 뜨는 횟수가 많아진다면 전체 테스트 수행시간이 길어지게 된다.

profile이 다르다면, 서버가 중복으로 뜨게 됨 -> 환경을 통일하면 서버가 뜨는 시간(횟수)을 줄일 수 있다.

@MockBean을 사용했을때도 다른 환경이라서, 서버가 새로 뜸

    강사분이 @DataJpaTest보다 @SpringBootTest를 선호하는 이유도 여기에 있다.
    
    @DataJpaTest를 쓰면, 서버를 따로 또 띄워야함

    그래서 그냥 통일해서 서버 띄우는 시간을 줄임

여기서 @WebMvcTest는 통합하기 어렵다.

서비스 모킹을 통해, 컨트롤러 레이어를, 검증에 대한 것들을 빠르게 테스트 했기 때문에

    추상클래스로 @SpringBootTest를 선언하고, 이를 상속 받으면 환경이 공유가 됨
    (@MockBean을 사용한다면 이를 추상 클래스에 선언해줘야 한다, 하위 클래스에 @MockBean있으면 서버 새로뜸(다른 환경이라))

    @WebMvcTest도 마찬가지


컨트롤러끼리 @WebMvcTest, 서비스&리포지토리 함께 @SpringBootTest를 할수 있음(아니면 레이어 별로)

---

`private 메서드 테스트`

할 필요가 없고 & 해서도 안된다.

    public 메서드는 공개 API, 객체가 공개 API를 테스트 하다 보면 private 메서드도 자연스럽게 검증이 된다.

    근데 그런 욕망이 강하게 든다면 객체 분리의 신호로 봐야 한다.

private 메서드를 테스트하고 싶어질 때 해야할 고민이 있다.

'객체를 분리해야 할 시점인가?'

---

`테스트에서만 필요한 메서드가 생겼는데 프로덕션 코드에서는 필요가 없다면?`

ex) 게터, 기본 생성자, 빌더, 사이즈

만들어도 된다. 하지만 '보수적으로' 접근하자

-> 미래에도 사용될지를 생각해보자.

---

### 키워드 정리

테스트 하나당 목적은 하나!

완벽한 제어

테스트 환경의 독립성, 테스트 간 독립성

Test Fixture

deleteAll(), deleteAllInBatch()

@ParameterizedTest, @DynamicTest

수행 환경 통합하기

private mehtod test

테스트에서만 필요한 코드