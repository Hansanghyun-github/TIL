# 람다를 이용한 도메인 전용 언어

> `이 장의 내용`
>
> 도메인 전용언(domain-specific languages, DSL)어란 무엇이며 어떤 형식으로 구성되는가?
>
> DSL을 API에 추가할때의 장단점
>
> JVM에서 활용할 수 있는 자바 기반 DSL을 깔끔하게 만드는 대안
>
> 최신 자바 인터페이스와 클래스에 적용된 DSL에서 배움
>
> 효과적인 자바 기반 DSL을 구현하는 패턴과 기법
>
> 이들 패턴을 자바 라이브러리 도구에서 얼마나 흔히 사용하는가?

---

## 10.1 도메인 전용 언어

DSL은 특정 비즈니스 도메인의 문제를 해결하려고 만든 언어이다.
> DSL이란 특정 비즈니스 도메인을 인터페이스로 만든 API라고 생각할 수 있다.

DSL을 개발할 때는 두가지가 필요하다.

1. 의사 소통의 왕: 우리의 코드의 의도가 명확히 전달되어야 하며 프로그래머가 아닌 사람도 이해할 수 있어야 한다.
2. 한 번 코드를 구현하지만 여러 번 읽는다: 가독성은 유지보수의 핵심이다. 항상 우리의 동료가 쉽게 이해할 수 있도록 코드를 구현해야 한다.

---

### 10.1.1 DSL의 장점과 단점

DSL을 도메인에 이용하면 약이 되거나 독이 될 수 있다.
> DSL은 코드의 비즈니스 의도를 명확하게 하고 가독성을 높인다는 점에서 약이 된다.
>
> 반면 DSL 구현은 코드이므로 올바르게 검증하고 유지보수해야하는 책임이 따른다.

DSL은 다음과 같은 장점을 제공한다.
1. 간결함
2. 가독성
3. 유지보수
4. 높은 수준의 추상화
5. 집중 - 프로그래머가 특정 코드에 집중할 수 있다. 결과적으로 생산성이 좋아진다.
6. 관심사분리

반면, DSL로 인해 다음과 같은 단점도 발생한다.
1. DSL 설계의 어려움: 간결하게 제한적인 언어에 도메인 지식을 담는 것은 쉬운 작업은 아니다.
2. 개발 비용
3. 추가 우회 계층
4. 새로 배워야 하는 언어
5. 호스팅 언어 한계

---

### 10.1.2 JVM에서 이용할 수 있는 다른 DSL 해결책

내부 DSL은 순수 자바 코드 같은 기존 호스팅 언어를 기반으로 구현하는 반면, 외부 DSL은 호스팅 언어와는 독립적으로 자체의 문법을 가진다.

`내부 DSL`

자바로 구현한 DSL을 의미한다.
> 람다 표현식이 등장하면서 자바를 이용해서 DSL을 만들때의 문제가 어느정도 해결될 수 있다.

```numbers.forEach(System.out::println);```

순수 자바로 DSL을 구현함으로 얻을 수 있는 장점
1. 기존 자바 언어를 이용해서 다른 기술을 배워 DSL을 구현하는 노력이 현저하게 줄어든다.
2. 외부 DSL을 만드는 도구를 사용할 필요가 없으므로 추가로 비용이 들지 않는다.
3. 기존 IDE를 이용해 자동 완성, 자동 리팩터링 같은 기능을 그대로 이용가능하다.


`다중 DSL`

같은 자바 바이트코드를 사용하는 JVM 기반 프로그래밍 언어를 이용한 DSL

(스칼라)
```scala
3 times{
    println("Hello Word")
}
```

몇가지 불편함이 있다.
1. 새로운 프로그래밍 언어를 배우거나, 다른 사람이 해당 기술을 가지고 있어야 한다.
2. 두개이상의 언어가 혼재하므로 여러 컴파일러로 소스를 빌드하도록 빌드 과정을 개선해야 한다.
3. 자바와 호환성이 완벽하지 않을 때가 많다.

`외부 DSL`

자신만의 문법과 구문으로 새 언어를 설계해야 한다.

외부 DSL의 큰 장점은 외부 DSL이 제공하는 무한한 유연성이다. 우리가 필요한 특성을 제공하는 언어를 설계할 수 있다.

---

## 10.2 최신 자바 API의 작은 DSL

리스트의 사람들을 나이와 이름순으로 정렬한다고 했을때 이를 자바로 구현하면,

예전 코드

```java
Collecitons.sort(persons, new Comparator<Person>(){
    public int compare(Person p1, Person p2){
        return p1.getAge() - p2.getAge();
    }
})
```

람다와 메서드 참조를 적용한 코드

```java
persons.sort(comparing(Person::getAge))
    .thenComparing(comparing(Person::getNAme));
```

람다와 메서드 참조를 이용함으로써 DSL이 코드의 가독성, 재사용성, 결합성을 높일 수 있음을 보여준다.

### 10.2.1 스트림 API는 컬렉션을 조작하는 API

Stream 인터페이스는 네이티브 자바 API에 작은 내부 DSL을 적용한 좋은 예다.

스트림 API의 플루언트 형식은 잘 설계된 DSL의 또 다른 특징이다.

모든 중간연산은 lazy 연산이고, 다른 연산으로 파이프라인될 수 있는 스트림으로 반환된다.<br>
최종 연산은 eager 연산이고, 전체 파이프라인이 계산을 일으킨다.

### 10.2.2 데이터를 수집하는 DSL인 Collectors

플루언트 형식 - comparing(Person::getAge).thenComparing(Person::getName)

중첩 형식 - groupingBy(Car::getBrand, groupingBy(Car::getColor))

## 10.3 자바로 DSL을 만드는 패턴과 기법

### 10.3.1 메서드 체인

```java
Order order = forCustomer("BigBank")
        .buy(80)
        .stock("IBM")
        .on("NYSE")
        ...
        .end();
```

이런 DSL을 구현하려면, 플루언트 API로 도메인 객체를 만드는 몇개의 빌더를 구현해야 한다.

> 빌더를 구현해야 한다는 것이 메서드 체인의 단점이다.
>
> 상위 수준의 빌더를 하위 수준의 빌더와 연결할 접착 많은 접착 코드가 필요하다.
>
> 도메인의 객체의 중첩 구조와 일치하게 들여쓰기를 강제하는 방법이 없다는 것도 단점이다.

### 10.3.2 중첩된 함수 이용

```java
Order order = order("BigBank",
                    buy(80,
                        sstock("IBM", on("NYSE"), ...)),
                    sell(...));
```

메서드 체인에 비해 함수의 중첩 방식이 도메인 객체 계층 구조에 그대로 반영된다는 것이 장점이다.

> 결과 DSL에 더 많은 괄호를 사용해야 한다는 단점이 있다.
>
> 인수 목록을 정적 메서드에 남겨줘야 한다는 제약도 있다.

### 10.3.3 람다 표현식을 이용한 함수 시퀀싱

```java
Order order = order(b -> {
    b.choice(b2 -> {
        b2.product(product1);
        b2.orderCount(1);
    });
    b.choice(b2 -> {
        b2.product(product2);
        b2.orderCount(1);
    });
    b.applyCoupon(coupon);
});
```

이런 DSL을 만들려면 람다 표현식을 받아 실행해 도메인 모델을 만들어 내는 여러 빌더를 구현해야 한다.<br>
이들 빌더는 메서드 체인 패턴을 이용해 만들려는 객체의 중간 상태를 유지한다.

이 패턴은 이전 두가지 DSL 형식의 두가지 장점을 더한다. 메서드 체인 패턴처럼 플루언트 방식으로 거래 주문을 정의할 수 있다. 또한 중첩 함수 형식처럼 다양한 람다 표현식의 중첩 수준과 비슷하게 도메인 객체의 계층 구조를 유지한다.

> 안타깝게도 많은 설정 코드가 필요하며 DSL 자체가 자바 8 람다 표현식 문법에 의한 잡음의 영향을 받는다는것이 단점이다.

---

지금까지 살펴본 것처럼 세가지 DSL 패턴 각자가 장단점을 가지고 있다.

|패턴 이름|장점|단점|
|--|--|--|
|메서드 체인|- 메서드 이름이 키워드 인수 역할을 한다.|- 구현이 장황하다.|
|--|- 선택형 파라미터와 잘 동작한다.|- 빌드를 연결하는 접착 코드가 상당히 많이 필요하다.|
|--|- DSL 사용자가 정해진 순서로 메서드를 호출하도록 강제한다.|- 들여쓰기 규칙으로만 도메인 객체 계층을 정의한다.|
|--|- 정적메서드를 최소화하거나 없앨 수 있다.||
|--|- 문법적 잡음을 최소화한다. (사용할 때)||
|중첩 함수|- 구현의 장황함을 줄일 수 있다.|- 정적 메서드의 사용이 빈번하다.|
|--|- 함수 중첩으로 도메인 객체 계층을 반영할 수 있다.|- 이름이 아닌 위치로 인수를 정의한다.|
|-|--|- 선택형 파라미터를 처리할 메서드 오버로딩이 필요하다.|
|람다를 이용한 함수 시퀀싱|- 선택형 파라미터와 잘 동작한다.|- 구현이 장황하다.|
|--|- 정적 메서드를 최소화하거나 없앨 수 있다.|- 람다 표현식으로 인한 문법적 잡음이 DSL에 존재한다. (사용할 때)|
|--|- 람다 중첩으로 도메인 객체 계층을 반영한다.||
|--|- 빌더의 접착 코드가 없다.||

---

## 10.4 실생활의 자바 8 DSL

스프링 시큐리티 SecurityConfig 설정할때도 DSL을 활용하네.

---

## 10.5 마치며

1. DSL의 주요 기능은 개발자와 도메인 전문가 사이의 간격을 좁히는 것이다.
    > 애플리케이션의 비즈니스 로직을 구현하는 코드를 만든 사람이 프로그램이 사용될 비즈니스 필드의 전문 지식을 갖추긴 어렵다. 개발자가 아닌 사람도 이해할 수 있는 언어로 이런 비즈니스 로직을 구현할 수 있다고 해서 도메인 전문가가 프로그래머가 될 수 있는 것은 아니지만 적어도 로직을 읽고 검증하는 역할은 할 수 있다.
2. DSL은 크게 내부적(DSL이 사용될 애플리케이션을 개발한 언어를 그대로 활용) DSL과 외부적(직접 언어를 설계해 사용함) DSL로 분류할 수 있다.
    > 내부적 DSL은 개발 노력이 적게 드는 반면 호스팅 언어의 문법 제약을 받는다. 외부적 DSL은 높은 유연성을 제공하지만 구현하기가 어렵다.
3. 자바의 장황함과 문법적 엄격함 때문에 보통 자바는 내부적 DSL을 개발하는 언어로는 적합하지 않다.<br>
    하지만 자바 8의 람다 표현식과 메서드 참조 덕분에 상황이 많이 개선되었다.
4. 자바 DSL을 구현할 때 보통 메서드 체인, 중첩 함수, 함수 시퀀싱 세가지 패턴이 사용된다. 각각의 패턴은 장단점이 있지만 모든 기법을 한 개의 DSL에 합쳐 장점만을 누릴 수 있다.
5. 많은 자바 프레임워크와 라이브러리를 DSL을 통해 이용할 수 있다.
    > 내가 본건 스프링 시큐리티





















