### HashMap의 해시 충돌 전략

해시 충돌 전략으로 separate chainning을 사용한다.  
(open addressing보다 캐시 효율은 낮지만, 삭제할 때 비효율적)

노드의 개수가 일정 값을 벗어나면, 해당 구조는 링크드리스트에서 트리로 변한다.  

> (default)  
> 추가할 때 8개 이상 -> 트리로  
> 삭제할 때 6개 이하 -> 연결리스트로

---

트리는 레드-블랙 트리를 사용한다.  
구현은 TreeMap과 거의 같다.

트리 순회 시 사용하는 대소 판단 기준은 해시 함수 값이다.  
(만약 해시 값이 같다면 두 노드의 키 값으로 순서를 정한다 - tieBreakOrder 메서드)

---

### HashMap의 보조 해시 함수

해시 버킷 개수의 기본값은 16이고, 데이터의 개수가 임계점에 이를 때마다 해시 버킷 개수의 크기를 두 배씩 증가시킨다.

여기서 문제는 해시 버킷의 개수 M이 $2^a$가 되기 때문에  
일반적으로 많이 사용하는 해시 함수인 hash % M은  
hash의 하위 a개의 비트만 사용하게 된다.  
-> 충돌이 쉽게 발생할 가능성이 높아진다.

그래서 보조 해시 함수를 사용한다.
```
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

그리고 해시테이블의 인덱스를 구할 때  
`tab[(n - 1) & hash]` (n = 테이블의 길이)  
이렇게 구하는데,  

기존 hash % n 보다 빠르다.  
(나머지 연산보다 XOR, AND 연산이 빠르다)

---

### (Appendix) 문자열의 해시 함수

string의 해시코드를 구할때, 각 문자에 31^{위치}를 곱하는데,  
31을 사용하는 이유는,  
1. 31은 소수라서, 다른 수의 배수가 되기 어렵다  
   -> 충돌 가능성이 낮아진다.
2. 계산 성능  
   31 * N = N << 5 - N  
   컴퓨터에서 곱셈연산은 덧셈보다 오래 걸리는데,
   이를 shift, 뺄셈연산을 이용해 효율적으로 처리 가능

