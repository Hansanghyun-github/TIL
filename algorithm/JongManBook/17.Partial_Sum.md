# 17 부분 합

n명의 성적이 주어졌을때, a학생부터 b학생까지의 평균을 구하고 싶다.

이는 O(n)으로 간단하게 구현가능하지만, a와 b가 수시로 바뀐다면 $O(n^2)$이 걸리게 된다.

이때 부분 합 또는 누적 합을 적용해서 최적화가 가능하다.

부분합 공식

```cpp
int input[100];
int partialSum[100];

partialSum[0] = input[0];
for(int i=1;i<100;i++)
    partialSum[i] = partialSum[i-1]+input[i];
```

이때 a부터 b사이의 평균을 구할려고 한다면

(partialSum[b] - partialSum[a-1])/(b-a)를 통해 구할 수 있다.(O(1))

`2차원으로의 확장`

부분 합은 1차원 배열에서만 쓸 수 있는 것은 아닙니다.

2차원 배열 A[][]이 주어질때, A[x1][y1]에서 A[x2][y2]까지의 직사각형 구간의 합을 계산해야 할때도 부분합을 적용할 수 있다.

partialSum[x][y] = input[0][0]부터 input[x][y]까지의 직사각 형 구간의 합

sum(x1, y1, x2, y2) = partialSum[x2][y2] - partialSum[x1-1][y2] - partialSum[x2][y1-1] + partialSum[x1-1][y1-1]

위를 통해 구할 수 있다.

이는 딱 한번만 누적합을 구한후 직사각형 구간의 합을 계산하는 것은 O(1)이 걸리기 때문에, 시간복잡도는 $O(n^2)$이 걸린다.

---

여기서 응용된 버전도 있음 - 프로그래머스 파괴되지 않은 건물 문제

1차원 배열에서 044400, 005550, 011110 을 더해주려면<br>
3x6번 수행해야 함

여기서 1차원 배열의 길이가 n이 되고, m개 있다면 n*m번 수행해야 함

이때 간단한 아이디어를 적용하면 n+m으로 줄일 수 있다.

044400 -> 0400-40<br>
005550 -> 00500-5<br>
011110 -> 01000-1

이렇게 한뒤, 3개를 모두 더해준다. 그러면<br>
0550-4-6이 된다. 그리고 왼쪽에서 오른쪽으로 누적합 진행하면,<br>
0|5|10|10|6|0 (-> 044400 + 005550 + 011110)<br>
(n*m을 n+m으로 줄였다)

    이 방법을 2차원 배열에도 적용 가능하다.

    1차원 배열은 왼쪽에서 오른쪽으로 누적합 진행했고
    2차원 배열은 위에서 아래, 왼쪽에서 오른쪽으로 누적합 진행한다.



