# 3. 코딩과 디버깅에 관하여

## 3.1 도입: 코딩의 중요성을 간과하지 말라

프로그래밍 대회에서 알고리즘이나 자료구조에 대한 지식도 중요하지만,<br>
코딩 과정도 중요하다.

프로그래밍 대회에서 좋은 성적을 올리기 위한 비결은 당장 빨리 코드를 작성하기보다 읽기 쉬운 코드를 작성하는 것이다.

> 많은 대회 참가자들은 반복적인 연습을 거쳐 자신의 코드 스타일을 간결하고 일관되게 다듬으려고 노력합니다.

---

## 3.2 좋은 코드를 짜기 위한 원칙

이절에서 프로그래밍 대회에서 특히 중요하게 적용되는 원칙들과 예외들을 간략하게 정리합니다.

#### `간결하게 코드 작성하기`

누구나 1000줄짜리 코드보다 100줄짜리 코드를 좋아할것이다.

하지만 여기선 일반 프로젝트에서 사용되는 기법이 아닌 코딩테스트에서만 쓰일 수 있는 기법을 소개한다.

`전역변수` - 코딩테스트는 코드가 그렇게 길지 않기 때문에 전역 변수를 많이 사용한다.

`매크로` (C++ 한정) - 매크로를 통해 코드를 간단하게 줄일 수 있다.
```cpp
#define FOR(i,n) for(int i=0;i<n;i++)

FOR(i,10){
    ...
}
```

> 사실 매크로는 좋은 방법은 아니지만, 실수를 방지할 수 있다는 점이 좋다
>
>```cpp
>for(int i=0;i<n;i++){
>    for(int j=0;j<n;i++) // j++이 정답
>}
>```

---

#### `적극적으로 코드 재사용하기`

같은 코드가 반복된다면 항상 해당 코드를 함수로 분리해 재사용한다는 기본 원칙을 만드는게 좋다.

---

### 표준 라이브러리 공부하기

코딩테스트 대회에서 스택, 큐, 리스트를 직접 만드는 건 바보 같은 짓이다.

시간도 너무 오래걸리고, 예외가 발생할 수 있다.

```cpp
#include<map>
#include<vector>
#include<queue>
```

---
#### `항상 같은 형태로 프로그램을 작성하기`

프로그래밍 대회에 참가하다 보면 여러 종류의 코드를 반복적으로 짜게 된다.

이분법, BF 등등...

이들은 다른 문제를 해결하는 도구로 흔히 이용되기 때문에 매우 자주 작성하게 된다.

자주 작성하는 알고리즘이나 코드 등에 대해서는 한 번 검증된 코드를 작성하고, 이것만을 꾸준히 사용할 필요가 있다.
> 그래야 도구가 아니라 문제에 집중할 수 있다.

#### `일관적이고 명료한 명명법 사용하기`

메서드를 작성할때 직관적으로 해석되는 이름을 짓자.

#### `모든 자료를 정규화해서 저장하기`

분수는 항상 기약분수로 저장하기
> 9/6 => 3/2로 저장

각도는 0~360 or -180~180으로

시간은 UTC

#### `코드와 데이터를 분리하기`

1월부터 12월을 if문으로 처리하지 말고 배열로 저장해놓자

상하좌우 움직이는 것도 if문으로 처리하지 말고 배열로 저장해놓자

---

## 3.3 자주 하는 실수

같은 실수를 반복하기보다는 실수에서 배우는 것이 좋고, 그보다 더 좋은 것은 남의 실수로부터 배워 유사한 실수를 저지르지 않는 것입니다.

이런 의미에서 프로그래밍 대회에 참가한 사람들이 흔히 저지르는 실수 중 대표적인 것들을 소개합니다.

#### `산술 오버플로` 
3.5절에서 계속

#### `배열 범위 밖 원소에 접근`

이문제는 대부분 런타임 에러가 나는데

가끔 안날때가 있다. -> 이떄는 뭐가 문제인지 캐치하기 어려움
> 배열 바로 뒤에 다른 변수가 위치해 있을 때<br>
> 배열 범위를 벗어나면 다른 변수에 접근함 (런타임 에러 안남, 의도치않게 값만 바뀜)

추가로 배열이 0으로 시작하는지, 1로 시작하는지 체크하자

#### `일관되지 않은 범위 표현 방식 사용하기`

[1,12] 처럼 양쪽다 닫힌 구간으로 하거나,<br>
(1,12) 처럼 양쪽다 열린 구간으로 할때 문제

[1,12) 처럼 처음만 닫고 뒤는 열린 구간으로 세팅하자.(half-open interval)

이 방법을 거의다 사용한다.
> n개의 원소를 갖고 있는 배열 a의 첫번째 원손ㄴ a[0]이고 마지막 원소는 a[n-1]이다.
>
> vector.begin() 첫위치를 가리키고, vector.end()는 마지막위치의 다음을 가리킨다.

#### `Off-by-one 오류`

계산의 큰 줄기는 맞지만, 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을 가리킨다.

> 100미터인 담장에 10미터 간격으로 울타리 기둥을 세운다고 하면, 기둥이 몇개 필요할까?<br>
답은 10개가 아닌 11개이다.
>
>배열 a[i]부터 a[j]까지의 평균을 구한다고 하면, 합을 얼마로 나눠야 할까?<br>
답은 j-i가 아니라 j-i+1이다.

Off-by-one 오류는 반복문에서 < 혹은 > 연산자와 =< 혹은 >= 연산자를 혼동하여 원소를 하나 적게, 혹은 많이 순회하는 경우나 반열린 구간과 닫힌 구간을 서로 혼용해 쓴 경우 흔하게 발생한다.

이런 오류를 방지할 수 있는 좋은 방법은 최소 입력이 주어졌을때 이 코드가 어떻게 동작할지를 되새겨 보면서 프로그램을 짜는 것이다.

그리고 최대 입력일때도 생각해봐야 한다.

> 결국 항상 모든 경우의수를 생각하면서 코딩하자

#### `컴파일러가 잡아주지 못하는 상수 오타`

2차원 배열의 그래프 탐색 문제를 풀 때, 이런 코드를 자주 사용한다.

```cpp
int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, 1 , -1, 0};
```

상하좌우를 표시한건데, 여기서 오타가 있다. dy[2]와 dy[3]이 바껴야 한다.

또 알파벳을 잘못써서 원하는대로 답이 나오지 않을때도 있다.

또는 0을 한개 빼먹어서 원하는대로 답이 나오지 않을때도 있다.

> 항상 주의하면서 코딩하자

#### `스택 오버플로`

c++에서 지역 변수로 선언한 배열이나 클래스 인스턴ㄴ스가 기본적으로 스택 메모리를 사용하기 때문에 특히나 스택 오버플로를 조심해야 한다.

이때는 힙에 메모리를 할당하는 STL 컨테이너를 사용하거나 전역 변수를 사용하자

#### `다차원 배열 인덱스 순서 바꿔 쓰기`

나중에 DP에서 이런 일이 잦은데, 이때는 c++의 참조 변수를 사용해 이 문제를 해결한다.

#### `잘못된 비교 함수 작성`

정렬할때 비교 함수 제대로 작성하자.

1. 클때, 작을때 체크
2. 같을때는 어떻게 정렬하는지 체크
3. c++과 자바는 비교함수가 다르다.

#### `최소, 최대 예외 잘못 다루기`

#### `연산자 우선순위 잘못 쓰기`

```cpp 
if(b&i == 0)
```
여기서 ==이 먼저 계산되고 다음으로 &이 계산된다.

우선순위를 주고싶으면 괄호를 해놓자

#### `너무 느린 입출력 방식 선택`

c++에서는 gets()이용해 모든 입력을 문자열 하나로 읽어들인뒤 파싱할 수도 있고,<br>
cin 등의 고수준 입력방식을 사용할 수도 있다.

입출력의 양이 많아진다면 어떤 입출력방식을 쓸지 생각해보자
```cpp
ios::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
```
위 코드로 cin, cout 속도를 높일 수 있다.

#### `변수 초기화 문제`

몇몇 문제는 프로그램을 한번만 실행하고, 한번에 여러개의 입력에 대해 답을 처리하라고 요구한다.

이때 흔한 실수는 이전 입력에서 이용한 전역 변수 값을 초기화하지 않고 그대로 사용하는 것이다.

이런 실수를 방지할 수 있는 팁은 같은 인풋을 똑같이 실행해 보는 것이다.
```
2
1234
231
```

이 입력을

```
4
1234
231
1234
231
```
이렇게 되면 예제 간의 의존 관계 떄문에 우연히 답이 나오는 경우를 방지할 수 있다.

물론 가장 좋은 방법은 처음부터 이를 의식하고 코딩하는 것이다.

`재귀 함수 사용할 때 조심할 점`

dfs를 사용할 때 예시를 보자.

```cpp
int nx; // 위험
void dfs(int n){
    if(n == num) return;

    int len = node[n].size();
    for(int i=0;i<len;i++){
        nx = node[n][i];
        if(visited[nx] == true) continue;
        visited[nx]=true;

        dfs(nx);

        visited[nx]=false; // ?
    }
}
```

이처럼 nx를 전역변수로 선언하면 dfs가 끝나고 visited[nx]를 다시 지워줘야하는데, 재귀 함수에 의해 nx 값이 바뀌어서 원하는결과가 나오지 않을 수 있다.

```cpp
        ...
        int nx = node[n][i]; // 지역변수로 선언해주자
        if(visited[nx] == true) continue;
        ...

```

## 3.4 디버깅과 테스팅

실제 코테에서는 IDE를 사용 못하는 일이 많다.

IDE없이 디버깅과 테스팅을 해봐야 한다.

1. 작은 입력에 대해 제대로 실행되는지 확인하기

2. assert(단정문) 사용해보기: assert는 해당 구문에서 특정 변수의 값이 내가 원하는대로 나왔는지 체크해줄 수 있다.
    > 함수에서 넘겨받은 인자들이 범위 안에 들어 있는지, 값들은 제대로 입력받았는지 검사
3. 프로그램 중간 결과를 출력해주기

`스캐폴딩`(scaffolding)이란 기법이 있다.<br>
건물을 짓거나 보수할때 공사하는 사람들이 걸어다니기 위해 설치하는 임시구조물

프로그램도 이 프로그램이 잘돌아가는지 다른 프로그램과 비교해볼수 있다.

> dp로 구현했다면, 그냥 브루트포스로 구현했을때랑 답을 비교하는것

근데 시간이 없으면 이건 스킵

## 3.5 변수 범위의 이해

### `산술 오버플로`

컴퓨터에서 변수에 담을 수 있는 수의 범위는 제한되어 있다.

자료형이 표현 가능한 범위를 벗어날 수 있다.<br>
이러한 이유는 크게 두가지가 있다.

1. 대부분의 프로그래밍 언어는 연산 과정에서 오버플로가 나더라도 별다른 경고를 해주지 않는다.
2. 프로그램 논리의 정확성에만 집중하면 산술 오버플로가 등장할 수 있다는 사실을 잊기 쉽다.

이제부터 산술 오버플로가 나는 대표적인 경우를 살펴보겠다.

#### `너무 큰 결과`

64비트 정수를 사용해야 하는데 습관적으로 32비트 정수를 사용했을때

#### `너무 큰 중간값`

프로그램의 출력 값의 범위는 작지만, 중간 과정에서 큰 값을 일시적으로 계산해야 하는 경우
> 이거 실수 진짜 많이 한다.

주의하자

#### `애매한 '무한대' 값`

프로그램을 짜다보면 max, min을 비교해야 할일이 많다.

그래서 처음에는 max는 매우 작은 값을, min에는 매우 큰 값을 넣어줘야 하는데 이때 실수를 많이한다.

처음부터 나올 수 있는 최댓값, 최솟값을 생각해놓자.

그리고 max값에 사칙연산을 했을때 오버플로가 발생할 수 있다.

INT_MAX + 1 < 10 ? 

INT_MAX에 1을 더해주면서 마이너스가 나오게 된다.

> 이 책의 저자는 987654321을 자주 이용한댄다. 2^30에 가깝고 오버플로 잘 안일어나니까, 그리고 오타확인이 쉬우니까

### `자료형의 프로모션`

연산을 할때, 피연산자의 자료형이 다르다면 자동으로 변환되는데,<br>
c++의 자료형의 경우 다음과 같다.

1. 한쪽이 정수형이고 한쪽이 실수형 - 정수형이 실수형으로
2. 양쪽다 정수형 or 실수형 - 보다 넓은 범위를 갖는 자료형으로
3. 양쪽다 int형보다 작은 정수형인 경우 - 둘다 int형으로
4. 부호없는 정수형과 부호있는 정수형 - 부호없는 정수형으로 통일

int + unsigned int => unsigned int + unsigned int

이러면 마이너스가 플러스될 수 있음

### `실수 자료형`

실수형에 대한 연산을 진행할때는 항상 주의해야 한다.

방지할 방법들

1. 비교할 실수들 크기들에 비례한 오차 한도를 정한다.
2. 그냥 실수를 정수로 변환하여 계산한다.

> 2가 가장 좋다.<br>
$sqrt((x1-x2)^2+(y1-y2)^2) = r$<br>
두 점사이의 거리를 확인하는 건데, 루트를 씌우지 말고 양변에 제곱을 해줘서 실수가 안나오게 하면 좋다.
