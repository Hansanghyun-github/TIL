# 10 탐욕법

    탐욕적 선택 속성(greedy choice property)
    동적 계획법처럼 답의 모든 부분을 고려하지 않고 탐욕적으로만 선택하더라도 최적해를 구할 수 있다는 것

    최적 부분 구조
    항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있음

    위 두가지를 증명해야 탐욕법을 적용할 수 있다.
    (최적 부분 구조는 대부분 자명해서 증명할 필요가 없다고 한다.)



탐욕법은 가장 직관적임 알고리즘 설계 패러다임 중 하나입니다. 탐욕법을 이용한 알고리즘은 우리가 원하는 답을 재귀 호출과 똑같이 여러 개의 조각으로 쪼개고, 각 단계마다 답의 한 부분을 만들어 간다는 점에서 완전 탐색이나 동적 계획법 알고리즘과 다를 것이 없습니다.

그러나 모든 선택지를 고려해 보고 그중 전체 답이 가장 좋은 것을 찾는 두 방법과 달리, 탐욕법은 각 단계마다 지금 당장 좋은 방법만을 선택합니다.

탐욕법은 `지금의 선택이 앞으로 남은 선택들에 대해 어떤 영향을 끼칠지는 고려하지 않습니다`.

이 알고리즘은 많은 경우 최적해를 찾지 못합니다. 따라서 탐욕적 알고리즘이 사용되는 경우는 크게 다음 두가지로 제한됩니다.

1. 탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제를 만난 경우, 탐욕법은 동적 계획법보다 수행 시간이 훨씬 빠르기 때문에 유용합니다.

2. 시간이나 공간적 제약으로 인해 다른 방법으로 최적해를 찾기 너무 어렵다면 최적해 대신 적당히 괜찮은 답(근사해)을 찾는 것으로 타협할 수 있습니다.

    프로그래밍 대회에서는 1번 용도로만 사용됩니다.

탐욕법은 개념은 간단하지만 사실 프로그래밍 대회에서 가장 많은 참가자들의 발목을 붙잡는 주제중 하나입니다. 한 문제를 탐욕적으로 해결하는 방법이 한가지만 있는 것이 아닌 경우도 많은데, 이 중 어느 방법을 선택해야 최적해를 구할 수 있을지를 알아내기가 어렵기 때문이죠. 

    실제로 최적해를 얻을 수 있는 접근이 직관적이지 않은 경우도 많기 때문에 실수에 더 유의해야 합니다.
    그러니 탐욕적 알고리즘을 연습 문제를 풀때는 알고리즘의 정당성을 증명하는 과정을 빼먹지 않고 연습하는 것이 좋습니다.

탐욕법이 유용하게 사용되는 문제 중 유명한 예로 활동 선택 문제가 있습니다.

`예제: 회의실 예약`

회사에 회의실이 하나밖에 없는데, n개의 팀이 각각 회의하고 싶은 시간이 있을때, 두 팀이 회의실을 같이 쓸수는 없기 때문에 이 중 서로 겹치지 않는 회의들만을 골라내서 진행해야 합니다. 몇개나 선택할 수 있을까요?

`무식하게 풀 수 있을까?`

이 문제를 무식하게 푸는 방법은 모든 부분 집합을 하나하나 만들어 보며 그중 회의들이 겹치지 않는 답들을 걸러내고 그중 가장 큰 부분 집합을 찾아냅니다.

이때 이 알고리즘의 시간복잡도는 $O(2^n)$이라 n이 30이 되어도 시간안에 문제를 풀기는 힘듭니다.

`탐욕적 알고리즘의 구상`

이런 문제를 `탐욕적으로` 해결하는 방법을 몇 가지 떠올릴 수 있습니다.

이 문제를 해결하는 탐욕적인 방법은 길이와 상관없이 가장 먼저 끝나는 회의부터 선택하는 것입니다. 가장 먼저 끝나는 회의를 선택하고, 이 회의와 겹치는 것들을 모두 지운 뒤 다시 이 중에서 가장 먼저 끝나는 회의를 선택하기를 반복하는 것이죠.

1. 목록 S에 남은 회의 중 가장 일찍 끝나는 회의 $S_{min}$를 선택한다.
2. $S_{min}$과 겹치는 회의를 S에서 모두 지운다.
3. S가 텅빌때까지 반복한다.

`정당성의 증명: 탐욕적 선택 속성`

탐욕적 알고리즘의 정당성 증명은 많은 경우 일정한 패턴을 가집니다. 이 증명 패턴은 탐욕적인 알고리즘이 항상 최적해를 찾아낼 수 있다는 것을 두가지의 속성을 증명함으로써 보입니다.

우리가 처음으로 증명해야 할 속성은 `동적 계획법처럼 답의 모든 부분을 고려하지 않고 탐욕적으로만 선택하더라도 최적해를 구할 수 있다는 것`입니다.<br>
이 속성은 매우 중요하기 때문에 따로 이름을 붙여 탐욕적 선택 속성(greedy choice property)이라고 부릅니다.

    어떤 알고리즘에 이 속성이 성립할 경우, 우리가 각 단계에서 탐욕적으로 내리는 선택은 항상 최적해로 가는 길 중 하나입니다.
    따라서 탐욕적인 선택을 해서 손해를 볼일이 없다는 것을 알 수 있습니다.

이 문제에서 제안한 알고리즘에서 탐욕적 선택 속성이 성립한다는 말은 다음 조건이 성립한다는 의미입니다.

가장 종료 시간이 빠른 회의($S_{min}$)를 포함하는 최적해가 반드시 존재한다.

// 증명은 책에 있음 - 그냥 위 조건이 아닐 때 최적해가 존재하지 않음을 증명함, 약간 귀류법 같은?

`최적 부분 구조`

이렇게 탐욕적인 방법으로 선택하는 것이 항상 최적의 답을 줄 수 있다고 해서 증명이 끝난 것은 아닙니다. `항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있음`을 보여야 합니다.

다행히 이 속성은 대개 매우 자명해서 따로 증명할 필요가 없는 경우가 대부분입니다.

`구현`

이 알고리즘을 쉽고 빠르게 구현하는 한 방법은 모든 회의를 종료 시간의 오름차순으로 정렬해 두는 것입니다.

```cpp
vector<pair<int,int>> order; // {끝나는 시간, 시작하는 시간}

sort(order.begin(), order.end()); 

int earliest = 0, selected = 0;
for(pair<int,int> it: order){
    if(it.second >= earliest){
        earliest = it.first;
        ++selected;
    }
}

return selected;
```

이 알고리즘은 O(nlgn) 시간이 걸리는 정렬 후에 선형 시간만이 걸리는 선택 과정을 통해 최적해를 찾아냅니다.

    이 문제는 동적 계획법으로도 풀 수 있습니다.

    schedule(idx) = meeting[idx] 혹은 그 이전에 끝나는 회의들 중 선택할 수 있는 최대 회의의 수

    사실 이 문제만이 아니라 탐욕법으로 최적해를 찾을 수 있는 많은 문제들은 동적 계획법으로 풀 수 있습니다. 
    탐욕법으로 최적해를 찾을 수 있다는 말은 지금 한 단계만을 고려해도 답을 찾을 수 있다는 의미입니다.
    (동적 계획법은 모든 단계를 고려하기 때문이죠)

    많은 경우 동적 계획법이 아닌 탐욕법을 사용하는 이유는 동적 계획법에 필요한 메모리나 시간이 과도하게 크기 때문입니다.

---

`예제: 출전 순서 정하기`

A팀과 B팀에 n명의 선수가 있다. 각 선수마다 레이팅이 있고, 레이팅에 따라서 승패가 갈린다.<br>
B팀 선수들의 출전 명단이 주어졌을때, A팀 선수들을 적절히 배치해서 최대 몇승을 할 수 있을까?

`무식하게 풀 수 있을까?`

n!개의 답이 있습니다. - 너무 무식함

`동적 계획법은 어떨까?` - $O(n*2^n)$이라서 불가능

`탐욕적 알고리즘의 구상`

탐욕적 알고리즘을 설계하는 좋은 방법은 간단한 입력을 몇 개 손으로 풀어 보면서 패턴을 찾는 것입니다.

여기서 사용하는 탐욕법은,<br>
상대방 선수를 이길 수 있는 선수가 있다면, 그 중에서 레이팅이 가장 낮은 선수를 보내는 것입니다.<br>
이길 수 있는 선수가 없다면, 역시 레이팅이 가장 낮은 선수를 보내는 것입니다.

`탐욕적 선택 속성 증명` - 반대를 가정하고, 그게 안됨을 증명

---

`탐욕적 알고리즘 레시피`

1. 문제의 답을 만드는 과정을 여러 조각으로 나눕니다.
2. 각 조각마다 어떤 우선순위로 선택을 내려야 할지 결정합니다. 이에 대한 직관을 얻기 위해서는 예제 입력이나 그 외에 작은 입력을 몇 개 손으로 풀어보는 것이 효율적입니다.
3. 어떤 방식이 동작할 것 같으면 두 가지의 속성을 증명합니다. - 탐욕적 선택 속성, 최적 부분 구조

    a) 탐욕적 선택 속성: 항상 각 단계에서 우리가 선택한 답을 포함하는 최적해가 존재함을 보이면 됩니다. 이 증명은 대개 우리가 선택한 답과 다른 최적해가 존재함을 가정하고, 이것을 조작해서 우리가 선택한 답을 포함하는 최적해로 바꿀 수 있음을 보이는 형태로 이루어집니다.

    b) 최적 부분 구조: 각 단계에서 항상 최적의 선택만을 했을 때 전체 최적해를 구할 수 있는지 여부를 증명합니다. 다행히도 대개의 경우 이 속성이 성립하는지 아닌지는 자명하게 알 수 있습니다.

## 10.2 문제: 도시락 데우기

n개의 정보가 있다 - 도시락을 데울 때 필요한 시간, 그 도시락을 먹는데 필요한 시간<br>
전자레인지는 1개라서 1개의 도시락만 데울 수 있다. 도시락을 데운 뒤에 바로 먹는다고 가정했을때, 최소 몇초의 시간이 필요한가?

>3<br>
>1 2 3<br>
>1 2 1
>
>답: 7

---

## 10.3 풀이: 도시락 데우기

이런 형태의 스케쥴링 문제는 탐욕법 문제의 단골 손님입니다.

`탐욕적 알고리즘의 구상`

데우는 시간과는 관련 없이 먹는 데 오래걸리는 도시락부터 정답일 것 같습니다.

`탐욕적 선택 속성 증명` - 먹는 데 가장 오래걸리는 도시락을 처음에 뒀을 때가 최적해임을 증명하면 된다.

> 가장 오래걸리는 도시락을 마지막으로 두고 비교해보자

`최적 부분 구조 증명`

첫번째 도시락을 정하고 나면 나머지 도시락들을 배치해야 합니다. 이때 각 도시락을 다 먹기까지 걸리는 시간은 첫번쨰 도시락을 데우는 시간만큼 지연되지만, 남은 도시락에 대해서도 가장 늦게 다 먹는 시간을 최소화해서 손해 볼것은 없습니다. 따라서 매 단계마다 최적의 선택을 해도 상관 없다는 사실을 알 수 있습니다.

`구현`

```cpp
int n, e[MAX_N], m[MAX_N];
int heat(){
    vector<pair<int,int>> order;
    for(int i=0;i<n;i++)
        order.push_back(make_pair(-e[i], i)); // 음수로 바꿔서 먹는데 걸리는 시간의 내림차순을 정렬되게 함
    sort(order.begin(), order.end());

    int ret = 0, beginEat = 0;
    for(int i=0;i<n;i++){
        int box = order[i].second;
        beginEat += m[box]; // 데우는 데 걸리는 시간 추가
        ret = max(ret, beginEat + e[box]); // 이전 도시락을 먹는 시간이랑, 다음 도시락을 데우고 먹는 시간과 비교한다
    }
    return ret;
}
```

전체 시간복잡도: $O(nlog)n$

---

## 10.4 문제: 문자열 합치기

문자열을 합치는 함수인 strcat(str1, str2)의 시간복잡도는 str1의 길이+str2의 길이이다.<br>
n개의 문자열이 주어졌을때, 이 문자열들을 모두 합치는 데 걸리는 최소 시간을 구하라.(아무렇게 합쳐도 됨)

## 10.5 풀이: 문자열 합치기

`탐욕적 알고리즘의 구상`

한 문자열이 전체 비용에 미치는 영향을 살펴봅시다. 

한 문자열로 인해 발생하는 총 비용은 이 문자열이 병합되는 횟수에 문자열의 길이를 곱한 것이라는 사실을 알 수 있습니다.

`알고리즘 설계하기`

탐욕적 알고리즘은 문제의 답을 여러 조각으로 나눠 한 조각마다 한 가지의 선택을 합니다. 이 문제에서는 한 조각마다 두 문자열을 서로 합치는 것으로 합시다.

문자열 목록에서 두개를 골라내고, 이들을 합친 뒤 다시 문자열 목록에 추가하는 과정을 반복하는 것입니다.

문자열이 길면 길수록 나중에 합쳐야 유리하다는 점이 있습니다. 이는 '항상 짧은 두개의 문자열을 합치는 것이 어떨까'라는 생각을 할 수 있습니다.

`정당성 증명`

이 선택이 최적해로 가는 길임을 증명하려면, 이 선택을 포함하는 (가장 짧은 두개의 문자열을 합치는) 최적해가 반드시 있음을 보여 주면 됩니다.

// 책에서 증명함

`구현`

우리가 만든 탐욕적 알고리즘은 문자열 길이의 목록을 유지하면서 최소 길이를 골라내고, 새 길이를 추가하는 과정을 반복합ㄴ디ㅏ.

이와 같은 동작을 가장 효율적으로 구현해주는 것이 '우선순위 큐'입니다.

우선순위 큐는 집합에서 가장 작은 원소를 찾거나, 새 원소를 추가하는 작업을 모두 O(lgn)에 할 수 있도록 해 줍니다.

---

`이론적 배경: 허프만 코드`

이 문제는 사실 탐욕적 알고리즘의 유명한 예인 '허프만 코드 알고리즘'을 각색한 것입니다.