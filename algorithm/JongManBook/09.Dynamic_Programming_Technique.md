# 9 동적 계획법 테크닉

이 장에서는 동적 계획법으로 풀 수 있는 여러 문제들과 다양한 기법들에 대해 다룹니다.

## 9.1 최적화 문제의 실제 답 계산하기

LIS 문제에서 해당 수열의 길이를 찾는 것이 아니라 가장 긴 부분 수열의 원소를 출력하라 한다면 어떻게 해야 할까요?

`예제: 최대 증가 부분 수열 실제로 출력하기`

맨 처음 떠오르는 방법은 lis()이 LIS의 길이 대신 실제 LIS의 원소를 담는 배열을 반환하도록 하는 것

이렇게 하면, 모든 부분 문제마다 최적해를 저장해야 하니 느리고 메모리를 많이 차지하는 데다 번거롭다는 문제가 있습니다.

떄문에 대게 동적 계획법을 사용하는 코드에서는 실제 답을 계산하는 과정을 별도로 구현합니다.

우리는 부분 문제가 주어질 때 그중 첫 번째 조각을 어떤 선택지로 채울지 하나하나 시도하면서 최적해를 찾습니다. 실제 답을 계산하기 위해서는 각 부분문제마다 어떤 선택지를 택했을 때 최적해를 얻는지를 기록해 두고, 별도의 재귀함수를 이용해 각 조각에서 한 선택을 되짚어 가면서 최적해를 생성해 내면 됩니다.

```cpp
int n;
int cache[101], S[100], choices[101];
int lis(int start){
    int& ret = cache[start+1];
    if(ret != -1) return ret;

    ret = 1;
    int bestNext = -1;
    for(int next = start+1;next < n; ++next){
        if(start == -1 || S[start] < S[next]){
            int cand = list(next) + 1;
            if(cand > ret){
                ret = cand;
                bestNext = next; // 최적해를 구한 위치를 저장해놓는다.
            }
        }
    }
    choices[start+1] = bestNext; // 최적해를 구한 위치를 저장해놓는다.
}

void reconstruct(int start, vector<int>& seq){
    if(start != -1) seq.push_back(S[start]);
    int next = choices[start+1];
    if(next != -1) reconstruct(next, seq);
}
```

---

`최적화 문제 답 계산하기 레시피`

1. 재귀 호출의 각 단계에서 최적해를 만들었던 선택을 별도의 배열에 저장해둡니다.

2. 별도의 재귀 함수를 이용해 이 선택을 따라가며 각 선택지를 저장하거나 출력합니다.

## 9.2 문제: 여행 짐 싸기

n개의 부피와 절박도가 주어졌을때, 전체 부피의 합이 w이하 일때 최대 절박도가 몇인지 구하는 문제

그냥 배낭 문제

## 9.3 풀이: 여행 짐 싸기

물건의 모든 조합을 하나하나 검사하고 이들 중 최적의 조합을 찾아내는 완전 탐색 알고리즘을 작성해 봅시다. <br>
이 알고리즘의 시간복잡도는 $O(2^n)$ (물건을 가져가거나 안가져가거나)

pack(items) = 지금까지 고른 물건들의 목록이 items에 주어질때, 남은 용량을 채워 얻을 수 있는 최대의 절박도 합

이때 물건들의 리스트를 일일이 전달하지 않고, 현재 남은 용량과 마지막으로 선택한 물건의 번호를 인자로 받으면 간단해집니다.

pack(capacity, item) = 캐리어에 용량이 capacity만큼 남았을때, item 이후의 물건들을 싸서 얻을 수 있는 최대 절박도를 반환

이때 각 물건에 대해 우리가 할 수 있는 선택은 가져간다/가져가지 않는다의 둘입니다.<br>
각 경우의 최대 절박도를 다음과 같이 계산할 수 있지요.

해당 물건을 가져가는 경우: pack(capacity-volume[item], item+1) + need[item]

가져가지 않는 경우: pack(capacity, item+1)

pack()은 두 선택지 중 항상 더 큰답을 택하면 됩니다.

```cpp
int pack(int capacity, int item){
    //base case
    if(item == n) return 0;

    int& ret = cache[capacity][item];
    if(ret != -1) return ret;

    ret = pack(capacity, item+1);
    if(capacity >= volume[item])
        ret = max(ret, pack(capacity-volume[item], item+1) + need[item]);

    return ret;
}
```

이 알고리즘의 시간복잡도는 $O(nw)$입니다.

`답 추적하기`

각 부분 문제의 선택지가 두가지 밖에 없기 때문에 따로 선택을 저장하지 않고도 답을 역추적할 수 있습니다.

pack(capacity, item)에서 item을 선택했는지를 알고싶다면, pack(capacity, item+1)과 pack(capacity, item)이 같은지 비교하면 됩니다.

    만약 두 값이 같다면 item을 선택하지 않고도 최대 절박도를 얻을 수 있다는 말이니 item을 무시하고, 아니면 목록에 item을 추가합니다.

```cpp
void reconstruc(int capacity, int item, vector<string>& picked){
    if(item == n) return;
    if(pack(capacity, item) == pack(capacity, item+1)){ // 해당 item 안가져갔음
        reconstruct(capacity, item+1, picked);
    }
    else{ // 해당 item 가져갔음
        picked.push_back(name[item]);
        reconstruct(capacity - volume[item], item+1, picked);
    }
}
```

## 9.6 k번째 답 계산하기

`예제: 모스 부호 사전`

모스 부호란 짧은 신호(단점, o)와 긴 신호(장점, -)를 섞어 글자를 표현하는 표현 방식입니다.

n개의 장점과 m개의 단점으로 구성된 신호가 있을때, 이때 k번째 신호를 출력하는 프로그램을 작성해보자

`모든 신호 만들기`

```cpp
void generate(int n, int m, string s){
    if(n == 0 && m == 0){
        cout << s << '\n';
        return;
    }
    if(n > 0) generate(n-1, m, s+"-");
    if(m > 0) generate(n, m-1, s+"o");
}
```

`k-1개 건너뛰기`

다음 단계는 모든 신호를 출력하는 대신 k번쨰 신호만을 출력하는 코드를 작성하는 것입니다.<br>
사전순으로 모든 신호를 생성하면서 k-1개를 건너뛰고 첫 번째 것을 출력하는 코드를 작성하면 됩니다.

```cpp
int skip;
void generate2(int n, int m, string s){
    if(skip < 0) return;

    if(n == 0 && m == 0){
        if(skip == 0) cout << s << '\n';
        skip--;
        return;
    }
    if(n > 0) generate(n-1, m, s+"-");
    if(m > 0) generate(n, m-1, s+"o");
}
```

이때 전역변수 skip은 k-1로 초기화됩니다.

`좀 더 똑똑하게 건너뛰기`

k가 크다면 여전히 시간 안에 답을 찾을 수 없습니다.<br>
이때야말로 각 경우의 답을 세는 동적 계획법이 유용하게 쓰입니다.

    generate2(n,m,s)가 호출되었을때, 재귀 호출 과정에서 앞으로 만들어질 신호는 몇개일까요?

    이들을 조합할 수 있는 방법은 이항계수로 표현할 수 있습니다.
    $n+m \choose n$

    이때 skip이 $n+m \choose n$과 같거나 크다면, generate2(n,m,s)가 종료할 때 skip은 $n+m \choose n$만큼 줄어 잇고, 답은 아직 못찾은 상태이다.

    그렇다면 실행할 필요없이 skip만 줄여버리고 종료해도 똑같은 결과가 된다.

    -> 이항계수를 미리 계산해 놓는다.

```cpp
int bino[201][201];

// 필요한 이항계수를 미리 계산해 둔다.
void calcBino(){
    memset(bino, 0, sizeof(bino));
    for(int i=0;i<=200;i++>{
        bino[i][0] = bino[i][i] = 1;
        for(int j=1;j<i;j++)
            bino[i][j] = bino[i-1][j-1] + bino[i-1][j];
    })
}

// skip개를 건너뛰고 출력한다.
int skip;
void generate3(int n, int m, string s){
    if(skip < 0) return;

    if(n == 0 && m == 0){
        if(skip == 0) cout << s << '\n';
        skip--;
        return;
    }

    if(bino[n+m][n] <= skip){
        skip -= bino[n+m][n];
        return ;
    }

    if(n > 0) generate(n-1, m, s+"-");
    if(m > 0) generate(n, m-1, s+"o");
}
```

이 코드는 신호의 수를 미리 계산하는 calcBino()와 실제 신호를 재구성하는 generate3()의 두 함수로 나뉩니다.

이 알고리즘은 k번째 신호 외에 어떤 신호도 완전히 만들지 않기 때문에, 시간복잡도는 O(n+m)이 됩니다.<br>
이 외로 처음에 각 이항계수를 미리 계산해 두는 데는 O(nm)이 걸리기 떄문에,<br>
전체 시간 복잡도는 O(nm)이 됩니다.

---

`k번째 답 계산하기 레시피`

1. 답들을 사전순서대로 만들며 경우의 수를 세는 완전 탐색 알고리즘을 설계하고, 메모이제이션을 적용해 경우의 수를 세는 동적 계획법 알고리즘으로 바꿉니다.

2. 모든 답들을 사전순으로 생성하며 skip개를 건너뛰고 첫번째 답을 반환하는 재귀 호출 함수를 구현합니다. 재귀 함수는 각 조각들에 들어갈 수 있는 값을 하나씩 고려하면서 이 값을 선택했을 때 만들어지는 답의 수 M과 건너뛰어야 할 답의 수 skip을 비교합니다.
    
    a) M <= skip: M개의 답은 모두 우리가 원하는 답보다 앞에 있으므로, 이들을 건너뜁니다. 대신 skip을 M만큼 줄입니다.
    
    b) M > skip: M개의 답 중에 우리가 원하는 답이 있으므로, 이 값을 선택합니다. M개의 답 중에 skip개를 건너뛴것이 우리가 원하는 답입니다. 이값을 답에 추가하고 재귀 호출로 답의 나머지 부분을 만듭니다.
