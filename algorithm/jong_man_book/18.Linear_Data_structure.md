# 18 선형 자료 구조

일려로 늘어선 같은 종류의 자료 여러개를 저장하기 위한 자료 구조는 `동적 배열`과 `연결리스트`입니다.

---

`동적 배열`

동적으로 삽입/삭제가 가능하지만, 결국 배열을 이용하기 때문에 처음 배열의 크기를 잘 선언해야 합니다.

`동적 배열의 재할당 전략`

데이터를 삽입할때 공간이 부족하다면 동적 배열은 재할당을 합니다. 이때 재할당을 하면 기존의 배열을 그대로 복사해야 하기 때문에 선형 시간이 걸립니다. 따라서 재할당을 최소화해야합니다.

상수 시간에 append()를 구현하는 비결은 재할당을 할 때마다 정해진 개수의 여유분을 확보하는 것이 아니라, 현재 가진 원소의 개수에 비례해서 여유분을 확보하는 것입니다.

    1, 2, 4, 8, 16, ...

이때 일어나는 총 복사의 수는 1+2+4+...+8192=16383입니다. 기존 정해진 크기를 재할당 한다면 최대 50만번이 일어나는데, 이에 비해 놀랍도록 줄어든 것을 알수 있습니다.

이런 재할당 전략을 쓸때 i번 재할당 시에 복사하는 원소의 수는 2^i입니다.

그러면 1번부터 k-1번까지 재할당하는 원소의 수의 합은 k번 재할당 했을때의 원소와 같다고 할 수 있습니다.

그런데 마지막 재할당에서 복사하는 원소의 수는 2^{k-1}이 O(n)이 되기 때문에, append() 연산을 n번 실행하는 총 수행 시간이 O(n)이라면, 한번의 append() 연산에 드는 시간은 평균적으로 O(1)이라고도 할 수 있습니다.

---

이와 같이 배열의 용량이 꽉 찼을 때 이것을 어떻게 증가시키느냐, 반대로 배열의 크기가 용량에 비해 많이 줄어들었을 때 용량을 어떻게 줄이느냐 등의 전략은 동적 배열의 효율성에 큰 영향을 미칩니다.

---

`연결리스트`

배열과 달리, 데이터와 다음 데이터를 가리키는 포인터를 가지고 있다

-> 중간에 원소를 삽입/삭제하는데 상수시간이 걸림

-> 특정 원소에 접근하는데 비효율적


---

`정리`

중간 위치에 원소삽입/삭제 잦으면 연결리스트 사용

임의의 위치의 원소 자주 찾는다면 동적 배열 사용