# 리팩터링, 테스팅, 디버깅

> 이 장의 내용
>
> 1. 람다 표현식으로 코드 리팩터링하기
> 2. 람다 표현식이 객체지향 설계 패턴에 미치는 영향
> 3. 람다 표현식 테스팅
> 4. 람다 표현식과 스트림 API 사용코드 디버깅

## 9.1 가독성과 유연성을 개선하는 리팩터링

9-1에서 지금까지 공부한 람다, 메서드 참조, 스트림 등의 기능을 이용해서 더 가독성이 좋고 유연한 코드로 리팩터링하는 방법을 알아본다.

### 9.1.1 코드 가독성 개선

일반적으로 코드 가독성이 좋다는 것은 '어떤 코드를 다른 사람도 쉽게 이해할 수 있음'을 의미한다.

즉 코드 가독성을 개선한다는 것은 `우리가 구현한 코드를 다른 사람이 쉽게 이해하고 유지보수할 수 있게 만드는 것`을 의미한다.

코드 가독성을 높이려면 코드의 문서화를 잘하고, 표준 코딩 규칙을 준수하는 등의 노력을 기울여야 한다.

### 9.1.2 익명 클래스를 람다 표현식으로 리팩터링하기

```java
Runnable r1 = new Runnable(){ // 익명 클래스 사용
    public void run(){
        System.out.println("Hello");
    }
};

Runnable r2 = () -> System.out.println("Hello"); // 람다 표현식 사용
```

r1과 r2를 보면 알 수 있듯이, 익명 클래스대신 람다 표현식을 사용해서 간결하고, 가독성이 좋은 코드를 구현할 수 있다.

`하지만 모든 익명 클래스를 람다 표현식으로 변환할 수 있는 것은 아니다.`

첫째, 익명 클래스에서 사용한 this와 super는 람다 표현식에서 다른 의미를 갖는다.<br>
익명 클래스에서 this는 익명클래스 자신을 가리키지만, 람다에서 this는 람다를 감싸는 클래스를 가리킨다.

둘째, 익명클래스는 감싸고 있는 클래스의 변수를 가릴 수 있다.(섀도 변수)<br>
하지만 람다 표현식으로는 변수를 가릴 수 없다.

```java
int a = 10;
Runnable r1 = new Runnable(){
    public void run(){
        int a=2; // 잘 작동한다.
        System.out.println(a);
    }
};

Runnable r2 = () -> {
        int a = 2; // 컴파일 에러
        System.out.println(a);
    }
```

마지막으로, 익명 클래스를 람다 표현식으로 바꾸면 콘텍스트 오버로딩에 따른 모호함이 초래될 수 있다.

```java
public static void doSomething(Runnable r){ r.run(); }
public static void doSomething(Task t){ t.excute(); } // Task는 excute 메서드를 갖고 있는 함수형 인터페이스
```

익명 클래스는 직접 인스턴스화할 때 명시적으로 형식이 정해지는 반면 람다의 형식은 콘텍스트에 따라 달라지기 때문에 모호하다.
> ```doSomething(() -> System.out.println("Hello")) // 어떤 함수를 실행하는 거지?```

여기서 명시적 형변환을 이용해서 모호함을 제거할 수 있다.
> ```doSomething((Task)() -> System.out.println("Hello"))```

### 9.1.3 람다 표현식을 메서드 참조로 리팩터링하기

람다 표현식 대신 메서드 참조를 이용하면 가독성을 높일 수 있다.

메서드 참조의 메서드 명으로 코드의 의도를 명확하게 알릴 수 있기 때문이다.

### 9.1.4 명령형 데이터 처리를 스트림으로 리팩터링하기

아래 코드를 보자

```java
List<String> dishNames = new ArrayList<>();
for(Dish dish: menu){
    if(dish.getCalories() > 300)
        dishNames.add(dish.getName());
}
```

이 코드는 menu의 음식들중 칼로리가 300을 넘는 음식의 이름만 dishNames에 저장하는 코드이다.

이 코드는 두가지 패턴(필터링과 추출)으로 엉킨 코드다.<br>
게다가 이 코드를 병렬로 실행시키는 것은 매우 어렵다.
> dishNames에 add하는 건 상태가 전이 되기 때문에 병렬로 실행시키기 어려움

스트림 API를 이용하면 문제를 더 직접적으로 기술할 수 있을 뿐 아니라 쉽게 병렬화할 수 있다.

```java
menu.parallelStream()
    .filter(d -> d.getCalories > 300)
    .map(Dish::getName)
    .collect(Collectors.toList());
```

### 9.1.5 코드 유연성 개선

`함수형 인터페이스 사용`

동작 파라미터화를 이용하면 변화하는 요구사항에 대응할 수 있는 코드를 구현할 수 있다.

```java
if(logger.isLoggable(Log.FINER))
    logger.finer("Problem: "+generateDiagnostic());
```

위 코드를 아래 코드로 변환하면

```java
public void log(Level level, Supplier<String> msgSupplier){
    if(logger.isLoggable(Log.FINER))
        log(level, msgSupplier.get()); // 람다 실행
}

logger.log(Level.FINER, () -> "Problem: "+generateDiagnostic());
```

불필요한 if문을 제거하고 logger의 상태를 노출할 필요도 없다.

그리고 람다 표현식을 이용해서 특정 조건(logger의 레벨이 FINER일떄)에서만 메세지가 생성될 수 있도록 메시지 생성 과정을 `연기`할 수 있다.

`실행 어라운드`

또한 실행 어라운드 패턴을 람다로 변화해, 준비, 종료 과정을 처리하는 로직을 재사용함으로써 코드 중복을 줄일 수 있다.

## 9.2 람다로 객체지향 디자인 패턴 리팩터링하기

다양한 패턴을 유형별로 정리한 것이 `디자인 패턴`이다.<br>
디자인 패턴은 공통적인 소프트웨어 문제를 설계할 때 재사용할 수 있는, 검증된 청사진을 제공한다.

람다를 이용하면 이전에 디자인 패턴으로 해결하던 문제를 더 쉽고 간단하게 해결할 수 있다.

> 아직 디자인 패턴을 잘 모르기 때문에 이부분은 일단 넘어감...

### 9.2.1 전략

전략 패턴은 한 유형의 알고리즘을 보유한 상태에서 런타임에 적절한 알고리즘을 선택하는 기법이다.

### 9.2.2 템플릿 메서드

알고리즘의 개요를 제시한 다음에 알고리즘의 일부를 고칠 수 있는 유연함을 제공해야 할 때 템플릿 메서드 디자인 패턴을 사용한다.
> `이 알고리즘을 사용하고 싶은데 그대로는 안 되고 조금 고쳐야 하는` 상황에 적합하다.

### 9.2.3 옵저버

어떤 이벤트가 발생했을 때 한 객체가 다른 객체 리스트에 자동으로 알림을 보내야 하는 상황에서 옵저버 디자인 패턴을 사용한다.

### 9.2.4 의무 체인

작업 처리 객체의 체인(동작 체인 등)을 만들 때는 의무 체인 패턴을 사용한다.

### 9.2.5 팩토리

인스턴스화 로직을 클라이언트에 노출하지 않고 객체를 만들 때 팩토리 디자인 패턴을 사용한다.

## 9.3 람다 테스팅

일반적으로 좋은 소프트웨어 공학자라면 프로그램이 의도대로 동작하는지 확인할 수 있는 단위 테스팅을 진행한다.

### 9.3.1 보이는 람다 표현식의 동작 테스팅

그냥 함수형 인터페이스 검증하는 것

### 9.3.2 람다를 사용하는 메서드의 동작에 집중하라

람다의 목표는 정해진 동작을 다른 메서드에서 사용할 수 있도록 하나의 조각으로 캡슐화하는 것이다.

람다 표현식을 사용하는 메서드의 동작을 테스트함으로써 람다를 공개하지 않으면서도 람다 표현식을 검증할 수 있다.

### 9.3.3 복잡한 람다를 개별 메서드로 분할하기

## 9.4 디버깅

문제가 발생한 코드를 디버깅할 때 개발자는 다음 두 가지를 가장 먼저 확인해야 한다.
- 스택 트레이스
- 로깅

하지만 람다 표현식과 스트림은 기존의 디버깅 기법을 무력화한다.

### 9.4.1 스택 트레이스 확인

`람다와 스택 트레이스`

유감스럽게도 람다 표현식은 이름이 없기 때문에 조금 복잡한 스택 트레이스가 생성된다.

```java
at Debugging.lambda$main$0(Deubugging.java:6)
    at Debugging$$Lambda$5/284720968.apply(Unknown Source) // 
    ...
```

이와 같은 이상한 문자는 람다 표현식 내부에서 에러가 발생했음을 가리킨다.

### 9.4.2 정보 로깅

스트림의 파이프라인에 적용된 각각의 연산(filter, map, limit 등)이 어떤 결과를 도출하는지 확인할 수 있는 스트림 연산이 있다.

`peek`은 스트림의 각 요소를 소비한 것처럼 동작을 실행한다. 하지만 forEach처럼 실제로 스트림의 요소를 소비하지는 않는다. peek은 자신이 확인한 요소를 파이프라인의 다음 연산으로 그대로 전달한다.

```java
numbers.stream()
    .peek(x -> System.out.println("from stream: " + x)) // 각요소를 출력
    .map(x -> x+17)
    .peek(x -> System.out.println("from map: " + x)) // map후에 각 요소를 출력
    .collect(toList());
```

## 9.5 마치며

람다 표현식으로 가독성이 좋고 더 유연한 코드를 만들 수 있다.

익명 클래스는 람다 표현식으로 바꾸는 것이 좋다. 하지만 이때 this, 변수 섀도 등 미묘하게 의미상 다른 내용이 있음을 주의하자.

메소드 참조로 더 가독성이 좋은 코드를 구현할 수 있다.

반복적으로 컬렉션을 처리하는 루틴은 스트림 API로 대체할 수 있을지 고려하는 것이 좋다.

람다 표현식도 단위 테스트를 수행할 수 있다. 하지만 람다 표현식 자체를 테스트하는 것보다는 람다 표현식이 사용되는 메서드의 동작을 테스트하는 것이 바람직하다.

람다 표현식을 사용하면 스택 트레이스를 이해하기 어려워진다.

스트림 파이프라인에서 요소를 처리할 때 peek 메서드로 중간값을 확인할 수 있다.































