# 13. 디폴트 메서드

인터페이스에 새로운 메서드를 추가하면 어떻게 될까.

-> 해당 인터페이스를 구현했던 모든 클래스의 구현도 고쳐야 한다. -> 끔찍하다.

하지만 걱정 마라. 자바 8에서는 이 문제를 해결하는 새로운 기능을 제공한다.<br>
자바 8에서는 기본 구현을 포함하는 인터페이스를 정의하는 두 가지 방법을 제공한다.

1. 인터페이스 내부에 정적 메서드를 사용

2. 인터페이스의 기본 구현을 제공할 수 있도록 디폴트 메서드 기능을 사용

즉, 자바 8에서는 메서드 구현을 포함하는 인터페이스를 정의할 수 있다.

    결과적으로 기존 인터페이스를 구현하는 클래스는 자동으로 인터페이스에 추가된 새로운 메서드의 디폴트 메서드를 상속받게 된다.

    이렇게 하면 기존의 코드 구현을 바꾸도록 강요하지 않으면서도 인터페이스를 바꿀 수 있다.

```java
default void sort(Comparaotr<? super E> c){
    Collections.sort(this, c);
}
```

List 인터페이스의 sort 메서드이다.

```java
default Stream<E> stream() {
    return StreaSupport.stream(spliterator(), false);
}
```

Collection의 stream 메서드이다.

    디폴트 메서드를 이용하면 자바 API의 호환성을 유지하면서 라이브러리를 바꿀 수 있다.

## 13.3 변화하는 API

`사용자가 겪는 문제`

인터페이스에 메서드를 추가하면, 인터페이스를 구현한 모든 클래스는 해당 메서드를 구현해야 한다.

여기서 바이너리 호환성은 유지된다.

    `바이너리 호환성`이란 새로 추가된 메서드를 호출하지만 않으면 새로운 메서드 구현이 없어도 기존 클래스 파일이 잘 동작한다는 의미이다.

    `소스 호환성`이란 코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일할 수 있음을 의미한다. 
    인터페이스에 메서드를 추가하면 소스 호환성이 아니다.

    `동작 호환성`이란 코드를 바꾼 다음에도 같은 입력값이 주어지면 프로그램이 같은 동작을 실행한다는 의미이다.
    인터페이스에 메서드를 추가하더라도 프로그램에서 추가된 메서드를 호출할 일은 없으므로 동작 호환성은 유지된다.

이 문제를 디폴트 메서드를 통해 해결할 수 있다.

## 13.2 디폴트 메서드란 무엇인가?

자바 8에서는 호환성을 유지하면서 API를 바꿀 수 있도록 새로운 기능인 디폴트 메서드를 제공한다.<br>
이제 인터페이스는 자신을 구현하는 클래스에서 메서드를 구현하지 않을 수 있는 새로운 메서드 시그니처를 제공한다.

    디폴트 메서드는 default라는 키워드로 시작하며 다른 클래스에 선언된 메서드처럼 메서드 바디를 포함한다.

디폴트 메서드를 추가하면 소스 호환성이 유지된다.

    `추상 클래스와 자바 8의 인터페이스`

    추상 클래스와 인터페이스는 뭐가 다를까? (둘 다 추상 메서드와 바디를 포함하는 메서드를 정의할 수 있다)

    1. 클래스는 하나의 추상 클래스만 상속받을 수 있지만 인터페이스를 여러개 구현할 수 있다.

    2. 추상 클래스는 인스턴스 변수(필드)로 공동 상태를 가질 수 있다. 하지만 인터페이스는 인스턴스 변수를 가질 수 없다.

## 13.3 디폴트 메서드 활용 패턴

이 절에서는 디폴트 메서드를 이용하는 두 가지 방식, 즉 선택형 메서드와 동작 다중 상속을 설명한다.

### 13.3.1 선택형 메서드

자바 8 이전에는 Iterator 인터페이스의 remove 메서드에 빈 구현을 제공했다. (잘 안써서)

디폴트 메서드를 이용하면 remove 같은 메서드에 기본 구현을 제공할 수 있으므로 빈 구현을 제공할 필요가 없다.

```java
interface Interator<T>{
    boolean hasNext();
    T next();
    default void remove() {
        return new UnsupportedOperationException();
    }
}
```
### 13.3.2 동작 다중 상속

디폴트 메서드를 이용하면 기존에는 불가능했던 동작 다중 상속 기능도 구현할 수 있다.

    자바 8 이전 인터페이스의 메서드들은 메서드 바디가 없었기 때문에

>

    `옳지 못한 상속`
    
    상속으로 코드 재사용 문제를 모두 해결할 수 있는 것은 아니다.

    예를 들어 한개의 메서드를 재사용하려고 100개의 메서드와 필드가 정의되어 있는 클래스를 상속받는 것은 좋은 생각이 아니다.
    이럴 때는 델리게이션, 즉 멤버 변수를 이용해서 클래스에서 필요한 메서드를 직접 호출하는 메서드를 작성하는 것이 좋다.

    종종 `final`로 선언된 클래스를 볼 수 있다. (String, ...)
    다른 클래스가 이 클래스를 상속받지 못하게 함으로써 원래 동작이 바뀌지 않길 원하기 때문이다.

## 13.4 해석 규칙

자바 8에는 디폴트 메서드가 추가되었으므로 같은 시그니처를 갖는 디폴트 메서드를 상속받는 상황이 생길 수 있다. 이런 상황에서는 어떤 인터페이스와 디폴트 메서드를 사용하게 될까?

`알아야 할 세가지 해결 규칙`

1. 클래스가 항상 이긴다. 클래스나 슈퍼클래스에서 `정의한 메서드`가 디폴트 메서드보다 우선권을 갖는다.

2. 1번 규칙 이외의 상황에서는 서브인터페이스가 이긴다.

3. 여전히 디폴트 메서드의 우선순위가 결정되지 않았다면 여러 인터페이스를 상속받는 클래스가 명시적으로 디폴트 메서드를 오버라이드하고 호출해야 한다.

## 13.5 마치며

자바 8의 인터페이스는 구현 코드를 포함하는 디폴트 메서드, 정적 메서드를 정의할 수 있다.

디폴트 메서드의 정의는 default 키워드로 시작하며 일반 클래스 메서드처럼 바디를 갖는다.

공개된 인터페이스에 추상 메서드를 추가하면 소스 호환성이 깨진다.

디폴트 메서드 덕분에 라이브러리 설계자가 API를 바꿔도 기존 버전과 호환성을 유지할 수 있다.

클래스가 같은 시그니처를 갖는 여러 디폴트 메서드를 상속하면서 생기는 충돌 문제를 해결하는 규칙이 있다.
