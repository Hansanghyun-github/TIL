## 스트림
자바 8 API에 새로 추가된 기능

스트림을 이용하면 선언형으로 데이터를 처리할 수 있다.
> 선언형: 데이터를 처리하는 임시 구현 코드 대신 짏의형으로 처리하는 것

또한 스트림을 이용 하면 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다.

스트림을 이용하지 않고 데이터를 처리하는 것과 스트림으로 데이터를 처리하는 것을 비교해보자

---
요청: 칼로리가 400보다 낮은 음식의 이름들의 리스트를 가져와라(내림차순으로 정렬)

스트림을 이용하지 않고 처리
```java
List<Dish> lowCaloricDishes = new ArrayList<>();
for(Dish dish: menu) {
	if(dish.getCalories() < 400)
    	lowCaloricDishes.add(dish.getName());
}
Collections.sort(lowCaloricDishes, (Dish dish1, Dish dish2) -> {
	return Integer.compare(dish1.getCalories(), dish2.getCalories());
}
List<String> lowCaloricDishesName = new ArrayList<>();
for(Dish dish: lowCaloricDishes){
	lowCaloricDishesName.add(dish.getName());
}
```
(lowCaloricDishes는 컨테이너 역할만 하는 중간 변수이다)

스트림을 사용하지 않고 처리하는 코드를 보면, 가독성이 매우 떨어진다.

스트림으로 처리
```java
List<String> lowCaloricDishesName =
	menu.stream()
    	.filter(dish -> dish.getCalories() < 400)
        .sorted(comparing(Dish::getCalories))
        .map(Dish::getName)
        .collect(toList());
	
```
스트림을 사용한 코드는 가독성이 매우 좋다
선언형으로 코드를 구현할 수 있다.
> 마치 SQL 질의문처럼
```SELECT NAME FROM DISHES WHERE CALORIES < 400;```

루프와 if 조건문 등의 제어 블록을 사용해서 어떻게 동작을 구현할지 지정할 필요가 없이 '저칼로리의 음식만 선택하라' 같은 동작의 수행을 지정할 수 있다.

filter(또는 sort, map, collec) 같은 연산은 고수준 빌딩 블록으로 이루어져 있으므로 특정 스레딩  모델에 제한되지 않고 어떤 상황에서든 자유롭게 사용할 수 있다.
(단일 스레드 모델부터 멀티코어 아키텍쳐 또한 최대한 투명하게 활용가능)

---
### 스트림의 정의
스트림이란 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소

연속된 요소: 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공
> 컬렉션의 주제는 데이터고, 스트림의 주제는 계산이다
>
>컬렉션: ArrayList, LinkedList, HashMap 등 저장 방식 및 접근 연산 주로 제공
>
>스트림: filter, map, sorted 처럼 계산식이 주

소스: 컬렉션 배열 I/O 자원 등의 제공 소스로부터 데이터를 소비한다. 
(리스트로 스트림을 만들면 리스트의 순서가 그대로 유지된다)

데이터 처리 연산: 데이터베이스와 비슷한 연산을 지원한다.
스트림 연산은 순차적으로 혹은 병렬로 실행할 수 있다

---
### 스트림의 특징
스트림은 두가지 중요 특징이 있다
파이프파이닝: 대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록 스트림 자신을 반환한다. 그덕분에 lazy 연산, 쇼트서킷 같은 최적화도 얻을 수 있다.

내부 반복: 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리, 스트림은 내부 반복을 지원한다.

위의 두가지 중요 특징에 의해 3가지 장점을 얻는다.

선언형: 더 간결하고 가독성이 좋아진다
조립할 수 있음: 유연성이 좋아진다
병렬화: 성능이 좋아진다

> 스트림을 이용하면 컬렉션으로 처리못하는 무제한의 요소도 처리할 수 있다

---
### 컬렉션 vs 스트림 1. 구조
비유를 하면 컬렉션은 DVD이고, 스트림은 인터넷 스트리밍이다.

DVD는 영화 전체의 내용이 저장되어 있다.

반면 인터넷 스트리밍을 이용하여 영화를 시청할때는, 사용자가 시청하는 부분의 몇 프레임을 미리 내려받는다. 그러면 스트림의 다른 대부분의 값을 처리하지 않는 상태에서 미리 내려받은 프레임부터 재생할 수 있다.
> 데이터를 언제 계산하느냐가 컬렉션과 스트림의 가장 큰 차이다.
> 
> 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조
> -> 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다.
> 
> 스트림은 요청할 때만 요소를 계산하는 고정된 자료구조이다.
> 스트림은 사용자가 데이터를 요청할 때만 값을 계산한다.
>> 스트림은 게으르지게 만들어지는 컬렉션과 같다

> 스트림은 딱 한번만 탐색할 수 있다. -> 탐색된 스트림의 요소는 소비된다.

---
### 컬렉션 vs 스트림 2. 데이터 반복 처리 방법
컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다.

이를 **외부 반복**이라고 한다.
> 명시적으로 컬렉션 항목을 하나씩 가져와서 처리한다

반면 스트림은 (반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장해주는)**내부 반복**을 사용한다.
> 내부 반복을 이용하면 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있다.

---
### 스트림 연산
스트림 인터페이스의 연산을 크게 두가지로 구분할 수 있다.

**1. 중간 연산**
filter, map, limit 같은 연산들

중간 연산은 다른 스트림을 반환한다. -> 여러 중간 연산을 연결해서 질의를 만들 수 있다.

단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다는 특징이 있다.

-> lazy 연산

filter 다음에 map이 바로 온다면, 한과정으로 병합된다. -> 루프 퓨전


**2. 최종 연산**
forEach, collect 같은 연산들

스트림 파이프라인에서 결과를 도출한다. -> 스트림 이외에 결과가 반환된다.

---
스트림의 이용 과정은 세가지이다.
1. 질의를 수행할 (컬렉션 같은) 데이터 소스
2. 스트림 파이프라인을 구성할 중간 연산 연결
3. 스트림 파이프라인을 실행하고 결과를 만들 최종 연산


---
## 스트림 활용

### 1. 필터링

#### 1-1 Predicate로 필터링

Predicate는 제네릭 변수 T를 받아 불리언을 반환하는 메소드 test를 가지고 있는 함수형 인터페이스

filter() 메서드의 파라미터로 Predicate를 입력해서 필터링한다.

#### 1-2 고유 요소 필터링

distinct() 메서드를 사용하면 고유한 요소만 필터링된다.
> 고유 여부는 스트림에서 만든 객체의 hashCode, equals로 결정된다

### 2. 스트림 슬라이싱

#### 2-1 Predicate를 이용한 슬라이싱

`TAKEWHILE 활용`

정렬된 데이터를 필터링할때 사용하는 메서드

takewhile 메서드를 filter 대신 사용가능
> takewhile을 사용하는 스트림은 정렬되어 있어야 한다.

takewhile은 프레디케이트가 처음으로 거짓이 되는 지점까지 발견된 요소만 필터링한다.

`DROPWHILE 활용`

takewhile과 정반대의 작업을 수행한다.

dropwhile은 프레디케이트가 처음으로 거짓이 되는 지점까지 발견된 요소를 버린다.

> dropwhile은 무한한 남은 요소를 가진 무한 스트림에서도 동작한다.

#### 2-2 스트림 축소

limit(n) 메서드는 주어진 값 이하의 크기를 갖는 새로운 스트림을 반환한다.

#### 2-3 요소 건너뛰기

skip(n) 메서드는 처음 n개 요소를 제외한 스트림을 반환한다.

> n개 이하의 요소를 포함하는 스트림에 skip(n)을 호출하면 빈 스트림이 반환된다.

### 3. 매핑

특정 객체에서 특정 데이터를 선택하는 작업을 매핑이라 한다.

스트림 API의 map과 flatMap 메서드가 이에 해당하는 메서드이다.

#### 스트림 평면화

map을 이용해서 객체에서 특정 데이터를 선택하는 작업을 수행할 수 있다.

이때 ```stream<String[]>``` 을 ```stream<String>``` 으로 변환하고 싶을때 Arrays.stream과 flatMap을 활용한다.

Arrays.stream : array를 스트림으로 변환해주는 함수 ```String[]``` -> ```stream<String>```

flatMap 메서드는 스트림의 각 값을 다른 스트림으로 만든 다음에 모든 스트림을 하나의 스트림으로 연결하는 기능을 수행한다.

일반 map 메서드 활용 => (String)str.stream().map(word -> word.split(" ")) : ```stream<String[]>```

Arrays.stream 활용 => (String)str.stream().map(word -> word.split(" ")).map(Arrays::stream) : ```stream<stream<String>>```

마지막으로 flatMap까지 활용 => (String)str.stream().map(word -> word.split(" ")).flatMap(Arrays::stream) : ```stream<String>```

### 4. 검색과 매칭

```anyMatch``` boolean을 반환하는 최종 연산 메서드. 스트림에서 적어도 한 요소가 일치하는지 확인한다.

```allMatch``` boolean을 반환하는 최종 연산 메서드. 스트림에서 모든 요소가 일치하는지 확인한다.

```noneMatch``` allMatch와 반대 연산 수행(일치하는 요소가 없는지 확인한다)

> 위 세 메서드는 스트림 쇼트서킷 기법, 즉 자바의 &&, ||와 같은 연산을 활용한다.
>
>쇼트서킷: 전체 스트림을 처리하지 않았더라도 결과를 반환하는 프로세스
>>ex) if(a==0 && b==0)에서 a가 0이 아니라면, b의 값과 상관없이 조건문의 결과가 false이므로 b를 체크하기 전에 if문을 탈출한다.

```findAny``` 현재 스트림에서 임의의 요소를 반환하는 최종 연산 메서드

```findFirst``` 스트림의 첫번째 요소를 반환한다.

(일부 스트림에는 논리적인 아이템 순서가 정해져 있을 수 있다)

> 💡 findAny vs findFirst
>
>병렬 실행에서 첫번째 요소를 찾는건 어렵다. 따라서 요소의 반환 순서가 상관없다면 병렬 스트림에서는 제약이 적은 findAny를 써야한다

### 5. 리듀싱

모든 스트림 요소를 처리해서 값으로 도출하는 연산을 리듀싱 연산이라 한다.

reduce 메서드는 (a, b) -> 리턴값 함수를 파라미터로 받는다.

초깃값을 첫 파라미터로 설정 가능

초깃값이 없다면 Optional로 반환됨
> 스트림에 객체가 없을수 있기 때문

> reduce를 이용하면 내부 반복이 추상화되면서 내부 구현에서 병렬로 reduce를 실행할 수 있게 됨

### 6. 스트림 연산: 상태 없음과 상태 있음

map, filter 등은 입력 스트림에서 각 요소를 받아 0 또는 결과를 출력 스트림으로 보낸다.<br>
이 두 메서드들은 보통 상태가 없는, 즉 내부 상태를 갖지 않는 연산이다.(stateless operation)

반면 sorted나 distince 같은 연산은 이전 메서드들과는 다르게, 과거의 이력을 알고 있어야 한다. 이말은 모든 요소가 버퍼에 추가되어 있어야 한다. 이러한 연산은 내부상태를 갖는 연산이다.(stateful operation)

### 7. 숫자형 스트림

일반적인 ```List<Integer> list```의 합계를 구할때는 다음과 같은 스트림을 이용한다.<br>
```list.stream().reduce(0, (a,b) -> a+b) or .reduce(Integer::sum)```

사실 이코드에는 박싱 비용이 숨어있다.<br>
그렇다면 박싱 비용을 피할 수 있는 기능이 있다면 좋지 않을까?

스트림 API는 기본형 특화 스트림을 제공한다.

#### 7-1 기본형 특화 스트림

자바 8에서는 세가지 기본형 특화 스트림을 제공한다.

스트림 API에서는 박싱 비용을 피할 수 있도록 IntStream, DoubleStream, LongStream을 제공한다.

각각의 인터페이스는 숫자 스트림의 sum, max와 같이 자주 사용하는 숫자 관련 리듀싱 연산 수행 메서드를 제공한다.

또한 필요할때 다시 객체 스트림으로 복원하는 기능도 제공한다.

특화 스트림은 오직 박싱 과정에서 일어나는 효율성과 관련 있으며 스트림에 추가 기능을 제공하지는 않는다.

스트림을 특화 스트림으로 변환할 때는 mapToInt, mapToDouble, mapToLong 세가지 메서드를 가장 많이 사용한다.
> mapToInt -> IntStream 반환

> mapToObj -> stream<Object> 반환

`객체 스트림으로 복원하기` - boxed 메서드 사용

`OptionInt`

최댓(솟)값을 구할때 OptionalInt, OptionalDouble, OptionalLong이 반환된다.<br>
```OptionalInt max = menu.stream().mapToInt(Dish::getCalories).max()```

#### 7-2 숫자 범위

IntStream과 LongStream에서는 range와 rangeClosed라는 두가지 static 메서드를 제공한다.<br>
두 메서드 모두 첫번째 인수로 시작값을, 두번쨰 인수로 종료값을 갖는다.

> range 메서드는 시작값과 종료값을 포함하지 않는다.<br>
> rangeClose 메서드는 시작값과 종료값을 포함한다.

### 스트림 만들기

Stream.of를 이용해서 스트림을 만들 수 있다.

Stream.empty() => 빈 스트림 생성

Arrays.stream(arr) => 배열로 스트림 만들기

iterate(0, n -> n+2) => 무한스트림

generate 메서드 => Supplier를 인수로 받아서 무한스트림 생성

> 무한스트림은 takeWhile, limit 메서드를 이용해서 제한해야 한다.












