## 스트림
자바 8 API에 새로 추가된 기능

스트림을 이용하면 선언형으로 데이터를 처리할 수 있다.
> 선언형: 데이터를 처리하는 임시 구현 코드 대신 짏의형으로 처리하는 것

또한 스트림을 이용 하면 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다.

스트림을 이용하지 않고 데이터를 처리하는 것과 스트림으로 데이터를 처리하는 것을 비교해보자

---
요청: 칼로리가 400보다 낮은 음식의 이름들의 리스트를 가져와라(내림차순으로 정렬)

스트림을 이용하지 않고 처리
```java
List<Dish> lowCaloricDishes = new ArrayList<>();
for(Dish dish: menu) {
	if(dish.getCalories() < 400)
    	lowCaloricDishes.add(dish.getName());
}
Collections.sort(lowCaloricDishes, (Dish dish1, Dish dish2) -> {
	return Integer.compare(dish1.getCalories(), dish2.getCalories());
}
List<String> lowCaloricDishesName = new ArrayList<>();
for(Dish dish: lowCaloricDishes){
	lowCaloricDishesName.add(dish.getName());
}
```
(lowCaloricDishes는 컨테이너 역할만 하는 중간 변수이다)

스트림을 사용하지 않고 처리하는 코드를 보면, 가독성이 매우 떨어진다.

스트림으로 처리
```java
List<String> lowCaloricDishesName =
	menu.stream()
    	.filter(dish -> dish.getCalories() < 400)
        .sorted(comparing(Dish::getCalories))
        .map(Dish::getName)
        .collect(toList());
	
```
스트림을 사용한 코드는 가독성이 매우 좋다
선언형으로 코드를 구현할 수 있다.
> 마치 SQL 질의문처럼
```SELECT NAME FROM DISHES WHERE CALORIES < 400;```

루프와 if 조건문 등의 제어 블록을 사용해서 어떻게 동작을 구현할지 지정할 필요가 없이 '저칼로리의 음식만 선택하라' 같은 동작의 수행을 지정할 수 있다.

filter(또는 sort, map, collec) 같은 연산은 고수준 빌딩 블록으로 이루어져 있으므로 특정 스레딩  모델에 제한되지 않고 어떤 상황에서든 자유롭게 사용할 수 있다.
(단일 스레드 모델부터 멀티코어 아키텍쳐 또한 최대한 투명하게 활용가능)

---
### 스트림의 정의
스트림이란 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소

연속된 요소: 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공
> 컬렉션의 주제는 데이터고, 스트림의 주제는 계산이다
>
>컬렉션: ArrayList, LinkedList, HashMap 등 저장 방식 및 접근 연산 주로 제공
>
>스트림: filter, map, sorted 처럼 계산식이 주

소스: 컬렉션 배열 I/O 자원 등의 제공 소스로부터 데이터를 소비한다. 
(리스트로 스트림을 만들면 리스트의 순서가 그대로 유지된다)

데이터 처리 연산: 데이터베이스와 비슷한 연산을 지원한다.
스트림 연산은 순차적으로 혹은 병렬로 실행할 수 있다

---
### 스트림의 특징
스트림은 두가지 중요 특징이 있다
파이프파이닝: 대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록 스트림 자신을 반환한다. 그덕분에 lazy 연산, 쇼트서킷 같은 최적화도 얻을 수 있다.

내부 반복: 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리, 스트림은 내부 반복을 지원한다.

위의 두가지 중요 특징에 의해 3가지 장점을 얻는다.

선언형: 더 간결하고 가독성이 좋아진다
조립할 수 있음: 유연성이 좋아진다
병렬화: 성능이 좋아진다

> 스트림을 이용하면 컬렉션으로 처리못하는 무제한의 요소도 처리할 수 있다

---
### 컬렉션 vs 스트림 1. 구조
비유를 하면 컬렉션은 DVD이고, 스트림은 인터넷 스트리밍이다.

DVD는 영화 전체의 내용이 저장되어 있다.

반면 인터넷 스트리밍을 이용하여 영화를 시청할때는, 사용자가 시청하는 부분의 몇 프레임을 미리 내려받는다. 그러면 스트림의 다른 대부분의 값을 처리하지 않는 상태에서 미리 내려받은 프레임부터 재생할 수 있다.
> 데이터를 언제 계산하느냐가 컬렉션과 스트림의 가장 큰 차이다.
> 
> 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조
> -> 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다.
> 
> 스트림은 요청할 때만 요소를 계산하는 고정된 자료구조이다.
> 스트림은 사용자가 데이터를 요청할 때만 값을 계산한다.
>> 스트림은 게으르지게 만들어지는 컬렉션과 같다

> 스트림은 딱 한번만 탐색할 수 있다. -> 탐색된 스트림의 요소는 소비된다.

---
### 컬렉션 vs 스트림 2. 데이터 반복 처리 방법
컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다.

이를 **외부 반복**이라고 한다.
> 명시적으로 컬렉션 항목을 하나씩 가져와서 처리한다

반면 스트림은 (반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장해주는)**내부 반복**을 사용한다.
> 내부 반복을 이용하면 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있다.

---
### 스트림 연산
스트림 인터페이스의 연산을 크게 두가지로 구분할 수 있다.

**1. 중간 연산**
filter, map, limit 같은 연산들

중간 연산은 다른 스트림을 반환한다. -> 여러 중간 연산을 연결해서 질의를 만들 수 있다.

단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다는 특징이 있다.

-> lazy 연산

filter 다음에 map이 바로 온다면, 한과정으로 병합된다. -> 루프 퓨전


**2. 최종 연산**
forEach, collect 같은 연산들

스트림 파이프라인에서 결과를 도출한다. -> 스트림 이외에 결과가 반환된다.

---
스트림의 이용 과정은 세가지이다.
1. 질의를 수행할 (컬렉션 같은) 데이터 소스
2. 스트림 파이프라인을 구성할 중간 연산 연결
3. 스트림 파이프라인을 실행하고 결과를 만들 최종 연산


---
## 스트림 활용



