> 스레드란 프로그램 실행의 가장 작은 단위

## Runnable 인터페이스

run() 메서드 하나만 가지고 있는 함수형 인터페이스

## Thread 클래스

start() - 새 스레드를 생성하여 run() 메서드를 실행

> native method인 start0()를 통해 스레드를 생성해 run 메서드를 실행한다.  
> (start0은 네티이브 메서드인 이유 - OS 별로 스레드 생성 메서드가 다르기 떄문에)

run() - target의 run 메서드를 실행  
(Runnable 인터페이스의 메서드를 오버라이딩)

sleep(long) - 밀리초 만큼 현재 스레드를 멈추는 native method  
(자원을 해제하지 않고, 제어권을 넘기기 때문에 데드락 발생 가능)

join() - 현재 스레드가 끝날 때까지 기다리는 메서드

setDaemon(boolean) - 데몬 스레드라고 표시하는 메서드

> 데몬 스레드
> 
> 1. 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드
> 2. 주 스레드가 종료되면 데몬 스레드는 강제적으로 자동 종료된다.  
>    (주 스레드의 보조 역할을 수행하므로 주 스레드가 종료되면 데몬 스레드의 존재 의미가 없어지기 때문)
> 
> (데몬 - 사용자가 직접적으로 제어하지 않고, 백그라운드에서 돌면서 여러 작업을 하는 프로그램)

---

## Thread를 이용해 멀티스레딩을 구현하는 방법

1. Thread를 상속 받아서 run 메서드를 오버라이딩
2. Runnable을 implement 해서 run 메서드를 오버라이딩 & Thread를 통해 실행한다

대부분 2번을 추천한다.

자바는 다중 상속이 지원되지 않기때문에, Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없다.

---

## Thread & Runnable의 한계점

1. 지나치게 저수준의 API(쓰레드의 생성)에 의존함
2. 값의 반환이 불가능
3. 매번 스레드 생성과 종료하는 오버헤드가 발생
4. 스레드들의 관리가 어려움

> 결국 개발자가 관심이 있는 것은  
> 스레드를 이용한 비즈니스 로직의 실행일 뿐이지,  
> 스레드의 생성, 종료가 아니기 때문이다.

이를 보완한 (Java 5 이후에 등장한) Executor, ExecutorService, Callable, Future 가 있다.