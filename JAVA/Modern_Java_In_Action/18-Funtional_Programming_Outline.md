# 18 함수형 관점으로 생각하기

지금까지 이 책에서 함수형(funtional)이라는 용어를 자주 언급했다.
람다와 관련 있으며 때로는 객체 변화를 제한하는 것이 함수형과 밀접한 관련을 갖는다.
그런데 함수형을 적용하면 어떤 점이 좋을까?

18장에서는 함수형 프로그래밍의 개념을 살펴본다.<br>
19장에서는 함수형 프로그래밍의 기법을 자세히 살펴본다.

## 18.1 시스템 구현과 유지보수

쉽게 유지보수할 수 있으려면 프로그램이 어떤 모습이어야 할까? 프로그램이 시스템의 구조를 이해하기 쉽게 클래스 계층으로 반영한다면 좋을 것이다. 시스템의 각 부분이 상호 의존성을 가리키는 결합성과 시스템의 다양한 부분이 서로 어떤 관계를 가리키는 응집성이라는 소프트웨어 엔지니어링 도구로 프로그램 구조를 평가할 수 있다.

그러나 실질적으로 많은 프로그래머가 유지보수 중 코드 크래시 디버깅 문제를 가장 많이 겪게 된다. 함수형 프로그래밍이 제공하는 부작용 없음(no side effect)과 불변성(immutability)이라는 개념이 이 문제를 해결하는데 도움을 준다.

### 18.1.1 공유된 가변 데이터

변수가 예상하지 못한 값을 갖는 이유는 결국 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다.<br>
공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기가 어려워진다.

어떤 자료구조도 바꾸지 않는 시스템이 있다면, 그 시스템은 예상하지 못하게 자료구조의 값이 바뀔 일이 없으니 유지보수가 쉬울 것이다.<br>
자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 부작용 없는 메서드라고 부른다.

    부작용의 예
    - 자료구조를 고치거나 필드에 값을 할당(setter 메서드 같은 생성자 이외에 초기화 동작)
    - 예외 발생
    - 파일에 쓰기 등의 I/O 동작 수행

불변 객체를 이용해서 부작용을 없애는 방법도 있다. 불변 객체는 복사하지 않고 공유할 수 있으며, 객체의 상태를 바꿀 수 없으므로 스레드 안전성을 제공한다.

부작용 없는 시스템의 개념은 함수형 프로그래밍에서 유래되었다.<br>
먼저 함수형 프로그래밍의 기반을 이루는 개념인 선언형 프로그래밍을 살펴보자

### 18.1.2 선언형 프로그래밍

프로그램으로 시스템을 구현하는 방식은 크게 두 가지로 구분할 수 있다.

첫번째는 작업을 어떻게 수행할 것인지에 집중하는 방법이 있다. 이처럼 어떻게(how)에 집중하는 프로그래밍 형식은 고전의 객체지향 프로그래밍에서 이용하는 방식이다.

    ex) 리스트에서 가장 비싼 트랜잭션을 계산해라
    1. 리스트에서 트랜잭션을 가져와서 가장 비싼 트랜잭션과 비교
    2. 가져온 트랜잭션이 가장 비싼 트랜잭션보다 비싸다면 가져온 트랜잭션이 가장 비싼 트랜잭션
    3. 리스트의 다음 트랜잭션으로 지금까지의 과정을 반복

때로는 이를 명령형 프로그래밍이라고 부르기도 한다.

---

'어떻게'가 아닌 '무엇을'에 집중하는 방식도 있다. 4장과 5장에서 스트림 API로 다음과 같은 질의를 만들 수 있었다.
```
Optional<Transaction> mostExpentive = 
    transactions.stream()
                .max(comparing(Transaction::getValue));
```

질의문 구현 방법은 라이브러리가 결정한다. 이와 같은 구현 방식을 `내부 반복`이라고 한다. 질의문 자체로 문제를 어떻게 푸는지 명황하게 보여준다는 것이 내부 반복 프로그래밍의 큰 장점이다.

이처럼 '무엇을'에 집중하는 방식을 `선언형 프로그래밍`이라고 부른다. 선언형 프로그래밍에서 우리가 원하는 것이 무엇이고 시스템이 어떻게 그 목표를 달성할 것인지 등의 규칙을 정한다.

    문제 자체가 코드로 명확하게 드러난다는 점이 선언형 프로그래밍의 강점이다.

### 18.1.3 왜 함수형 프로그래밍인가?

함수형 프로그래밍은 선언형 프로그래밍의 대표적인 방식이며, 부작용이 없는 계산을 지향한다. '선언형 프로그래밍'과 '부작용을 멀리한다'는 두가지 개념은 좀더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.

람다와 스트림의 기능은 함수형 프로그래밍의 특징을 고스란히 보여준다.

실제로 함수형 프로그래밍을 이용하고 자바 8의 새로운 기능과 연결하려면 먼저 함수형 프로그래밍을 제대로 정의하고 자바로 어떻게 구현하는지 살펴봐야 한다.

## 18.2 함수형 프로그래밍이란 무엇인가?

함수형 프로그래밍이란 `함수`를 이용하는 프로그래밍이다.

함수형 프로그래밍에서 함수란 수학적인 함수와 같다.

    함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 부작용이 없어야 한다.

자바와 같은 언어에서는 바로 수학적인 함수냐 아니냐가 메서드와 함수를 구분하는 핵심이다. 특히 인수가 같다면 수학적 함수를 반복적으로 호출했을 때 항상 같은 결과가 반환된다.

`함수형`이라는 말은 `수학의 함수처럼 부작용이 없는`을 의미한다.

결론적으로 '함수 그리고 if-then-else 등의 수학적 표현만 사용'하는 방식을 순수 함수형 프로그래밍이라고 하며, '시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용'하는 방식을 함수형 프로그래밍이라 한다.

### 18.2.1 함수형 자바

자바에서는 순수 함수형이 아니라 `함수형 프로그램`을 구현할 것이다. 실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써 `함수형`을 달성할 수 있다.

함수나 메서드는 지역 변수만을 변경해야 함수형이라 할 수 있다. 그리고 함수나 메서드에서 참조하는 객체가 있다면 그 객체는 불변 객체여야 한다. 즉 모든 필드가 final이어야 하고 모든 참조 필드는 불변 객체를 직접 참조해야 한다.

함수형이라면 `함수나 메서드가 어떤 예외도 일으키지 않아야 한다`.

    함수에는 항상 예외가 따르는데, 예외를 사용하지 않고 나눗셈 같은 함수를 표현하려면 Optional<T>를 사용하여 문제를 해결할 수 있다.

마지막으로 함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야 한다.(먼저 자료구조를 복사한다든가 발생할 수 있는 예제를 적절하게 내부적으로 처리함으로써 자료구조의 변경을 호출자가 알 수 없도록 감춰야 한다).

### 18.2.2 참조 투명성

'부작용을 감춰야 한다'라는 제약은 `참조 투명성`(referential transparency) 개념으로 귀결된다.

    같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다.

    Random.nextInt는 함수형이 될 수 없다.

참조 투명성은 프로그램 이해에 큰 도움을 준다.

자바에서 결과 리스트를 (불변의) 순수값으로 사용할 것이라면 두 리스트가 같은 객체라고 볼 수 있으므로 리스트 생성 함수는 투명한 것으로 같주할 수 있다. 일반적으로 `함수형 코드에서는 이런 함수를 참조적으로 투명한 것으로 간주한다.`

### 18.2.4 함수형 실전 연습

두개의 리스트를 인수로 받고, 두 리스트를 합친 결과 리스트를 반환하는 메서드 concat을 작성해보자.

두가지 유형이 있다.

```java
static List<List<Integer>> concat1(List<List<Integer>> a,
                                  List<List<Integer>> b) {
    a.addAll(b);
    return a;
}

static List<List<Integer>> concat2(List<List<Integer>> a,
                                  List<List<Integer>> b) {
    List<List<Integer>> result = new ArrayList<>(a);
    result.addAll(b);
    return r;
}
```

concat1()보다 concat2()가 더 좋은 코드이다.

concat2()는 순수 함수다. 내부적으로는 리스트 result에 요소를 추가하는 변화가 발생하지만 반환 결과는 오로지 인수에 의해 이루어지며 인수의 정보는 변경하지 않는다.

이와 달리 concat1()은 호출한 다음에 a의 값을 다시 참조하지 않는다는 가정을 한다.

    `메서드의 첫번째 인수를 임의의 값으로 바꿀 수 있는 상황에서만 메서드를 사용해야 하며 a를 고칠때는 이 사실을 고려해야함`이라는 자세한 설명을 주석으로 추가해야한다.

    여기서 concat1()은 concat2()보다 가벼운 메서드이기 때문에, concat1()을 더 실용적으로 사용할 수도 있다.

---

무엇을 해야 하는가에 집중할 수 있도록 도움을 주는 함수형 프로그래밍의 한 기법인 재귀를 자세히 살펴보자

## 18.3 재귀와 반복

순수 함수형 프로그래밍 언어에서는 while, for 같은 반복문을 포함하지 않는다. 이러한 반복문 떄문에 변화가 자연스럽게 코드에 스며들 수 있기 때문이다.

여기서 재귀를 이용하면 루프 단계마다 갱신되는 반복 변수를 제거할 수 있다.

하지만 일반적으로 반복코드보다 재귀 코드가 더 비싸다. 함수를 호출할 때마다 호출 스택에 각 호출시 생성되는 정보를 저장할 새로운 스택 프레임이 만들어진다. 즉, 함수의 입력값에 비례해서 메모리 사용량이 증가한다.

(함수형 언어에서는 이를 해결하기 위한 꼬리 호출 최적화라는 해결책을 제공하지만, 자바는 이와 같은 최적화를 제공하지 안흔ㄴ다.)

결론적으로 자바 8에서는 반복을 스트림으로 대체해서 변화를 피할 수 있다. 또한 반복을 재귀로 바꾸면 더 간결하고, 부작용이 없는 알고리즘을 만들 수 있다. 또한 약간의 실행시간 차이보다는 프로그래머의 효율성이 더 중요할 때도 있다.

## 18.4 마치며

공유된 가변 자료구조를 줄이는 것은 장기적으로 프로그램을 유지보수하고 디버깅하는데 도움이 된다.

함수형 프로그래밍은 부작용이 없는 메서드와 선언형 프로그래밍 방식을 지향한다.

함수형 메서드는 입력 인수와 출력 결과만을 갖는다.

같은 인수값으로 함수를 호출했을 때 항상 같은 값을 반환하면 참조 투명성을 갖는다. while 루프 같은 반복문은 재귀로 대체할 수 있다.

자바에서는 고전 방식의 재귀보다는 꼬리 재귀를 사용해야 추가적인 컴파일러 최적화를 기대할 수 있다.










