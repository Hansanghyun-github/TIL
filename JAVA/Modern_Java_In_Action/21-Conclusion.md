# 21 결론 그리고 자바의 미래

## 21.1 자바 8의 기능 리뷰

지금까지 배운 내용을 복습하면서 자바 8이 얼마나 실용적이고 유용한 언어인지 다시 확인해보자.

자바 8에 추가된 대부분의 새로운 기능은 자바에서 함수형 프로그래밍을 쉽게 적용할 수 있도록 도와준다.

자바 8에 이렇게 큰 변화가 생긴 이유는 두가지 추세 떄문이다.

1. 멀티코어 프로세서의 파워를 충분히 활용해야 한다. 무어의 법칙에 따라 실리콘 기술이 발전하면서 개별 CPU 코어의 속도가 빨라지고 있다. 즉, 코드를 병렬로 실행해야 더 빠르게 코드를 실행할 수 있다.

2. 데이터 소스를 이용해서 주어진 조건과 일치하는 모든 데이터를 추출하고, 결과에 어떤 연산을 적용하는 등 선언형으로 데이터를 처리하는 방식, 즉 간결하게 데이터 컬렉션을 다루는 추세다. 간결하게 데이터 컬렉션을 처리하려면 불변값을 생산할 수 있는 불변 객체와 불변 컬렉션이 필요하다.

필드를 변화하고 반복자를 적용하는 기존의 객체지향, 명령형 언어로는 이러한 추세를 만족시키기 어렵다. 한 코어에서 데이터를 변화시키고 다른 코어에서 이 데이터를 읽으려면 비싼 비용을 치러야 할 뿐 아니라 잠금 관련 버그도 많이 발생한다.

함수형 프로그래밍을 사용하면 이 두가지 추세를 모두 달성할 수 있다.

### 21.1.1 동작 파라미터화(람다와 메서드 참조)

재사용할 수 있는 filter 같은 메서드를 구현하려면 filter 메서드의 인수가 필터링 조건을 받도록 만들어야 한다. (필터링 조건을 메서드 내에서 클래스로 감싼 다음에 해당 클래스의 인스턴스를 전달하는 방법) 보통 상당히 복잡한 코드를 구현해야 하며 따라서 유지보수하는 것도 쉽지 않다.

이를 람다를 이용해 깔끔하게 구현한다.

```apple -> apple.getWeight() > 150```

```Apple::isHeavy```

### 21.1.2 스트림

자바의 컬렉션 클래스, 반복자, for-Each 구문은 오랫동안 사용된 기능이다.

자바 8 설계자는 완전히 새로운 스트림 API를 만들었다.(기존의 컬렉션에 람다를 활용한 filter, map 등의 메서드를 추가해서 DB 질의 같은 기능을 제공하는 방법을 선택하지 않고)

이유가 뭘까?

    컬렉션에 어떤 문제가 있으며 스트림과 비슷한 점과 다른 점은 무엇일까?

    컬렉션에서 세가지 연산을 적용한다면, 컬렉션을 각각 세번 탐색해야 한다.

    스트림 API는 이들 연산을 파이프라인이라는 lazy한 형식의 연산으로 구성한다.
    그리고 한번의 탐색으로 파이프라인의 모든 연산을 수행한다. 
    
    큰 데이터 집합일수록 스트림의 데이터 처리 방식이 효율적이며, 또한 메모리 캐시등의 관점에서도 커다란 데이터 집합일수록 탐색 횟수를 최소화하는 것이 아주 중요하다.

    멀티코어 CPU를 활용하는 것도, 스트림의 parallel 메서드를 이용해서 쉽게 가능하다.

### 21.1.3 CompletableFuture 클래스

자바 5부터 Future 인터페이스를 제공한다. Future를 이용하면 여러 작업이 동시에 실행될 수 있도록 다른 스레드나 코어로 작업을 할당할 수 있다. -> 멀티코어를 잘 활용할 수 있다.

16장에서는 Future를 구현하는 CompletableFutur 자바 8의 클래스를 소개했다. CompletableFuture는 'CompletableFuture와 Future의 관계는 스트림과 컬렉션의 관계와 같다'라는 좌우명을 주장한다.

    스트림에서는 파이프라인 연산을 구성할 수 있으므로 map, filter 등으로 동작 파라미터화를 제공한다. 따라서 반복자를 사용했을 때 생기는 불필요한 코드를 피할 수 있다.

    마찬가지로 CompletableFuture는 Future와 관련한 공통 디자인 패턴을 함수형 프로그래밍으로 간결하게 표현할 수 있도록 thenCompose, thenCombine, allOf 등을 제공한다.
    따라서 명령형에서 발생하는 불필요한 코드를 피할 수 있다.

### 21.1.4 Optional 클래스

자바 8 라이브러리는 T 형식의 값을 반환하거나 아니면 값이 없음을 의미하는 Optional.empty라는 정적 메서드를 반환할 수 있는 Optional\<T\> 클래스를 제공한다. Optional\<T\>는 프로그램을 쉽게 이해하고 문서화하는데 큰 도움을 준다. 즉, Optional\<T\>는 에러가 잘 발생할 수 있는 계산을 수행하면서 값이 없을 때 에러를 발생시킬 수 있는 null 대신 정해진 데이터 형식을 제공할 수 있다.

Optional\<T\> 클래스를 자세히 살펴보면, Optional\<T\> 클래스는 map, filter, ifPresent를 제공한다. 스트림 클래스가 제공하는 것과 비슷한 동작으로 계산을 연결할 때 함수형으로 map, filter, ifPresent 등을 사용할 수 있으며, 값이 없는 상황을 사용자 코드에서 확인하는 것이 아니라 라이브러리에서 확인할 수 있다.

### 21.1.5 Flow API

자바 9에서는 리액티브 스트림과 리액티브 당김 기반 역압력 프로토콜을 표준화했다.

### 21.1.6 디폴트 메서드

자바 8에는 다른 기능도 추가되었다. 이 기능은 심지어 개별 프로그래밍의 구현에는 아무 영향도 미치지 않는다.

디폴트 메서드 덕분에 인터페이스 설계자는 메서드의 기본 구현을 제공할 수 있다.

    특히 인터페이스에 새로운 기능을 추가했을 때 기존의 모든 고객이 새로 추가된 기능을 구현하지 않을 수 있게 되었다는 점에서 디폴트 메서드는 라이브러리 설계자에게 아주 훌륭한 도구다.

## 21.2 자바 9 모듈 시스템

자바 8에서는 새 기능(람다, 디폴트 메서드 등) 그리고 Stream, CompletableFuture 같은 유용한 새 클래스를 추가했다.

자바 9에서는 새 언어 기능은 추가되지 않았지만, 자바 8에서 시작된 여러 기능을 강화했다.

자바 9의 핵심은 새 모듈 시스템이다. 새 모듈 시스템에서는 module-info.java 파일이 추가되었지만 언어적으로는 바뀐 것이 없다. 

자바 모듈 시스템이 제공하는 장점
1. 안정적 설정
2. 강한 캡슐화
3. 보안성 개선
4. 성능 개선
5. 확장성

## 21.3 자바 10 지역 변수형 추론

자바 7이전

```Map<String, List<String>> m = new HashMap<Stirng, List<String>>();```

자바 7부터는 위 코드를 다음처럼 간소화할 수 있다.

```Map<String, List<String>> m = new HashMap<>();```

형식이 생략되면 컴파일러가 생략된 형식을 추론한다.

자바 10부터 다음처럼 m을 선언할 수 있다.

```var m = new HashMap<String, List<String>>();```

이를 `지역 변수형 추론`이라 부르며 자바 10에 추가된 기능이다.

    초깃값이 없을 때는 var을 사용할 수 없다.

## 21.4 자바의 미래

이 절에서 살펴보는 내용은, 좋은 제안임에도 불구하고 기존 기능과의 상호 작용이나 기타 문제 떄문에 채택되지 못한 이유를 설명한다.

### 21.4.1 선언 사이트 변종

자바에서는 제네릭의 서브형식을 와일드카드로 지정할 수 있는 유연성(보통 이를 `사용 사이트 변종`이라 함)을 허용한다.

```List<? extends Number> numbers = new ArrayList<Integer>();```

하지만 다음처럼 ? extends가 없으면 컴파일 에러가 발생한다.

```List<Number> numbers = new ArrayList<Integer>();```

    C#, 스칼라 같은 많은 프로그래밍 언어는 선언 사이트 변종이라는 다른 변종 기법을 지원한다. 이를 이용하면 제네릭 클래스를 정의할 때 프로그래머가 변종을 지정할 수 있다.

    선언 사이트 변종에서는 ? extends나 ? super를 사용할 필요가 없다.

이유는 없나?

### 21.4.2 패턴 매칭

//

### 21.4.3 풍부한 형식의 제네릭

이 절에서는 자바 제네릭의 두가지 한계를 살펴보고 이를 해결할 수 있는 방법을 제공한다.

`구체화된 제네릭`

자바 5에서 제네릭을 소개했을때 제네릭이 기존 JVM과 호환성을 유지해야 한다. 결과적으로 ArrayList\<String>이나 ArrayList\<Integer> 모두 런타임 표현이 같게 되었다.(주소값을 저장하니까) 

이를 `제네릭 다형성의 삭제 모델`이라고 한다.<br>
이 때문에 약간의 런타임 비용을 지불하게 되엇으며 제네릭 형식의 파라미터로 객체를 사용할 수 있게 되었다.(기본형은 제네릭 형식 사용불가)

    만약 자바가 ArrayList<int>를 지원한다고 하면 어떻게 될까?

    이는 불가능하다. 불행하게도 가비지 컬렉션 때문이다.

    런타임에 ArrayList의 콘텐츠 형식 정보를 확인할 수 없으므로 ArrayList에 13이라는 요소가 Integer 참조인지(GC가 사용중으로 표시) 아니면 int 기본값인지(GC 수행 불가) 분간할 수 없다.

C#에서는 String, Integer, int를 담은 ArrayList가 각각 다른 의미를 갖는다.

하지만 자바처럼 이와 같은 선언이 모두 같은 상황이라면 가비지 컬레션이 필드가 참조형인지 기본형인지 알 수 없도록 충분한 형식 정보를 런타임에 유지해야 한다.<br>
이를 제네릭 `다형성 구체화 모델` 또는 줄여서 `구체와된 제네릭`이라고 부른다.
> 구체화란 암묵적인 어떤 것을 명시적으로 바꾼다는 의미다.

---

이제 제네릭의 기본형과 기본형에 대응하는 객체형에서 발생하는 문제를 살펴볼 것이다.

`제네릭이 함수 형식에 제공하는 문법적 유연성`

기본적으로 자바 8 람다는 코드 구현을 풍부하게 할 수 있도록 해주었지만 형식 시스템은 코드 유연성을 따라잡지 못하고 있다.

`기본형 특화와 제네릭`

자바의 모든 기본형에는 대응하는 객체형이 존재한다. 이를 unboxed type과 boxed type이라고 부른다.

이와 같은 구분으로 런타임 효율성은 조금 증가했지만 형식은 오히려 혼란스러워졌다.

### 21.4.4 더 근본적인 불변성 지원

자바에서 함수형 프로그래밍을 구현하려면 '불변값'을 언어적으로 지원해야 한다.

final로는 필드값 갱신만 막을 수 있으므로 final만으로 불변값이라는 목표를 달성하긴 어렵다.

    final int[] arr = {1,2,3};

    arr = ... 같이 다른 값은 할당할 수 없지만
    arr[1] = 2 처럼 요소는 바꿀 수 있다.

### 21.4.5 값 형식

이 절에서는 기본형과 객체형의 차이점을 살펴보면서 값 형식이 필요한 이유를 설명한다.

`컴파일러가 Integer과 int를 같은 값으로 취급할 수는 없을까?`

상당히 괜찮은 아이디어지만 실현은 쉽지 않다.

```java
double d1=3.14;
double d2=d1;
Double o1=d1;
Double o2=d2;
Double ox=o1;
System.out.println(d1==d2?"yes":"no"); // yes
System.out.println(o1==p2?"yes":"no"); // no
System.out.println(o1==ox?"yes":"no"); // yes
```

마지막 두행은 ==말고 equals를 사용해야 한다.

기본형에서는 비트를 비교해서 같음을 판단하지만, 객체에서는 참조로 같음을 판단한다.

`박싱, 제네릭, 값 형식: 상호 의존 문제`

함수형 프로그래밍에서는 식별자가 없는 불변값을 이용하므로 자바에서 값 형식을 지원한다면 좋을 것이다.

## 21.5 더 빠르게 발전하는 자바

(다양한 이유로) 자바는 6개월 개발 주기를 갖기로 결정했다.

그리고 자바 아키텍트는 매 3년마다 이후 3년 동안 지원을 보장하는 장기 지원(LTS) 릴리스도 결정했다.

## 21.6 결론

이 책에서는 자바 8, 자바 9에 추가된 주요 새 기능을 살펴봤다.

자바 5 - 제네릭

자바 8 - 동작 파라미터화, 람다, 메서드 참조, 스트림, 디폴트 메서드, Optional

자바 9 - 자바 모듈 시스템, Flow API

자바 10 - 다른 언어에서 생상성을 높이도록 지원하기 시작한 지역 변수형 추론 기능 도입

자바 11 - 암묵적 형식의 람다 표현식의 파라미터 목록에 지역 변수형 문법을 사용할 수 있도록 지원, 동시성과 리액티브 프로그래밍 사상을 CompletableFuture를 온전히 적용한 새로운 비동기 HTTP 클라이언트로 제공할 것

자바 12 - 함수형 프로그래밍 언어의 핵심 기능으로 switch 구문에 구분 대신 표현식을 사용할 수 있도록 허용할 것이다.

이런 모든 업데이트는 함수형 프로그래밍 사상과 영향이 자바의 미래에도 계속 적용될 것임을 보여준다!